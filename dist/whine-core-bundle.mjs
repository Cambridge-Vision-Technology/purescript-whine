#!/usr/bin/env node
/* Generated by Spago v0.93.44 */import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));const __filename=new URL(import.meta.url).pathname
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod5) => function __require2() {
  return mod5 || (0, cb[__getOwnPropNames(cb)[0]])((mod5 = { exports: {} }).exports, mod5), mod5.exports;
};
var __copyProps = (to2, from3, except3, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to2, key) && key !== except3)
        __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod5, isNodeMode, target) => (target = mod5 != null ? __create(__getProtoOf(mod5)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod5 || !mod5.__esModule ? __defProp(target, "default", { value: mod5, enumerable: true }) : target,
  mod5
));

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min5, max4, step3 = 1, limit) => {
      if (limit === false) return false;
      if (!exports.isInteger(min5) || !exports.isInteger(max4)) return false;
      return (Number(max4) - Number(min5)) / Number(step3) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      const node = block.nodes[n];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = (ast, options = {}) => {
      const stringify2 = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber2 = require_is_number();
    var toRegexRange = (min5, max4, options) => {
      if (isNumber2(min5) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max4 === void 0 || min5 === max4) {
        return String(min5);
      }
      if (isNumber2(max4) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap4 = String(opts.wrap);
      let cacheKey = min5 + ":" + max4 + "=" + relax + shorthand + capture + wrap4;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min5, max4);
      let b = Math.max(min5, max4);
      if (Math.abs(a - b) === 1) {
        let result = min5 + "|" + max4;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min5) || hasPadding(max4);
      let state2 = { min: min5, max: max4, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state2.isPadded = isPadded;
        state2.maxLen = String(state2.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state2, opts);
        a = state2.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state2, opts);
      }
      state2.negatives = negatives;
      state2.positives = positives;
      state2.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state2.result = `(${state2.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state2.result = `(?:${state2.result})`;
      }
      toRegexRange.cache[cacheKey] = state2;
      return state2.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min5, max4) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min5, nines);
      let stops = /* @__PURE__ */ new Set([max4]);
      while (min5 <= stop && stop <= max4) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min5, nines);
      }
      stop = countZeros(max4 + 1, zeros) - 1;
      while (min5 < stop && stop <= max4) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max4 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare5);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip2(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min5, max4, tok, options) {
      let ranges = splitToRanges(min5, max4);
      let tokens = [];
      let start = min5;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max5 = ranges[i];
        let obj = rangeToPattern(String(start), String(max5), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max5 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max5, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max5 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix2, intersection3, options) {
      let result = [];
      for (let ele of arr) {
        let { string: string5 } = ele;
        if (!intersection3 && !contains3(comparison, "string", string5)) {
          result.push(prefix2 + string5);
        }
        if (intersection3 && contains3(comparison, "string", string5)) {
          result.push(prefix2 + string5);
        }
      }
      return result;
    }
    function zip2(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
      return arr;
    }
    function compare5(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains3(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min5, len) {
      return Number(String(min5).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros(value3, tok, options) {
      if (!tok.isPadded) {
        return value3;
      }
      let diff = Math.abs(tok.maxLen - String(value3).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber3) => {
      return (value3) => toNumber3 === true ? Number(value3) : String(value3);
    };
    var isValidValue = (value3) => {
      return typeof value3 === "number" || typeof value3 === "string" && value3 !== "";
    };
    var isNumber2 = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value3 = `${input}`;
      let index5 = -1;
      if (value3[0] === "-") value3 = value3.slice(1);
      if (value3 === "0") return false;
      while (value3[++index5] === "0") ;
      return index5 > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber3) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber3 === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix2 = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix2}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix2}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap4 = options.wrap === true;
        let prefix2 = options.capture ? "" : "?:";
        return wrap4 ? `(${prefix2}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step3, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step3}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step3 = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a === 0) a = 0;
      if (b === 0) b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step3);
      step3 = Math.max(Math.abs(step3), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber3 = padded === false && stringify2(start, end, options) === false;
      let format2 = options.transform || transform(toNumber3);
      if (options.toRegex && step3 === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range3 = [];
      let index5 = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step3 > 1) {
          push2(a);
        } else {
          range3.push(pad(format2(a, index5), maxLen, toNumber3));
        }
        a = descending ? a - step3 : a + step3;
        index5++;
      }
      if (options.toRegex === true) {
        return step3 > 1 ? toSequence(parts, options, maxLen) : toRegex(range3, null, { wrap: false, ...options });
      }
      return range3;
    };
    var fillLetters = (start, end, step3 = 1, options = {}) => {
      if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format2 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min5 = Math.min(a, b);
      let max4 = Math.max(a, b);
      if (options.toRegex && step3 === 1) {
        return toRange(min5, max4, false, options);
      }
      let range3 = [];
      let index5 = 0;
      while (descending ? a >= b : a <= b) {
        range3.push(format2(a, index5));
        a = descending ? a - step3 : a + step3;
        index5++;
      }
      if (options.toRegex === true) {
        return toRegex(range3, null, { wrap: false, options });
      }
      return range3;
    };
    var fill = (start, end, step3, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step3 === "function") {
        return fill(start, end, 1, { transform: step3 });
      }
      if (isObject2(step3)) {
        return fill(start, end, 0, step3);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step3 = step3 || opts.step || 1;
      if (!isNumber2(step3)) {
        if (step3 != null && !isObject2(step3)) return invalidStep(step3, opts);
        return fill(start, end, 1, step3);
      }
      if (isNumber2(start) && isNumber2(end)) {
        return fillNumbers(start, end, step3, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step3), 1), opts);
    };
    module.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      const walk = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix2 = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix2 + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix2, node.value);
          return prefix2 + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix2 + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix2 + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range3 = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range3.length !== 0) {
            return args.length > 1 && range3.length > 1 ? `(${range3})` : range3;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils();
    var append11 = (queue = "", stash = "", enclose2 = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose2 ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value3 of item) {
            result.push(append11(value3, stash, enclose2));
          }
        } else {
          for (let ele of stash) {
            if (enclose2 === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append11(item, ele, enclose2) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand2 = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append11(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append11(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range3 = fill(...args, options);
          if (range3.length === 0) {
            range3 = stringify2(node, options);
          }
          q.push(append11(q.pop(), range3));
          node.nodes = [];
          return;
        }
        const enclose2 = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          const child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append11(q.pop(), queue, enclose2));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append11(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand2;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse3 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max4) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max4})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets2 = 0;
      const length9 = input.length;
      let index5 = 0;
      let depth = 0;
      let value3;
      const advance = () => input[index5++];
      const push2 = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push2({ type: "bos" });
      while (index5 < length9) {
        block = stack[stack.length - 1];
        value3 = advance();
        if (value3 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value3 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value3 === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options.keepEscaping ? value3 : "") + advance() });
          continue;
        }
        if (value3 === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value3 });
          continue;
        }
        if (value3 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets2++;
          let next2;
          while (index5 < length9 && (next2 = advance())) {
            value3 += next2;
            if (next2 === CHAR_LEFT_SQUARE_BRACKET) {
              brackets2++;
              continue;
            }
            if (next2 === CHAR_BACKSLASH) {
              value3 += advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets2--;
              if (brackets2 === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value3 });
          continue;
        }
        if (value3 === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value3 });
          continue;
        }
        if (value3 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value3 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value3 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value3 === CHAR_DOUBLE_QUOTE || value3 === CHAR_SINGLE_QUOTE || value3 === CHAR_BACKTICK) {
          const open = value3;
          let next2;
          if (options.keepQuotes !== true) {
            value3 = "";
          }
          while (index5 < length9 && (next2 = advance())) {
            if (next2 === CHAR_BACKSLASH) {
              value3 += next2 + advance();
              continue;
            }
            if (next2 === open) {
              if (options.keepQuotes === true) value3 += next2;
              break;
            }
            value3 += next2;
          }
          push2({ type: "text", value: value3 });
          continue;
        }
        if (value3 === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value3 });
          continue;
        }
        if (value3 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value3 });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value3 });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value3 === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify2(block) }];
          }
          push2({ type: "comma", value: value3 });
          block.commas++;
          continue;
        }
        if (value3 === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push2({ type: "text", value: value3 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value3;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value3;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value3 });
          continue;
        }
        push2({ type: "text", value: value3 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index6 = parent.nodes.indexOf(block);
          parent.nodes.splice(index6, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    module.exports = parse3;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand2 = require_expand();
    var parse3 = require_parse();
    var braces2 = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces2.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces2.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces2.parse = (input, options = {}) => parse3(input, options);
    braces2.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces2.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces2.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      return compile(input, options);
    };
    braces2.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      let result = expand2(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces2.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces2.compile(input, options) : braces2.expand(input, options);
    };
    module.exports = braces2;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path3 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path3.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path3 = __require("path");
    var win322 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
    exports.isRegexChar = (str2) => str2.length === 1 && exports.hasRegexChars(str2);
    exports.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str2) => {
      return str2.replace(REGEX_REMOVE_BACKSLASH, (match3) => {
        return match3 === "\\" ? "" : match3;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path3.sep === "\\";
    };
    exports.escapeLast = (input, char2, lastIdx) => {
      const idx = input.lastIndexOf(char2, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports.escapeLast(input, char2, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state2 = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state2.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state2 = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append11 = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append11}`;
      if (state2.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length9 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index5 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index5 >= length9;
      const peek2 = () => str2.charCodeAt(index5 + 1);
      const advance = () => {
        prev = code;
        return str2.charCodeAt(++index5);
      };
      while (index5 < length9) {
        code = advance();
        let next2;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index5);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index5 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index5 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob = token2.isGlob = true;
            isExtglob = token2.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index5 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token2.isGlobstar = true;
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next2 = advance())) {
            if (next2 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index5 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str2;
      let prefix2 = "";
      let glob3 = "";
      if (start > 0) {
        prefix2 = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob3 = str2.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob3 = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob3) glob3 = utils.removeBackslashes(glob3);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state2 = {
        prefix: prefix2,
        input,
        start,
        base,
        glob: glob3,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state2.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token2);
        }
        state2.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value3 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix2;
            } else {
              tokens[idx].value = value3;
            }
            depth(tokens[idx]);
            state2.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value3 !== "") {
            parts.push(value3);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value3 = input.slice(prevIndex + 1);
          parts.push(value3);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value3;
            depth(tokens[tokens.length - 1]);
            state2.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state2.slashes = slashes;
        state2.parts = parts;
      }
      return state2;
    };
    module.exports = scan;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants2 = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants2;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value3 = `[${args.join("-")}]`;
      try {
        new RegExp(value3);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value3;
    };
    var syntaxError = (type, char2) => {
      return `Missing ${type}: "${char2}" - use "\\\\${char2}" to match literal characters`;
    };
    var parse3 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils.isWindows(options);
      const PLATFORM_CHARS = constants2.globChars(win322);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star3 = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state2 = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state2);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value3;
      const eos = () => state2.index === len - 1;
      const peek2 = state2.peek = (n = 1) => input[state2.index + n];
      const advance = state2.advance = () => input[++state2.index] || "";
      const remaining = () => input.slice(state2.index + 1);
      const consume = (value4 = "", num = 0) => {
        state2.consumed += value4;
        state2.index += num;
      };
      const append11 = (token2) => {
        state2.output += token2.output != null ? token2.output : token2.value;
        consume(token2.value);
      };
      const negate2 = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state2.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state2.negated = true;
        state2.start++;
        return true;
      };
      const increment = (type) => {
        state2[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state2[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state2.output = state2.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star3;
            state2.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append11(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value4) => {
        const token2 = { ...EXTGLOB_CHARS[value4], conditions: 1, inner: "" };
        token2.prev = prev;
        token2.parens = state2.parens;
        token2.output = state2.output;
        const output = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push2({ type, value: value4, output: state2.output ? "" : ONE_CHAR });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output = token2.close + (opts.capture ? ")" : "");
        let rest;
        if (token2.type === "negate") {
          let extglobStar = star3;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
            output = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse3(rest, { ...options, fastpaths: false }).output;
            output = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state2.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value3, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index5) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index5 === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star3 : "");
            }
            return star3;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state2.output = input;
          return state2;
        }
        state2.output = utils.wrapOutput(output, state2, options);
        return state2;
      }
      while (!eos()) {
        value3 = advance();
        if (value3 === "\0") {
          continue;
        }
        if (value3 === "\\") {
          const next2 = peek2();
          if (next2 === "/" && opts.bash !== true) {
            continue;
          }
          if (next2 === "." || next2 === ";") {
            continue;
          }
          if (!next2) {
            value3 += "\\";
            push2({ type: "text", value: value3 });
            continue;
          }
          const match3 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match3 && match3[0].length > 2) {
            slashes = match3[0].length;
            state2.index += slashes;
            if (slashes % 2 !== 0) {
              value3 += "\\";
            }
          }
          if (opts.unescape === true) {
            value3 = advance();
          } else {
            value3 += advance();
          }
          if (state2.brackets === 0) {
            push2({ type: "text", value: value3 });
            continue;
          }
        }
        if (state2.brackets > 0 && (value3 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value3 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state2.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value3 === "[" && peek2() !== ":" || value3 === "-" && peek2() === "]") {
            value3 = `\\${value3}`;
          }
          if (value3 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value3 = `\\${value3}`;
          }
          if (opts.posix === true && value3 === "!" && prev.value === "[") {
            value3 = "^";
          }
          prev.value += value3;
          append11({ value: value3 });
          continue;
        }
        if (state2.quotes === 1 && value3 !== '"') {
          value3 = utils.escapeRegex(value3);
          prev.value += value3;
          append11({ value: value3 });
          continue;
        }
        if (value3 === '"') {
          state2.quotes = state2.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value3 });
          }
          continue;
        }
        if (value3 === "(") {
          increment("parens");
          push2({ type: "paren", value: value3 });
          continue;
        }
        if (value3 === ")") {
          if (state2.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state2.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value3, output: state2.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value3 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value3 = `\\${value3}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value3 });
          continue;
        }
        if (value3 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value3, output: `\\${value3}` });
            continue;
          }
          if (state2.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value: value3, output: `\\${value3}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value3 = `/${value3}`;
          }
          prev.value += value3;
          append11({ value: value3 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state2.output = state2.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state2.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state2.output += prev.value;
          continue;
        }
        if (value3 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value: value3,
            output: "(",
            outputIndex: state2.output.length,
            tokensIndex: state2.tokens.length
          };
          braces2.push(open);
          push2(open);
          continue;
        }
        if (value3 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value3, output: value3 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range3 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range3.unshift(arr[i].value);
              }
            }
            output = expandRange(range3, opts);
            state2.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state2.output.slice(0, brace.outputIndex);
            const toks = state2.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value3 = output = "\\}";
            state2.output = out;
            for (const t of toks) {
              state2.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value3, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value3 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value3 });
          continue;
        }
        if (value3 === ",") {
          let output = value3;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value3, output });
          continue;
        }
        if (value3 === "/") {
          if (prev.type === "dot" && state2.index === state2.start + 1) {
            state2.start = state2.index + 1;
            state2.consumed = "";
            state2.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value3, output: SLASH_LITERAL });
          continue;
        }
        if (value3 === ".") {
          if (state2.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value3;
            prev.value += value3;
            brace.dots = true;
            continue;
          }
          if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value3, output: DOT_LITERAL });
            continue;
          }
          push2({ type: "dot", value: value3, output: DOT_LITERAL });
          continue;
        }
        if (value3 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value3);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next2 = peek2();
            let output = value3;
            if (next2 === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next2) || next2 === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value3}`;
            }
            push2({ type: "text", value: value3, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value3, output: QMARK_NO_DOT });
            continue;
          }
          push2({ type: "qmark", value: value3, output: QMARK });
          continue;
        }
        if (value3 === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value3);
              continue;
            }
          }
          if (opts.nonegate !== true && state2.index === 0) {
            negate2();
            continue;
          }
        }
        if (value3 === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value3);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value3, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
            push2({ type: "plus", value: value3 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value3 === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: true, value: value3, output: "" });
            continue;
          }
          push2({ type: "text", value: value3 });
          continue;
        }
        if (value3 !== "*") {
          if (value3 === "$" || value3 === "^") {
            value3 = `\\${value3}`;
          }
          const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match3) {
            value3 += match3[0];
            state2.index += match3[0].length;
          }
          push2({ type: "text", value: value3 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value3;
          prev.output = star3;
          state2.backtrack = true;
          state2.globstar = true;
          consume(value3);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value3);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value3);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value3, output: "" });
            continue;
          }
          const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push2({ type: "star", value: value3, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state2.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value3;
            prev.output = globstar(opts);
            state2.output = prev.output;
            state2.globstar = true;
            consume(value3);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value3;
            state2.globstar = true;
            state2.output += prior.output + prev.output;
            consume(value3);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value3;
            state2.output += prior.output + prev.output;
            state2.globstar = true;
            consume(value3 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value3;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state2.output = prev.output;
            state2.globstar = true;
            consume(value3 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state2.output = state2.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value3;
          state2.output += prev.output;
          state2.globstar = true;
          consume(value3);
          continue;
        }
        const token2 = { type: "star", value: value3, output: star3 };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push2(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value3;
          push2(token2);
          continue;
        }
        if (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state2.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state2.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state2.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state2.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push2(token2);
      }
      while (state2.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state2.output = utils.escapeLast(state2.output, "[");
        decrement("brackets");
      }
      while (state2.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state2.output = utils.escapeLast(state2.output, "(");
        decrement("parens");
      }
      while (state2.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state2.output = utils.escapeLast(state2.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state2.backtrack === true) {
        state2.output = "";
        for (const token2 of state2.tokens) {
          state2.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state2.output += token2.suffix;
          }
        }
      }
      return state2;
    };
    parse3.fastpaths = (input, options) => {
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants2.globChars(win322);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state2 = { negated: false, prefix: "" };
      let star3 = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star3;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create3 = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR}${star3}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
          default: {
            const match3 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match3) return;
            const source3 = create3(match3[1]);
            if (!source3) return;
            return source3 + DOT_LITERAL + match3[2];
          }
        }
      };
      const output = utils.removePrefix(input, state2);
      let source2 = create3(output);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL}?`;
      }
      return source2;
    };
    module.exports = parse3;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path3 = __require("path");
    var scan = require_scan();
    var parse3 = require_parse2();
    var utils = require_utils2();
    var constants2 = require_constants2();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob3, options, returnState = false) => {
      if (Array.isArray(glob3)) {
        const fns = glob3.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state3 = isMatch(str2);
            if (state3) return state3;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob3) && glob3.tokens && glob3.input;
      if (glob3 === "" || typeof glob3 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = utils.isWindows(options);
      const regex4 = isState ? picomatch.compileRe(glob3, options) : picomatch.makeRe(glob3, options, false, true);
      const state2 = regex4.state;
      delete regex4.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match3, output } = picomatch.test(input, regex4, options, { glob: glob3, posix: posix2 });
        const result = { glob: glob3, state: state2, regex: regex4, posix: posix2, input, output, match: match3, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state2;
      }
      return matcher;
    };
    picomatch.test = (input, regex4, options, { glob: glob3, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format2 = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match3 = input === glob3;
      let output = match3 && format2 ? format2(input) : input;
      if (match3 === false) {
        output = format2 ? format2(input) : input;
        match3 = output === glob3;
      }
      if (match3 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match3 = picomatch.matchBase(input, regex4, options, posix2);
        } else {
          match3 = regex4.exec(output);
        }
      }
      return { isMatch: Boolean(match3), match: match3, output };
    };
    picomatch.matchBase = (input, glob3, options, posix2 = utils.isWindows(options)) => {
      const regex4 = glob3 instanceof RegExp ? glob3 : picomatch.makeRe(glob3, options);
      return regex4.test(path3.basename(input));
    };
    picomatch.isMatch = (str2, patterns, options) => picomatch(patterns, options)(str2);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse3(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state2, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state2.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append11 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state2.output})${append11}`;
      if (state2 && state2.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex4 = picomatch.toRegex(source2, options);
      if (returnState === true) {
        regex4.state = state2;
      }
      return regex4;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse3.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse3(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source2, options) => {
      try {
        const opts = options || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants2;
    module.exports = picomatch;
  }
});

// node_modules/micromatch/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var braces2 = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (v) => v === "" || v === "./";
    var hasBraces = (v) => {
      const index5 = v.indexOf("{");
      return index5 > -1 && v.indexOf("}", index5) > -1;
    };
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state2) => {
        items.add(state2.output);
        if (options && options.onResult) {
          options.onResult(state2);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match3 = negated ? !matched.isMatch : matched.isMatch;
          if (!match3) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str2, patterns, options) => picomatch(patterns, options)(str2);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state2) => {
        if (options.onResult) options.onResult(state2);
        items.push(state2.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str2, pattern, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str2, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str2) || isEmptyString(pattern)) {
          return false;
        }
        if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str2, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys4 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys4) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str2, patterns, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str2));
    };
    micromatch.capture = (glob3, input, options) => {
      let posix2 = utils.isWindows(options);
      let regex4 = picomatch.makeRe(String(glob3), { ...options, capture: true });
      let match3 = regex4.exec(posix2 ? utils.toPosixSlashes(input) : input);
      if (match3) {
        return match3.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str2 of braces2(String(pattern), options)) {
          res.push(picomatch.parse(str2, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !hasBraces(pattern)) {
        return [pattern];
      }
      return braces2(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    micromatch.hasBraces = hasBraces;
    module.exports = micromatch;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str2) {
      if (a instanceof RegExp) a = maybeMatch(a, str2);
      if (b instanceof RegExp) b = maybeMatch(b, str2);
      var r = range3(a, b, str2);
      return r && {
        start: r[0],
        end: r[1],
        pre: str2.slice(0, r[0]),
        body: str2.slice(r[0] + a.length, r[1]),
        post: str2.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str2) {
      var m = str2.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range3;
    function range3(a, b, str2) {
      var begs, beg, left, right, result;
      var ai = str2.indexOf(a);
      var bi = str2.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str2.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str2.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str2.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str2) {
      return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
    }
    function escapeBraces(str2) {
      return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str2) {
      return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str2) {
      if (!str2)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str2);
      if (!m)
        return str2.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str2) {
      if (!str2)
        return [];
      if (str2.substr(0, 2) === "{}") {
        str2 = "\\{\\}" + str2.substr(2);
      }
      return expand2(escapeBraces(str2), true).map(unescapeBraces);
    }
    function embrace(str2) {
      return "{" + str2 + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str2, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str2);
      if (!m) return [str2];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str2 = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str2);
          }
          return [str2];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width2 = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test3 = lte;
          var reverse3 = y < x;
          if (reverse3) {
            incr *= -1;
            test3 = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test3(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width2 - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity17.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path3) {
      const ctrl = callVisitor(key, node, visitor, path3);
      if (identity17.isNode(ctrl) || identity17.isPair(ctrl)) {
        replaceNode(key, path3, ctrl);
        return visit_(key, ctrl, visitor, path3);
      }
      if (typeof ctrl !== "symbol") {
        if (identity17.isCollection(node)) {
          path3 = Object.freeze(path3.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path3);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity17.isPair(node)) {
          path3 = Object.freeze(path3.concat(node));
          const ck = visit_("key", node.key, visitor, path3);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path3);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity17.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path3) {
      const ctrl = await callVisitor(key, node, visitor, path3);
      if (identity17.isNode(ctrl) || identity17.isPair(ctrl)) {
        replaceNode(key, path3, ctrl);
        return visitAsync_(key, ctrl, visitor, path3);
      }
      if (typeof ctrl !== "symbol") {
        if (identity17.isCollection(node)) {
          path3 = Object.freeze(path3.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path3);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity17.isPair(node)) {
          path3 = Object.freeze(path3.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path3);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path3);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path3) {
      if (typeof visitor === "function")
        return visitor(key, node, path3);
      if (identity17.isMap(node))
        return visitor.Map?.(key, node, path3);
      if (identity17.isSeq(node))
        return visitor.Seq?.(key, node, path3);
      if (identity17.isPair(node))
        return visitor.Pair?.(key, node, path3);
      if (identity17.isScalar(node))
        return visitor.Scalar?.(key, node, path3);
      if (identity17.isAlias(node))
        return visitor.Alias?.(key, node, path3);
      return void 0;
    }
    function replaceNode(key, path3, node) {
      const parent = path3[path3.length - 1];
      if (identity17.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity17.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity17.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity17.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line2, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line2.trim().split(/[ \t]+/);
        const name3 = parts.shift();
        switch (name3) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix2] = parts;
            this.tags[handle] = prefix2;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name3}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source2, onError) {
        if (source2 === "!")
          return "!";
        if (source2[0] !== "!") {
          onError(`Not a valid tag: ${source2}`);
          return null;
        }
        if (source2[1] === "<") {
          const verbatim = source2.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
            return null;
          }
          if (source2[source2.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source2.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source2} tag has no suffix`);
        const prefix2 = this.tags[handle];
        if (prefix2) {
          try {
            return prefix2 + decodeURIComponent(suffix);
          } catch (error5) {
            onError(String(error5));
            return null;
          }
        }
        if (handle === "!")
          return source2;
        onError(`Could not resolve tag: ${source2}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix2] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix2))
            return handle + escapeTagName(tag.substring(prefix2.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines2 = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity17.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity17.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix2] of tagEntries) {
          if (handle === "!!" && prefix2 === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix2)))
            lines2.push(`%TAG ${handle} ${prefix2}`);
        }
        return lines2.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix2, exclude) {
      for (let i = 1; true; ++i) {
        const name3 = `${prefix2}${i}`;
        if (!exclude.has(name3))
          return name3;
      }
    }
    function createNodeAnchors(doc, prefix2) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source2) => {
          aliasObjects.push(source2);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix2, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source2 of aliasObjects) {
            const ref = sourceObjects.get(source2);
            if (typeof ref === "object" && ref.anchor && (identity17.isScalar(ref.node) || identity17.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error5 = new Error("Failed to resolve repeated object (this should not happen)");
              error5.source = source2;
              throw error5;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    function toJS(value3, arg, ctx) {
      if (Array.isArray(value3))
        return value3.map((v, i) => toJS(v, String(i), ctx));
      if (value3 && typeof value3.toJSON === "function") {
        if (!ctx || !identity17.hasAnchor(value3))
          return value3.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value3, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value3.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value3 === "bigint" && !ctx?.keep)
        return Number(value3);
      return value3;
    }
    exports.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity17 = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity17.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity17.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity17 = require_identity();
    var Node2 = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node2.NodeBase {
      constructor(source2) {
        super(identity17.ALIAS);
        this.source = source2;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source2 = this.resolve(doc);
        if (!source2) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source2);
        if (!data) {
          toJS.toJS(source2, null, ctx);
          data = anchors2.get(source2);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source2, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity17.isAlias(node)) {
        const source2 = node.resolve(doc);
        const anchor = anchors2 && source2 && anchors2.get(source2);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity17.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity17.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Node2 = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value3) => !value3 || typeof value3 !== "function" && typeof value3 !== "object";
    var Scalar = class extends Node2.NodeBase {
      constructor(value3) {
        super(identity17.SCALAR);
        this.value = value3;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value3, tagName, tags) {
      if (tagName) {
        const match3 = tags.filter((t) => t.tag === tagName);
        const tagObj = match3.find((t) => !t.format) ?? match3[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value3) && !t.format);
    }
    function createNode(value3, tagName, ctx) {
      if (identity17.isDocument(value3))
        value3 = value3.contents;
      if (identity17.isNode(value3))
        return value3;
      if (identity17.isPair(value3)) {
        const map47 = ctx.schema[identity17.MAP].createNode?.(ctx.schema, null, ctx);
        map47.items.push(value3);
        return map47;
      }
      if (value3 instanceof String || value3 instanceof Number || value3 instanceof Boolean || typeof BigInt !== "undefined" && value3 instanceof BigInt) {
        value3 = value3.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value3 && typeof value3 === "object") {
        ref = sourceObjects.get(value3);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value3);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value3, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value3, tagName, schema.tags);
      if (!tagObj) {
        if (value3 && typeof value3.toJSON === "function") {
          value3 = value3.toJSON();
        }
        if (!value3 || typeof value3 !== "object") {
          const node2 = new Scalar.Scalar(value3);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value3 instanceof Map ? schema[identity17.MAP] : Symbol.iterator in Object(value3) ? schema[identity17.SEQ] : schema[identity17.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value3, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value3, ctx) : new Scalar.Scalar(value3);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity17 = require_identity();
    var Node2 = require_Node();
    function collectionFromPath(schema, path3, value3) {
      let v = value3;
      for (let i = path3.length - 1; i >= 0; --i) {
        const k = path3[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path3) => path3 == null || typeof path3 === "object" && !!path3[Symbol.iterator]().next().done;
    var Collection = class extends Node2.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity17.isNode(it) || identity17.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path3, value3) {
        if (isEmptyPath(path3))
          this.add(value3);
        else {
          const [key, ...rest] = path3;
          const node = this.get(key, true);
          if (identity17.isCollection(node))
            node.addIn(rest, value3);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value3));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path3) {
        const [key, ...rest] = path3;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity17.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path3, keepScalar) {
        const [key, ...rest] = path3;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity17.isScalar(node) ? node.value : node;
        else
          return identity17.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity17.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity17.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path3) {
        const [key, ...rest] = path3;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity17.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path3, value3) {
        const [key, ...rest] = path3;
        if (rest.length === 0) {
          this.set(key, value3);
        } else {
          const node = this.get(key, true);
          if (identity17.isCollection(node))
            node.setIn(rest, value3);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value3));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment2, indent2) {
      if (/^\n+$/.test(comment2))
        return comment2.substring(1);
      return indent2 ? comment2.replace(/^(?! *$)/gm, indent2) : comment2;
    }
    var lineComment2 = (str2, indent2, comment2) => str2.endsWith("\n") ? indentComment(comment2, indent2) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent2) : (str2.endsWith(" ") ? "" : " ") + comment2;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment2;
    exports.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text2, indent2, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text2;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent2.length);
      if (text2.length <= endStep)
        return text2;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent2.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split3 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text2, i, indent2.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text2[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text2[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text2, i, indent2.length);
          end = i + indent2.length + endStep;
          split3 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next2 = text2[i + 1];
            if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
              split3 = i;
          }
          if (i >= end) {
            if (split3) {
              folds.push(split3);
              end = split3 + endStep;
              split3 = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text2[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text2;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split3 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text2;
      if (onFold)
        onFold();
      let res = text2.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold20 = folds[i2];
        const end2 = folds[i2 + 1] || text2.length;
        if (fold20 === 0)
          res = `
${indent2}${text2.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold20])
            res += `${text2[fold20]}\\`;
          res += `
${indent2}${text2.slice(fold20 + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text2, i, indent2) {
      let end = i;
      let start = i + 1;
      let ch = text2[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent2) {
          ch = text2[++i];
        } else {
          do {
            ch = text2[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text2[start];
        }
      }
      return end;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value3, ctx) {
      const json2 = JSON.stringify(value3);
      if (ctx.options.doubleQuotedAsJSON)
        return json2;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent2 = ctx.indent || (containsDocumentMarker(value3) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str2 += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json2[i + 1]) {
            case "u":
              {
                str2 += json2.slice(start, i);
                const code = json2.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str2 += "\\x" + code.substr(2);
                    else
                      str2 += json2.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json2.slice(start, i) + "\n\n";
                while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent2;
                if (json2[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json2.slice(start) : json2;
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent2, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value3, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value3.includes("\n") || /[ \t]\n|\n[ \t]/.test(value3))
        return doubleQuotedString(value3, ctx);
      const indent2 = ctx.indent || (containsDocumentMarker(value3) ? "  " : "");
      const res = "'" + value3.replace(/'/g, "''").replace(/\n+/g, `$&
${indent2}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value3, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value3.includes('"');
        const hasSingle = value3.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value3, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment: comment2, type, value: value3 }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value3) || /^\s*$/.test(value3)) {
        return quotedString(value3, ctx);
      }
      const indent2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value3) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value3, lineWidth, indent2.length);
      if (!value3)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value3.length; endStart > 0; --endStart) {
        const ch = value3[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value3.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value3 === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value3 = value3.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent2}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value3.length; ++startEnd) {
        const ch = value3[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value3.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value3 = value3.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent2}`);
      }
      const indentSize = indent2 ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment2) {
        header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value3.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent2}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent2, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent2}${body}`;
      }
      value3 = value3.replace(/\n+/g, `$&${indent2}`);
      return `|${header}
${indent2}${start}${value3}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value: value3 } = item;
      const { actualString, implicitKey, indent: indent2, indentStep, inFlow } = ctx;
      if (implicitKey && value3.includes("\n") || inFlow && /[[\]{},]/.test(value3)) {
        return quotedString(value3, ctx);
      }
      if (!value3 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value3)) {
        return implicitKey || inFlow || !value3.includes("\n") ? quotedString(value3, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value3.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value3)) {
        if (indent2 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent2 === indentStep) {
          return quotedString(value3, ctx);
        }
      }
      const str2 = value3.replace(/\n+/g, `$&
${indent2}`);
      if (actualString) {
        const test3 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str2);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test3) || compat?.some(test3))
          return quotedString(value3, ctx);
      }
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity17 = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match3 = tags.filter((t) => t.tag === item.tag);
        if (match3.length > 0)
          return match3.find((t) => t.format === item.format) ?? match3[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity17.isScalar(item)) {
        obj = item.value;
        let match3 = tags.filter((t) => t.identify?.(obj));
        if (match3.length > 1) {
          const testMatch = match3.filter((t) => t.test);
          if (testMatch.length > 0)
            match3 = testMatch;
        }
        tagObj = match3.find((t) => t.format === item.format) ?? match3.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name3 = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name3} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity17.isScalar(node) || identity17.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify2(item, ctx, onComment, onChompKeep) {
      if (identity17.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity17.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity17.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity17.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return identity17.isScalar(node) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var stringify2 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value: value3 }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity17.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity17.isCollection(key) || !identity17.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value3 == null && !ctx.inFlow || identity17.isCollection(key) || (identity17.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent2 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str2 = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value3 == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
        }
      } else if (allNullValues && !simpleKeys || value3 == null && explicitKey) {
        str2 = `? ${str2}`;
        if (keyComment && !keyCommentDone) {
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        str2 = `? ${str2}
${indent2}:`;
      } else {
        str2 = `${str2}:`;
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity17.isNode(value3)) {
        vsb = !!value3.spaceBefore;
        vcb = value3.commentBefore;
        valueComment = value3.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value3 && typeof value3 === "object")
          value3 = doc.createNode(value3);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity17.isScalar(value3))
        ctx.indentAtStart = str2.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity17.isSeq(value3) && !value3.flow && !value3.tag && !value3.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify2.stringify(value3, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity17.isCollection(value3)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value3.flow ?? value3.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str2 += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str2;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    function debug3(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn3(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug3;
    exports.warn = warn3;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge5 = {
      identify: (value3) => value3 === MERGE_KEY || typeof value3 === "symbol" && value3.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge5.identify(key) || identity17.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge5.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge5.tag && tag.default);
    function addMergeToJSMap(ctx, map47, value3) {
      value3 = ctx && identity17.isAlias(value3) ? value3.resolve(ctx.doc) : value3;
      if (identity17.isSeq(value3))
        for (const it of value3.items)
          mergeValue(ctx, map47, it);
      else if (Array.isArray(value3))
        for (const it of value3)
          mergeValue(ctx, map47, it);
      else
        mergeValue(ctx, map47, value3);
    }
    function mergeValue(ctx, map47, value3) {
      const source2 = ctx && identity17.isAlias(value3) ? value3.resolve(ctx.doc) : value3;
      if (!identity17.isMap(source2))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source2.toJSON(null, ctx, Map);
      for (const [key, value4] of srcMap) {
        if (map47 instanceof Map) {
          if (!map47.has(key))
            map47.set(key, value4);
        } else if (map47 instanceof Set) {
          map47.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map47, key)) {
          Object.defineProperty(map47, key, {
            value: value4,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map47;
    }
    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge5;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log6 = require_log();
    var merge5 = require_merge();
    var stringify2 = require_stringify2();
    var identity17 = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map47, { key, value: value3 }) {
      if (identity17.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map47, value3);
      else if (merge5.isMergeKey(ctx, key))
        merge5.addMergeToJSMap(ctx, map47, value3);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map47 instanceof Map) {
          map47.set(jsKey, toJS.toJS(value3, jsKey, ctx));
        } else if (map47 instanceof Set) {
          map47.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value3, stringKey, ctx);
          if (stringKey in map47)
            Object.defineProperty(map47, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map47[stringKey] = jsValue;
        }
      }
      return map47;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity17.isNode(key) && ctx?.doc) {
        const strCtx = stringify2.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log6.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity17 = require_identity();
    function createPair(key, value3, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value3, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value3 = null) {
        Object.defineProperty(this, identity17.NODE_TYPE, { value: identity17.PAIR });
        this.key = key;
        this.value = value3;
      }
      clone(schema) {
        let { key, value: value3 } = this;
        if (identity17.isNode(key))
          key = key.clone(schema);
        if (identity17.isNode(value3))
          value3 = value3.clone(schema);
        return new _Pair(key, value3);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var stringify2 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify3(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent2, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines2 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment3 = null;
        if (identity17.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines2.push("");
          addCommentBefore(ctx, lines2, item.commentBefore, chompKeep);
          if (item.comment)
            comment3 = item.comment;
        } else if (identity17.isPair(item)) {
          const ik = identity17.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines2.push("");
            addCommentBefore(ctx, lines2, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str3 = stringify2.stringify(item, itemCtx, () => comment3 = null, () => chompKeep = true);
        if (comment3)
          str3 += stringifyComment.lineComment(str3, itemIndent, commentString(comment3));
        if (chompKeep && comment3)
          chompKeep = false;
        lines2.push(blockItemPrefix + str3);
      }
      let str2;
      if (lines2.length === 0) {
        str2 = flowChars.start + flowChars.end;
      } else {
        str2 = lines2[0];
        for (let i = 1; i < lines2.length; ++i) {
          const line2 = lines2[i];
          str2 += line2 ? `
${indent2}${line2}` : "\n";
        }
      }
      if (comment2) {
        str2 += "\n" + stringifyComment.indentComment(commentString(comment2), indent2);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str2;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent: indent2, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines2 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity17.isNode(item)) {
          if (item.spaceBefore)
            lines2.push("");
          addCommentBefore(ctx, lines2, item.commentBefore, false);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity17.isPair(item)) {
          const ik = identity17.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines2.push("");
            addCommentBefore(ctx, lines2, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity17.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment2 = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment2 = ik.comment;
          }
        }
        if (comment2)
          reqNewline = true;
        let str2 = stringify2.stringify(item, itemCtx, () => comment2 = null);
        if (i < items.length - 1)
          str2 += ",";
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (!reqNewline && (lines2.length > linesAtValue || str2.includes("\n")))
          reqNewline = true;
        lines2.push(str2);
        linesAtValue = lines2.length;
      }
      const { start, end } = flowChars;
      if (lines2.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines2.reduce((sum2, line2) => sum2 + line2.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str2 = start;
          for (const line2 of lines2)
            str2 += line2 ? `
${indentStep}${indent2}${line2}` : "\n";
          return `${str2}
${indent2}${end}`;
        } else {
          return `${start}${fcPadding}${lines2.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent: indent2, options: { commentString } }, lines2, comment2, chompKeep) {
      if (comment2 && chompKeep)
        comment2 = comment2.replace(/^\n+/, "");
      if (comment2) {
        const ic = stringifyComment.indentComment(commentString(comment2), indent2);
        lines2.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity17 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity17.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity17.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity17.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity17.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map47 = new this(schema);
        const add3 = (key, value3) => {
          if (typeof replacer === "function")
            value3 = replacer.call(obj, key, value3);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value3 !== void 0 || keepUndefined)
            map47.items.push(Pair.createPair(key, value3, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value3] of obj)
            add3(key, value3);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add3(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map47.items.sort(schema.sortMapEntries);
        }
        return map47;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity17.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity17.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity17.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value3) {
        this.add(new Pair.Pair(key, value3), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map47 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map47);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map47, item);
        return map47;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity17.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var YAMLMap = require_YAMLMap();
    var map47 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map48, onError) {
        if (!identity17.isMap(map48))
          onError("Expected a mapping for this tag");
        return map48;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map47;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity17.SEQ, schema);
        this.items = [];
      }
      add(value3) {
        this.items.push(value3);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity17.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value3) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity17.isScalar(prev) && Scalar.isScalarValue(value3))
          prev.value = value3;
        else
          this.items[idx] = value3;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity17.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity17.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string5 = {
      identify: (value3) => typeof value3 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string5;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value3) => value3 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source: source2 }, ctx) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value3) => typeof value3 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar.Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source: source2, value: value3 }, ctx) {
        if (source2 && boolTag.test.test(source2)) {
          const sv = source2[0] === "t" || source2[0] === "T";
          if (value3 === sv)
            return source2;
        }
        return value3 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value: value3 }) {
      if (typeof value3 === "bigint")
        return String(value3);
      const num = typeof value3 === "number" ? value3 : Number(value3);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value3);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node.minFractionDigits = str2.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value3) => typeof value3 === "bigint" || Number.isInteger(value3);
    var intResolve = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    function intStringify(node, radix, prefix2) {
      const { value: value3 } = node;
      if (intIdentify(value3) && value3 >= 0)
        return prefix2 + value3.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value3) => intIdentify(value3) && value3 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value3) => intIdentify(value3) && value3 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map47 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string5 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map47.map,
      seq.seq,
      string5.string,
      _null2.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map47 = require_map();
    var seq = require_seq();
    function intIdentify(value3) {
      return typeof value3 === "bigint" || Number.isInteger(value3);
    }
    var stringifyJSON = ({ value: value3 }) => JSON.stringify(value3);
    var jsonScalars = [
      {
        identify: (value3) => typeof value3 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value3) => value3 == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value3) => typeof value3 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value3 }) => intIdentify(value3) ? value3.toString() : JSON.stringify(value3)
      },
      {
        identify: (value3) => typeof value3 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    var schema = [map47.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value3) => value3 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment: comment2, type, value: value3 }, ctx, onComment, onChompKeep) {
        const buf = value3;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str2 = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str2.length / lineWidth);
          const lines2 = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines2[i] = str2.substr(o, lineWidth);
          }
          str2 = lines2.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment: comment2, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity17.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity17.isPair(item))
            continue;
          else if (identity17.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity17.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value3;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value3 = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys4 = Object.keys(it);
            if (keys4.length === 1) {
              key = keys4[0];
              value3 = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys4.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value3, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map47 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map47);
        for (const pair of this.items) {
          let key, value3;
          if (identity17.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value3 = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map47.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map47.set(key, value3);
        }
        return map47;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value3) => value3 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity17.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value: value3, source: source2 }, ctx) {
      const boolObj = value3 ? trueTag : falseTag;
      if (source2 && boolObj.test.test(source2))
        return source2;
      return value3 ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value3) => value3 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value3) => value3 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f = str2.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value3) => typeof value3 === "bigint" || Number.isInteger(value3);
    function intResolve(str2, offset, radix, { intAsBigInt }) {
      const sign2 = str2[0];
      if (sign2 === "-" || sign2 === "+")
        offset += 1;
      str2 = str2.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign2 === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign2 === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix2) {
      const { value: value3 } = node;
      if (intIdentify(value3)) {
        const str2 = value3.toString(radix);
        return value3 < 0 ? "-" + prefix2 + str2.substr(1) : prefix2 + str2;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity17.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity17.isPair(pair) ? identity17.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value3) {
        if (typeof value3 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value3}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value3) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value3) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value3 of iterable) {
            if (typeof replacer === "function")
              value3 = replacer.call(iterable, value3, value3);
            set2.items.push(Pair.createPair(value3, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value3) => value3 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map47, onError) {
        if (identity17.isMap(map47)) {
          if (map47.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map47);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map47;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str2, asBigInt) {
      const sign2 = str2[0];
      const parts = sign2 === "-" || sign2 === "+" ? str2.substring(1) : str2;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign2 === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value: value3 } = node;
      let num = (n) => n;
      if (typeof value3 === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value3) || !isFinite(value3))
        return stringifyNumber.stringifyNumber(node);
      let sign2 = "";
      if (value3 < 0) {
        sign2 = "-";
        value3 *= num(-1);
      }
      const _60 = num(60);
      const parts = [value3 % _60];
      if (value3 < 60) {
        parts.unshift(0);
      } else {
        value3 = (value3 - parts[0]) / _60;
        parts.unshift(value3 % _60);
        if (value3 >= 60) {
          value3 = (value3 - parts[0]) / _60;
          parts.unshift(value3);
        }
      }
      return sign2 + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value3) => typeof value3 === "bigint" || Number.isInteger(value3),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value3) => value3 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match3 = str2.match(timestamp.test);
        if (!match3)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month2, day2, hour2, minute2, second2] = match3.map(Number);
        const millisec = match3[7] ? Number((match3[7] + "00").substr(1, 3)) : 0;
        let date2 = Date.UTC(year2, month2 - 1, day2, hour2 || 0, minute2 || 0, second2 || 0, millisec);
        const tz = match3[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date2 -= 6e4 * d;
        }
        return new Date(date2);
      },
      stringify: ({ value: value3 }) => value3.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map47 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string5 = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge5 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map47.map,
      seq.seq,
      string5.string,
      _null2.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge5.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map47 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string5 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge5 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map47.map, seq.seq, string5.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map47.map,
      merge: merge5.merge,
      null: _null2.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge5.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge5.merge) ? schemaTags.concat(merge5.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys4 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys4} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge5.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys4 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys4}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var map47 = require_map();
    var seq = require_seq();
    var string5 = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge5, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge5);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity17.MAP, { value: map47.map });
        Object.defineProperty(this, identity17.SCALAR, { value: string5.string });
        Object.defineProperty(this, identity17.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var stringify2 = require_stringify2();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines2 = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines2.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines2.push("---");
      const ctx = stringify2.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines2.length !== 1)
          lines2.unshift("");
        const cs = commentString(doc.commentBefore);
        lines2.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity17.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines2.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines2.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines2[lines2.length - 1] === "---") {
          lines2[lines2.length - 1] = `--- ${body}`;
        } else
          lines2.push(body);
      } else {
        lines2.push(stringify2.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines2.push("...");
            lines2.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines2.push(`... ${cs}`);
          }
        } else {
          lines2.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines2[lines2.length - 1] !== "")
            lines2.push("");
          lines2.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines2.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity17 = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value3, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity17.NODE_TYPE, { value: identity17.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value3 === void 0 ? null : this.createNode(value3, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity17.NODE_TYPE]: { value: identity17.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity17.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value3) {
        if (assertCollection(this.contents))
          this.contents.add(value3);
      }
      /** Adds a value to the document. */
      addIn(path3, value3) {
        if (assertCollection(this.contents))
          this.contents.addIn(path3, value3);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name3) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name3 || prev.has(name3) ? anchors.findNewAnchor(name3 || "a", prev) : name3;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value3, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value3 = replacer.call({ "": value3 }, "", value3);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value3, tag, ctx);
        if (flow && identity17.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value3, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value3, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path3) {
        if (Collection.isEmptyPath(path3)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path3) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity17.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path3, keepScalar) {
        if (Collection.isEmptyPath(path3))
          return !keepScalar && identity17.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity17.isCollection(this.contents) ? this.contents.getIn(path3, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity17.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path3) {
        if (Collection.isEmptyPath(path3))
          return this.contents !== void 0;
        return identity17.isCollection(this.contents) ? this.contents.hasIn(path3) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value3) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value3);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value3);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path3, value3) {
        if (Collection.isEmptyPath(path3)) {
          this.contents = value3;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path3), value3);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path3, value3);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new directives.Directives({ version: version2 });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json2,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity17.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name3, pos, code, message2) {
        super();
        this.name = name3;
        this.code = code;
        this.message = message2;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLParseError", pos, code, message2);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLWarning", pos, code, message2);
      }
    };
    var prettifyError = (src, lc) => (error5) => {
      if (error5.pos[0] === -1)
        return;
      error5.linePos = error5.pos.map((pos) => lc.linePos(pos));
      const { line: line2, col } = error5.linePos[0];
      error5.message += ` at line ${line2}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error5.linePos[1];
        if (end && end.line === line2 && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error5.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment2 = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token2 of tokens) {
        if (reqSpace) {
          if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
            onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token2.type !== "comment" && token2.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token2.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next2?.type !== "flow-collection") && token2.source.includes("	")) {
              tab = token2;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token2.source.substring(1) || " ";
            if (!comment2)
              comment2 = cb;
            else
              comment2 += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment2)
                comment2 += token2.source;
              else
                spaceBefore = true;
            } else
              commentSep += token2.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token2;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token2.source.endsWith(":"))
              onError(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
            if (found)
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow ?? "collection"}`);
            found = token2;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token2;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last4 = tokens[tokens.length - 1];
      const end = last4 ? last4.offset + last4.source.length : offset;
      if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
        onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next2?.type === "block-map" || next2?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment: comment2,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent2, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent2 && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity17.isScalar(a) && identity17.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map47 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep3, value: value3 } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep3) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map47.comment)
                map47.comment += "\n" + keyProps.comment;
              else
                map47.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map47.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep3 ?? [], {
          indicator: "map-value-ind",
          next: value3,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value3?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value3 ? composeNode(ctx, value3, valueProps, onError) : composeEmptyNode(ctx, offset, sep3, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value3, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map47.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map47.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map47.range = [bm.offset, offset, commentEnd ?? offset];
      return map47;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value: value3 } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value3,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value3) {
            if (value3 && value3.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value3 ? composeNode(ctx, value3, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value3, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment2 = "";
      if (end) {
        let hasSpace = false;
        let sep3 = "";
        for (const token2 of end) {
          const { source: source2, type } = token2;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source2.substring(1) || " ";
              if (!comment2)
                comment2 = cb;
              else
                comment2 += sep3 + cb;
              sep3 = "";
              break;
            }
            case "newline":
              if (comment2)
                sep3 += source2;
              hasSpace = true;
              break;
            default:
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source2.length;
        }
      }
      return { comment: comment2, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep3, value: value3 } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep3 && !value3) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity17.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep3 && !props.found) {
          const valueNode = value3 ? composeNode(ctx, value3, props, onError) : composeEmptyNode(ctx, props.end, sep3, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value3))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep3 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value3,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep3)
                for (const st of sep3) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value3) {
            if ("source" in value3 && value3.source && value3.source[0] === ":")
              onError(value3, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value3 ? composeNode(ctx, value3, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep3, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value3))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map47 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map47.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map47.items.push(pair);
          } else {
            const map47 = new YAMLMap.YAMLMap(ctx.schema);
            map47.flow = true;
            map47.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map47.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map47);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name3 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name3} must end with a ${expectedEnd}` : `${name3} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token2, onError, tagName, tag) {
      const coll = token2.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token2, onError, tag) : token2.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token2, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token2, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token2, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token2.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message2 = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message2);
        }
      }
      const expType = token2.type === "block-map" ? "map" : token2.type === "block-seq" ? "seq" : token2.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token2, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token2, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token2, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity17.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines2 = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines2.length;
      for (let i = lines2.length - 1; i >= 0; --i) {
        const content = lines2[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value4 = header.chomp === "+" && lines2.length > 0 ? "\n".repeat(Math.max(1, lines2.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value4, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent2, content] = lines2[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent2.length > trimIndent)
            trimIndent = indent2.length;
        } else {
          if (indent2.length < trimIndent) {
            const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent2.length, "MISSING_CHAR", message2);
          }
          if (header.indent === 0)
            trimIndent = indent2.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message2 = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message2);
          }
          break;
        }
        offset += indent2.length + content.length + 1;
      }
      for (let i = lines2.length - 1; i >= chompStart; --i) {
        if (lines2[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value3 = "";
      let sep3 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value3 += lines2[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent2, content] = lines2[i];
        offset += indent2.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent2.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message2 = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
          indent2 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value3 += sep3 + indent2.slice(trimIndent) + content;
          sep3 = "\n";
        } else if (indent2.length > trimIndent || content[0] === "	") {
          if (sep3 === " ")
            sep3 = "\n";
          else if (!prevMoreIndented && sep3 === "\n")
            sep3 = "\n\n";
          value3 += sep3 + indent2.slice(trimIndent) + content;
          sep3 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep3 === "\n")
            value3 += "\n";
          else
            sep3 = "\n";
        } else {
          value3 += sep3 + content;
          sep3 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines2.length; ++i)
            value3 += "\n" + lines2[i][0].slice(trimIndent);
          if (value3[value3.length - 1] !== "\n")
            value3 += "\n";
          break;
        default:
          value3 += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value: value3, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source: source2 } = props[0];
      const mode = source2[0];
      let indent2 = 0;
      let chomp = "";
      let error5 = -1;
      for (let i = 1; i < source2.length; ++i) {
        const ch = source2[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent2 && n)
            indent2 = n;
          else if (error5 === -1)
            error5 = offset + i;
        }
      }
      if (error5 !== -1)
        onError(error5, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
      let hasSpace = false;
      let comment2 = "";
      let length9 = source2.length;
      for (let i = 1; i < props.length; ++i) {
        const token2 = props[i];
        switch (token2.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length9 += token2.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message2 = "Comments must be separated from other tokens by white space characters";
              onError(token2, "MISSING_CHAR", message2);
            }
            length9 += token2.source.length;
            comment2 = token2.source.substring(1);
            break;
          case "error":
            onError(token2, "UNEXPECTED_TOKEN", token2.message);
            length9 += token2.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message2 = `Unexpected token in block scalar header: ${token2.type}`;
            onError(token2, "UNEXPECTED_TOKEN", message2);
            const ts = token2.source;
            if (ts && typeof ts === "string")
              length9 += ts.length;
          }
        }
      }
      return { mode, indent: indent2, chomp, comment: comment2, length: length9 };
    }
    function splitLines(source2) {
      const split3 = source2.split(/\n( *)/);
      const first = split3[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines2 = [line0];
      for (let i = 1; i < split3.length; i += 2)
        lines2.push([split3[i], split3[i + 1]]);
      return lines2;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source: source2, end } = scalar;
      let _type;
      let value3;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value3 = plainValue(source2, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value3 = singleQuotedValue(source2, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value3 = doubleQuotedValue(source2, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source2.length, offset + source2.length]
          };
      }
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value: value3,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source2, onError) {
      let badChar = "";
      switch (source2[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source2[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source2[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source2);
    }
    function singleQuotedValue(source2, onError) {
      if (source2[source2.length - 1] !== "'" || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source2) {
      let first, line2;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match3 = first.exec(source2);
      if (!match3)
        return source2;
      let res = match3[1];
      let sep3 = " ";
      let pos = first.lastIndex;
      line2.lastIndex = pos;
      while (match3 = line2.exec(source2)) {
        if (match3[1] === "") {
          if (sep3 === "\n")
            res += sep3;
          else
            sep3 = "\n";
        } else {
          res += sep3 + match3[1];
          sep3 = " ";
        }
        pos = line2.lastIndex;
      }
      const last4 = /[ \t]*(.*)/sy;
      last4.lastIndex = pos;
      match3 = last4.exec(source2);
      return res + sep3 + (match3?.[1] ?? "");
    }
    function doubleQuotedValue(source2, onError) {
      let res = "";
      for (let i = 1; i < source2.length - 1; ++i) {
        const ch = source2[i];
        if (ch === "\r" && source2[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold: fold20, offset } = foldNewline(source2, i);
          res += fold20;
          i = offset;
        } else if (ch === "\\") {
          let next2 = source2[++i];
          const cc = escapeCodes[next2];
          if (cc)
            res += cc;
          else if (next2 === "\n") {
            next2 = source2[i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "\r" && source2[i + 1] === "\n") {
            next2 = source2[++i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "x" || next2 === "u" || next2 === "U") {
            const length9 = { x: 2, u: 4, U: 8 }[next2];
            res += parseCharCode(source2, i + 1, length9, onError);
            i += length9;
          } else {
            const raw = source2.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next2 = source2[i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source2[++i + 1];
          if (next2 !== "\n" && !(next2 === "\r" && source2[i + 2] === "\n"))
            res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source2[source2.length - 1] !== '"' || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source2, offset) {
      let fold20 = "";
      let ch = source2[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source2[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold20 += "\n";
        offset += 1;
        ch = source2[offset + 1];
      }
      if (!fold20)
        fold20 = " ";
      return { fold: fold20, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source2, offset, length9, onError) {
      const cc = source2.substr(offset, length9);
      const ok = cc.length === length9 && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source2.substr(offset - 2, length9 + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity17 = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token2, tagToken, onError) {
      const { value: value3, type, comment: comment2, range: range3 } = token2.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token2, onError) : resolveFlowScalar.resolveFlowScalar(token2, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity17.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value3, tagName, tagToken, onError);
      else if (token2.type === "scalar")
        tag = findScalarTagByTest(ctx, value3, token2, onError);
      else
        tag = ctx.schema[identity17.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value3, (msg) => onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity17.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error5) {
        const msg = error5 instanceof Error ? error5.message : String(error5);
        onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value3);
      }
      scalar.range = range3;
      scalar.source = value3;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment2)
        scalar.comment = comment2;
      return scalar;
    }
    function findScalarTagByName(schema, value3, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity17.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value3))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity17.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value3, token2, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value3)) || schema[identity17.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value3)) ?? schema[identity17.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token2, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity17 = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token2, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment: comment2, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token2.type) {
        case "alias":
          node = composeAlias(ctx, token2, onError);
          if (anchor || tag)
            onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token2, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token2, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message2 = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
          onError(token2, "UNEXPECTED_TOKEN", message2);
          node = composeEmptyNode(ctx, token2.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity17.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token2, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        if (token2.type === "scalar" && token2.source === "")
          node.comment = comment2;
        else
          node.commentBefore = comment2;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token2;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment2, anchor, tag, end }, onError) {
      const token2 = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token2, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        node.comment = comment2;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source: source2, end }, onError) {
      const alias = new Alias.Alias(source2.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value: value3, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value3 ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value3 && (value3.type === "block-map" || value3.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value3 ? composeNode.composeNode(ctx, value3, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity17 = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source: source2 } = src;
      return [offset, offset + (typeof source2 === "string" ? source2.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment2 = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source2 = prelude[i];
        switch (source2[0]) {
          case "#":
            comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment: comment2, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source2, code, message2, warning) => {
          const pos = getErrorPos(source2);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message2));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message2));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment2) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment2;
          } else if (identity17.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity17.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token2 of tokens)
          yield* this.next(token2);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token2) {
        if (process.env.LOG_STREAM)
          console.dir(token2, { depth: null });
        switch (token2.type) {
          case "directive":
            this.directives.add(token2.source, (offset, message2, warning) => {
              const pos = getErrorPos(token2);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message2, warning);
            });
            this.prelude.push(token2.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token2, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token2.source);
            break;
          case "error": {
            const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
            const error5 = new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error5);
            else
              this.doc.errors.push(error5);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token2, strict = true, onError) {
      if (token2) {
        const _onError = (pos, code, message2) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message2);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message2);
        };
        switch (token2.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token2, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token2, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value3, context) {
      const { implicitKey = false, indent: indent2, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source2 = stringifyString.stringifyString({ type, value: value3 }, {
        implicitKey,
        indent: indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent: indent2, source: "\n" }
      ];
      switch (source2[0]) {
        case "|":
        case ">": {
          const he = source2.indexOf("\n");
          const head4 = source2.substring(0, he);
          const body = source2.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent2, source: head4 }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
          return { type: "block-scalar", offset, indent: indent2, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent2, source: source2, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent2, source: source2, end };
        default:
          return { type: "scalar", offset, indent: indent2, source: source2, end };
      }
    }
    function setScalarValue(token2, value3, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent2 = "indent" in token2 ? token2.indent : null;
      if (afterKey && typeof indent2 === "number")
        indent2 += 2;
      if (!type)
        switch (token2.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token2.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source2 = stringifyString.stringifyString({ type, value: value3 }, {
        implicitKey: implicitKey || indent2 === null,
        indent: indent2 !== null && indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source2[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token2, source2);
          break;
        case '"':
          setFlowScalarValue(token2, source2, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token2, source2, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token2, source2, "scalar");
      }
    }
    function setBlockScalarValue(token2, source2) {
      const he = source2.indexOf("\n");
      const head4 = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      if (token2.type === "block-scalar") {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head4;
        token2.source = body;
      } else {
        const { offset } = token2;
        const indent2 = "indent" in token2 ? token2.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent2, source: head4 }
        ];
        if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
        for (const key of Object.keys(token2))
          if (key !== "type" && key !== "offset")
            delete token2[key];
        Object.assign(token2, { type: "block-scalar", indent: indent2, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token2, source2, type) {
      switch (token2.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token2.type = type;
          token2.source = source2;
          break;
        case "block-scalar": {
          const end = token2.props.slice(1);
          let oa = source2.length;
          if (token2.props[0].type === "block-scalar-header")
            oa -= token2.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token2.props;
          Object.assign(token2, { type, source: source2, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token2.offset + source2.length;
          const nl = { type: "newline", offset, indent: token2.indent, source: "\n" };
          delete token2.items;
          Object.assign(token2, { type, source: source2, end: [nl] });
          break;
        }
        default: {
          const indent2 = "indent" in token2 ? token2.indent : -1;
          const end = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token2))
            if (key !== "type" && key !== "offset")
              delete token2[key];
          Object.assign(token2, { type, indent: indent2, source: source2, end });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token2) {
      switch (token2.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token2.props)
            res += stringifyToken(tok);
          return res + token2.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token2.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token2.start.source;
          for (const item of token2.items)
            res += stringifyItem(item);
          for (const st of token2.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token2);
          if (token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token2.source;
          if ("end" in token2 && token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep3, value: value3 }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep3)
        for (const st of sep3)
          res += st.source;
      if (value3)
        res += stringifyToken(value3);
      return res;
    }
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path3) => {
      let item = cst;
      for (const [field, index5] of path3) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index5];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path3) => {
      const parent = visit.itemAtPath(cst, path3.slice(0, -1));
      const field = path3[path3.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path3, item, visitor) {
      let ctrl = visitor(item, path3);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token2 = item[field];
        if (token2 && "items" in token2) {
          for (let i = 0; i < token2.items.length; ++i) {
            const ci = _visit(Object.freeze(path3.concat([[field, i]])), token2.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token2.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path3);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path3) : ctrl;
    }
    exports.visit = visit;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token2) => !!token2 && "items" in token2;
    var isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
    function prettyToken(token2) {
      switch (token2) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token2);
      }
    }
    function tokenType(source2) {
      switch (source2) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source2[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty4(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source2, incomplete = false) {
        if (source2) {
          if (typeof source2 !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source2 : source2;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next2 = this.next ?? "stream";
        while (next2 && (incomplete || this.hasChars(1)))
          next2 = yield* this.parseNext(next2);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent2 = 0;
          while (ch === " ")
            ch = this.buffer[++indent2 + offset];
          if (ch === "\r") {
            const next2 = this.buffer[indent2 + offset + 1];
            if (next2 === "\n" || !next2 && !this.atEnd)
              return offset + indent2 + 1;
          }
          return ch === "\n" || indent2 >= this.indentNext || !ch && !this.atEnd ? offset + indent2 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty4(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state2) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state2;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next2) {
        switch (next2) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line2 = this.getLine();
        if (line2 === null)
          return this.setNext("stream");
        if (line2[0] === cst.BOM) {
          yield* this.pushCount(1);
          line2 = line2.substring(1);
        }
        if (line2[0] === "%") {
          let dirEnd = line2.length;
          let cs = line2.indexOf("#");
          while (cs !== -1) {
            const ch = line2[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line2.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line2[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line2.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line2.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty4(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty4(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty4(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line2[n]) {
          case "#":
            yield* this.pushCount(line2.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line2.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent2 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent2 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("flow");
        if (indent2 !== -1 && indent2 < this.indentNext && line2[0] !== "#" || indent2 === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty4(line2[3])) {
          const atFlowEndMarker = indent2 === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line2[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line2[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line2.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next2 = this.charAt(1);
            if (this.flowKey || isEmpty4(next2) || next2 === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty4(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent2 = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent2 += 1;
              break;
            case "\n":
              nl = i2;
              indent2 = 0;
              break;
            case "\r": {
              const next2 = this.buffer[i2 + 1];
              if (!next2 && !this.atEnd)
                return this.setNext("block-scalar");
              if (next2 === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent2 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent2;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent2 > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next2 = this.buffer[i + 1];
            if (isEmpty4(next2) || inFlow && flowIndicatorChars.has(next2))
              break;
            end = i;
          } else if (isEmpty4(ch)) {
            let next2 = this.buffer[i + 1];
            if (ch === "\r") {
              if (next2 === "\n") {
                i += 1;
                ch = "\n";
                next2 = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty4(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty4(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test3) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test3(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token2) {
      switch (token2?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source2, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source2, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source2) {
        this.source = source2;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source2));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source2.length;
          return;
        }
        const type = cst.tokenType(source2);
        if (!type) {
          const message2 = `Not a YAML token: ${source2}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message2, source: source2 });
          this.offset += source2.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source2.length);
              break;
            case "space":
              if (this.atNewLine && source2[0] === " ")
                this.indent += source2.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source2.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source2.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top3 = this.peek(1);
        if (this.type === "doc-end" && (!top3 || top3.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top3)
          return yield* this.stream();
        switch (top3.type) {
          case "document":
            return yield* this.document(top3);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top3);
          case "block-scalar":
            return yield* this.blockScalar(top3);
          case "block-map":
            return yield* this.blockMap(top3);
          case "block-seq":
            return yield* this.blockSequence(top3);
          case "flow-collection":
            return yield* this.flowCollection(top3);
          case "doc-end":
            return yield* this.documentEnd(top3);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error5) {
        const token2 = error5 ?? this.stack.pop();
        if (!token2) {
          const message2 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message2 };
        } else if (this.stack.length === 0) {
          yield token2;
        } else {
          const top3 = this.peek(1);
          if (token2.type === "block-scalar") {
            token2.indent = "indent" in top3 ? top3.indent : 0;
          } else if (token2.type === "flow-collection" && top3.type === "document") {
            token2.indent = 0;
          }
          if (token2.type === "flow-collection")
            fixFlowSeqItems(token2);
          switch (top3.type) {
            case "document":
              top3.value = token2;
              break;
            case "block-scalar":
              top3.props.push(token2);
              break;
            case "block-map": {
              const it = top3.items[top3.items.length - 1];
              if (it.value) {
                top3.items.push({ start: [], key: token2, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token2;
              } else {
                Object.assign(it, { key: token2, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top3.items[top3.items.length - 1];
              if (it.value)
                top3.items.push({ start: [], value: token2 });
              else
                it.value = token2;
              break;
            }
            case "flow-collection": {
              const it = top3.items[top3.items.length - 1];
              if (!it || it.value)
                top3.items.push({ start: [], key: token2, sep: [] });
              else if (it.sep)
                it.value = token2;
              else
                Object.assign(it, { key: token2, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token2);
          }
          if ((top3.type === "document" || top3.type === "block-map" || top3.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
            const last4 = token2.items[token2.items.length - 1];
            if (last4 && !last4.sep && !last4.value && last4.start.length > 0 && findNonEmptyIndex(last4.start) === -1 && (token2.indent === 0 || last4.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
              if (top3.type === "document")
                top3.end = last4.start;
              else
                top3.items.push({ start: last4.start });
              token2.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep3;
          if (scalar.end) {
            sep3 = scalar.end;
            sep3.push(this.sourceToken);
            delete scalar.end;
          } else
            sep3 = [this.sourceToken];
          const map47 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep3 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map47;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map47) {
        const it = map47.items[map47.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last4?.type === "comment")
                end?.push(this.sourceToken);
              else
                map47.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map47.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map47.indent)) {
                const prev = map47.items[map47.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map47.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map47.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map47.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map47.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map47.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map47.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map47.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep3 = it.sep;
                  sep3.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep3 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map47.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map47.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map47);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map47.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last4?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top3;
          do {
            yield* this.pop();
            top3 = this.peek(1);
          } while (top3 && top3.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep3 = fc.end.splice(1, fc.end.length);
            sep3.push(this.sourceToken);
            const map47 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep3 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map47;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent2) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent2)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token2) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token2.end)
              token2.end.push(this.sourceToken);
            else
              token2.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log6 = require_log();
    var identity17 = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source2)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source2), true, source2.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
      }
      return doc;
    }
    function parse3(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log6.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify2(value3, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent2 = Math.round(options);
        options = indent2 < 1 ? void 0 : indent2 > 8 ? { indent: 8 } : { indent: indent2 };
      }
      if (value3 === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity17.isDocument(value3) && !_replacer)
        return value3.toString(options);
      return new Document.Document(value3, _replacer, options).toString(options);
    }
    exports.parse = parse3;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity17 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity17.isAlias;
    exports.isCollection = identity17.isCollection;
    exports.isDocument = identity17.isDocument;
    exports.isMap = identity17.isMap;
    exports.isNode = identity17.isNode;
    exports.isPair = identity17.isPair;
    exports.isScalar = identity17.isScalar;
    exports.isSeq = identity17.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value3) {
      return value3 === true || value3 === false;
    }
    exports.boolean = boolean;
    function string5(value3) {
      return typeof value3 === "string" || value3 instanceof String;
    }
    exports.string = string5;
    function number2(value3) {
      return typeof value3 === "number" || value3 instanceof Number;
    }
    exports.number = number2;
    function error5(value3) {
      return value3 instanceof Error;
    }
    exports.error = error5;
    function func(value3) {
      return typeof value3 === "function";
    }
    exports.func = func;
    function array2(value3) {
      return Array.isArray(value3);
    }
    exports.array = array2;
    function stringArray(value3) {
      return array2(value3) && value3.every((elem4) => string5(elem4));
    }
    exports.stringArray = stringArray;
    function typedArray(value3, check) {
      return Array.isArray(value3) && value3.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value3) {
      return value3 && func(value3.then);
    }
    exports.thenable = thenable;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value3) {
      return value3 === true || value3 === false;
    }
    exports.boolean = boolean;
    function string5(value3) {
      return typeof value3 === "string" || value3 instanceof String;
    }
    exports.string = string5;
    function number2(value3) {
      return typeof value3 === "number" || value3 instanceof Number;
    }
    exports.number = number2;
    function error5(value3) {
      return value3 instanceof Error;
    }
    exports.error = error5;
    function func(value3) {
      return typeof value3 === "function";
    }
    exports.func = func;
    function array2(value3) {
      return Array.isArray(value3);
    }
    exports.array = array2;
    function stringArray(value3) {
      return array2(value3) && value3.every((elem4) => string5(elem4));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message2, data) {
        super(message2);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value3) {
        return value3 === _ParameterStructures.auto || value3 === _ParameterStructures.byName || value3 === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message2) {
        const candidate = message2;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message2) {
        const candidate = message2;
        return candidate && is.string(candidate.method) && message2.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message2) {
        const candidate = message2;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value3, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value3;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value: value3, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state2 = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state2) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state2 = this._state;
        let current = this._head;
        const iterator2 = {
          [Symbol.iterator]: () => {
            return iterator2;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator2;
      }
      values() {
        const state2 = this._state;
        let current = this._head;
        const iterator2 = {
          [Symbol.iterator]: () => {
            return iterator2;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator2;
      }
      entries() {
        const state2 = this._state;
        let current = this._head;
        const iterator2 = {
          [Symbol.iterator]: () => {
            return iterator2;
          },
          next: () => {
            if (this._state !== state2) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator2;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next2 = item.next;
          const previous = item.previous;
          if (!next2 || !previous) {
            throw new Error("Invalid list");
          }
          next2.previous = previous;
          previous.next = next2;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next2 = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next2.previous = previous;
            previous.next = next2;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next2 = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next2.previous = void 0;
            this._head = next2;
          } else {
            next2.previous = previous;
            previous.next = next2;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value3, key) => {
          data.push([key, value3]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value3] of data) {
          this.set(key, value3);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache2 = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value3) {
        super.set(key, value3, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create3(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create3;
    })(Disposable || (exports.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value3) {
        const candidate = value3;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve2, reject) => {
          this._waiting.push({ thunk, resolve: resolve2, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next2 = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next2.thunk();
          if (result instanceof Promise) {
            result.then((value3) => {
              this._active--;
              next2.resolve(value3);
              this.runNext();
            }, (err) => {
              this._active--;
              next2.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next2.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next2.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value3) {
        let candidate = value3;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error5) {
        this.errorEmitter.fire(this.asError(error5));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info4) {
        this.partialMessageEmitter.fire(info4);
      }
      asError(error5) {
        if (error5 instanceof Error) {
          return error5;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error5.message) ? error5.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error5) => this.fireError(error5));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length9 = parseInt(contentLength);
              if (isNaN(length9)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length9;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message2 = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message2);
            }).catch((error5) => {
              this.fireError(error5);
            });
          }
        } catch (error5) {
          this.fireError(error5);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token2, timeout) => {
          this.partialMessageTimer = void 0;
          if (token2 === this.messageToken) {
            this.firePartialMessage({ messageToken: token2, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF2 = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value3) {
        let candidate = value3;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error5, message2, count) {
        this.errorEmitter.fire([this.asError(error5), message2, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error5) {
        if (error5 instanceof Error) {
          return error5;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error5.message) ? error5.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error5) => this.fireError(error5));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF2);
            headers.push(CRLF2);
            return this.doWrite(msg, headers, buffer);
          }, (error5) => {
            this.fireError(error5);
            throw error5;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error5) {
          this.handleError(error5, msg);
          return Promise.reject(error5);
        }
      }
      handleError(error5, msg) {
        this.errorCount++;
        this.fireError(error5, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF2 = 10;
    var CRLF2 = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state2 = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value3 = chunk[offset];
            switch (value3) {
              case CR:
                switch (state2) {
                  case 0:
                    state2 = 1;
                    break;
                  case 2:
                    state2 = 3;
                    break;
                  default:
                    state2 = 0;
                }
                break;
              case LF2:
                switch (state2) {
                  case 1:
                    state2 = 2;
                    break;
                  case 3:
                    state2 = 4;
                    offset++;
                    break row;
                  default:
                    state2 = 0;
                }
                break;
              default:
                state2 = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state2 !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF2);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index5 = header.indexOf(":");
          if (index5 === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index5);
          const value3 = header.substr(index5 + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value3);
        }
        return result;
      }
      tryReadBody(length9) {
        if (this._totalLength < length9) {
          return void 0;
        }
        return this._read(length9);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value3) {
        return typeof value3 === "string" || typeof value3 === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value3) {
        return Is.func(value3);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString7(value3) {
        if (!Is.string(value3)) {
          return Trace2.Off;
        }
        value3 = value3.toLowerCase();
        switch (value3) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString7;
      function toString7(value3) {
        switch (value3) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString7;
    })(Trace || (exports.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString7(value3) {
        if (!Is.string(value3)) {
          return TraceFormat2.Text;
        }
        value3 = value3.toLowerCase();
        if (value3 === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString7;
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message2) {
        super(message2);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value3) {
        const candidate = value3;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value3) {
        const candidate = value3;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value3) {
        const candidate = value3;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value3) {
        return IdCancellationReceiverStrategy.is(value3) || RequestCancellationReceiverStrategy.is(value3);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value3) {
        const candidate = value3;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value3) {
        const candidate = value3;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value3) {
        const candidate = value3;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value3) {
        const candidate = value3;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state2 = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message2) {
        if (messages_1.Message.isRequest(message2)) {
          queue.set(createRequestQueueKey(message2.id), message2);
        } else if (messages_1.Message.isResponse(message2)) {
          queue.set(createResponseQueueKey(message2.id), message2);
        } else {
          queue.set(createNotificationQueueKey(), message2);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state2 === ConnectionState.Listening;
      }
      function isClosed() {
        return state2 === ConnectionState.Closed;
      }
      function isDisposed() {
        return state2 === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state2 === ConnectionState.New || state2 === ConnectionState.Listening) {
          state2 = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error5) {
        errorEmitter.fire([error5, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message2) {
        if (messages_1.Message.isRequest(message2)) {
          handleRequest(message2);
        } else if (messages_1.Message.isNotification(message2)) {
          handleNotification(message2);
        } else if (messages_1.Message.isResponse(message2)) {
          handleResponse(message2);
        } else {
          handleInvalidMessage(message2);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message2 = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message2, handleMessage);
          } else {
            handleMessage(message2);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message2) => {
        try {
          if (messages_1.Message.isNotification(message2) && message2.method === CancelNotification.type.method) {
            const cancelId = message2.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message2.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message2);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message2);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message2 = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message2.error = resultOrError.toJson();
          } else {
            message2.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message2, method, startTime2);
          messageWriter.write(message2).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error5, method, startTime2) {
          const message2 = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error5.toJson()
          };
          traceSendingResponse(message2, method, startTime2);
          messageWriter.write(message2).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message2 = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message2, method, startTime2);
          messageWriter.write(message2).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise2 = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise2.then) {
              promise2.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error5) => {
                requestTokens.delete(tokenKey);
                if (error5 instanceof messages_1.ResponseError) {
                  replyError(error5, requestMessage.method, startTime);
                } else if (error5 && Is.string(error5.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error5.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error5) {
            requestTokens.delete(tokenKey);
            if (error5 instanceof messages_1.ResponseError) {
              reply(error5, requestMessage.method, startTime);
            } else if (error5 && Is.string(error5.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error5.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error5 = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error5.code, error5.message, error5.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error5) {
              if (error5.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error5.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message2) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message2.method === CancelNotification.type.method) {
          const cancelId = message2.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message2);
          return;
        } else {
          const element = notificationHandlers.get(message2.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message2);
            if (notificationHandler) {
              if (message2.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message2.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message2.params)) {
                const params = message2.params;
                if (message2.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message2.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message2.params.length) {
                      logger.error(`Notification ${message2.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message2.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message2.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message2.method, message2.params);
            }
          } catch (error5) {
            if (error5.message) {
              logger.error(`Notification handler '${message2.method}' failed with message: ${error5.message}`);
            } else {
              logger.error(`Notification handler '${message2.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message2);
        }
      }
      function handleInvalidMessage(message2) {
        if (!message2) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message2, null, 4)}`);
        const responseMessage = message2;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message2) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message2.params) {
            data = `Params: ${stringifyTrace(message2.params)}

`;
          }
          tracer.log(`Sending request '${message2.method} - (${message2.id})'.`, data);
        } else {
          logLSPMessage("send-request", message2);
        }
      }
      function traceSendingNotification(message2) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message2.params) {
              data = `Params: ${stringifyTrace(message2.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message2.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message2);
        }
      }
      function traceSendingResponse(message2, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message2.error && message2.error.data) {
              data = `Error data: ${stringifyTrace(message2.error.data)}

`;
            } else {
              if (message2.result) {
                data = `Result: ${stringifyTrace(message2.result)}

`;
              } else if (message2.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message2.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message2);
        }
      }
      function traceReceivedRequest(message2) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message2.params) {
            data = `Params: ${stringifyTrace(message2.params)}

`;
          }
          tracer.log(`Received request '${message2.method} - (${message2.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message2);
        }
      }
      function traceReceivedNotification(message2) {
        if (trace === Trace.Off || !tracer || message2.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message2.params) {
              data = `Params: ${stringifyTrace(message2.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message2.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message2);
        }
      }
      function traceReceivedResponse(message2, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message2.error && message2.error.data) {
              data = `Error data: ${stringifyTrace(message2.error.data)}

`;
            } else {
              if (message2.result) {
                data = `Result: ${stringifyTrace(message2.result)}

`;
              } else if (message2.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error5 = message2.error ? ` Request failed: ${message2.error.message} (${message2.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message2.id})' in ${Date.now() - responsePromise.timerStart}ms.${error5}`, data);
          } else {
            tracer.log(`Received response ${message2.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message2);
        }
      }
      function logLSPMessage(type, message2) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message: message2,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value3) => undefinedToNull(value3));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error5) => {
            logger.error(`Sending notification failed.`);
            throw error5;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token2, handler) => {
          if (progressHandlers.has(token2)) {
            throw new Error(`Progress handler for token ${token2} already registered`);
          }
          progressHandlers.set(token2, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token2);
            }
          };
        },
        sendProgress: (_type, token2, value3) => {
          return connection.sendNotification(ProgressNotification.type, { token: token2, value: value3 });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token2 = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last4 = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last4)) {
              paramEnd = paramEnd - 1;
              token2 = last4;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value3) => undefinedToNull(value3));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token2 = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token2) {
            disposable = token2.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version2,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve2, reject) => {
            const resolveWithCleanup = (r) => {
              resolve2(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error5) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error5.message ? error5.message : "Unknown reason"));
              throw error5;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state2 = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error5 = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise2 of responsePromises.values()) {
            promise2.reject(error5);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state2 = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = __require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value3, encoding) {
        return Buffer.from(value3, encoding);
      }
      toString(value3, encoding) {
        if (value3 instanceof Buffer) {
          return value3.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value3);
        }
      }
      asNative(buffer, length9) {
        if (length9 === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length9) : Buffer.from(buffer, 0, length9);
        }
      }
      allocNative(length9) {
        return Buffer.allocUnsafe(length9);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream2) {
        this.stream = stream2;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve2, reject) => {
          const callback = (error5) => {
            if (error5 === void 0 || error5 === null) {
              resolve2();
            } else {
              reject(error5);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream2) => new ReadableStreamWrapper(stream2),
        asWritableStream: (stream2) => new WritableStreamWrapper(stream2)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path3 = __require("path");
    var os = __require("os");
    var crypto_1 = __require("crypto");
    var net_1 = __require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process3) {
        super();
        this.process = process3;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error5) => this.fireError(error5));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process3) {
        super();
        this.process = process3;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error5) => this.fireError(error5));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error5) => {
              if (error5) {
                this.errorCount++;
                this.handleError(error5, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error5) {
          this.handleError(error5, msg);
          return Promise.reject(error5);
        }
      }
      handleError(error5, msg) {
        this.errorCount++;
        this.fireError(error5, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error5) => this.fireError(error5));
        port.on("message", (message2) => {
          this.onData.fire(message2);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error5) => this.fireError(error5));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error5) {
          this.handleError(error5, msg);
          return Promise.reject(error5);
        }
      }
      handleError(error5, msg) {
        this.errorCount++;
        this.fireError(error5, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path3.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path3.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected2 = new Promise((resolve2, _reject) => {
        connectResolve = resolve2;
      });
      return new Promise((resolve2, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve2({
            onConnected: () => {
              return connected2;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected2 = new Promise((resolve2, _reject) => {
        connectResolve = resolve2;
      });
      return new Promise((resolve2, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve2({
            onConnected: () => {
              return connected2;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value3) {
      const candidate = value3;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value3) {
      const candidate = value3;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module) {
    "use strict";
    module.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module) {
    (function(factory) {
      if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(__require, exports);
        if (v !== void 0) module.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlineCompletionContext = exports2.SelectedCompletionInfo = exports2.InlineCompletionTriggerKind = exports2.InlineCompletionList = exports2.InlineCompletionItem = exports2.StringValue = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value3) {
          return typeof value3 === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports2.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value3) {
          return typeof value3 === "string";
        }
        URI2.is = is;
      })(URI || (exports2.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value3) {
          return typeof value3 === "number" && integer2.MIN_VALUE <= value3 && value3 <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports2.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value3) {
          return typeof value3 === "number" && uinteger2.MIN_VALUE <= value3 && value3 <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports2.uinteger = uinteger = {}));
      var Position2;
      (function(Position3) {
        function create3(line2, character) {
          if (line2 === Number.MAX_VALUE) {
            line2 = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line: line2, character };
        }
        Position3.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position3.is = is;
      })(Position2 || (exports2.Position = Position2 = {}));
      var Range;
      (function(Range2) {
        function create3(one2, two, three, four) {
          if (Is.uinteger(one2) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position2.create(one2, two), end: Position2.create(three, four) };
          } else if (Position2.is(one2) && Position2.is(two)) {
            return { start: one2, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one2, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports2.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create3(uri2, range3) {
          return { uri: uri2, range: range3 };
        }
        Location2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports2.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create3(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports2.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create3(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports2.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create3(range3, color) {
          return {
            range: range3,
            color
          };
        }
        ColorInformation2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports2.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create3(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports2.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports2.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create3(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports2.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create3(location, message2) {
          return {
            location,
            message: message2
          };
        }
        DiagnosticRelatedInformation2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports2.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports2.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports2.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create3(range3, message2, severity, code, source2, relatedInformation) {
          var result = { range: range3, message: message2 };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source2)) {
            result.source = source2;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create3;
        function is(value3) {
          var _a;
          var candidate = value3;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports2.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create3(title2, command2) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title: title2, command: command2 };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports2.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace4(range3, newText) {
          return { range: range3, newText };
        }
        TextEdit2.replace = replace4;
        function insert6(position2, newText) {
          return { range: { start: position2, end: position2 }, newText };
        }
        TextEdit2.insert = insert6;
        function del(range3) {
          return { range: range3, newText: "" };
        }
        TextEdit2.del = del;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports2.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create3(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports2.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value3) {
          var candidate = value3;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace4(range3, newText, annotation) {
          return { range: range3, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace4;
        function insert6(position2, newText, annotation) {
          return { range: { start: position2, end: position2 }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert6;
        function del(range3, annotation) {
          return { range: range3, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value3) {
          var candidate = value3;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports2.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create3(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports2.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create3(uri2, options, annotation) {
          var result = {
            kind: "create",
            uri: uri2
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports2.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create3(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports2.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create3(uri2, options, annotation) {
          var result = {
            kind: "delete",
            uri: uri2
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports2.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value3) {
          var candidate = value3;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports2.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position2, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position2, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position2, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position2, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range3, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range3, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range3, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range3, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range3, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range3);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range3, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range3, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value3) {
            if (value3 === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri2, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri2, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri2, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri2, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri2, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri2, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create3(uri2) {
          return { uri: uri2 };
        }
        TextDocumentIdentifier2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports2.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create3(uri2, version2) {
          return { uri: uri2, version: version2 };
        }
        VersionedTextDocumentIdentifier2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create3(uri2, version2) {
          return { uri: uri2, version: version2 };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create3(uri2, languageId, version2, text2) {
          return { uri: uri2, languageId, version: version2, text: text2 };
        }
        TextDocumentItem2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports2.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value3) {
          var candidate = value3;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports2.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(value3) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports2.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports2.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports2.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports2.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create3(newText, insert6, replace4) {
          return { newText, insert: insert6, replace: replace4 };
        }
        InsertReplaceEdit2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports2.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports2.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value3) {
          var candidate = value3;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create3(label) {
          return { label };
        }
        CompletionItem2.create = create3;
      })(CompletionItem || (exports2.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create3(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create3;
      })(CompletionList || (exports2.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value3) {
          var candidate = value3;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports2.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value3) {
          var candidate = value3;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value3.range === void 0 || Range.is(value3.range));
        }
        Hover2.is = is;
      })(Hover || (exports2.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create3(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create3;
      })(ParameterInformation || (exports2.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create3(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create3;
      })(SignatureInformation || (exports2.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports2.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create3(range3, kind) {
          var result = { range: range3 };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create3;
      })(DocumentHighlight || (exports2.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports2.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports2.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create3(name3, kind, range3, uri2, containerName) {
          var result = {
            name: name3,
            kind,
            location: { uri: uri2, range: range3 }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create3;
      })(SymbolInformation || (exports2.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create3(name3, kind, uri2, range3) {
          return range3 !== void 0 ? { name: name3, kind, location: { uri: uri2, range: range3 } } : { name: name3, kind, location: { uri: uri2 } };
        }
        WorkspaceSymbol2.create = create3;
      })(WorkspaceSymbol || (exports2.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create3(name3, detail, kind, range3, selectionRange, children) {
          var result = {
            name: name3,
            detail,
            kind,
            range: range3,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports2.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports2.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports2.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create3(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports2.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create3(title2, kindOrCommandOrEdit, kind) {
          var result = { title: title2 };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports2.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create3(range3, data) {
          var result = { range: range3 };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports2.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create3(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports2.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create3(range3, target, data) {
          return { range: range3, target, data };
        }
        DocumentLink2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports2.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create3(range3, parent) {
          return { range: range3, parent };
        }
        SelectionRange2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports2.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports2.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports2.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports2.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create3(range3, text2) {
          return { range: range3, text: text2 };
        }
        InlineValueText2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports2.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create3(range3, variableName, caseSensitiveLookup) {
          return { range: range3, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports2.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create3(range3, expression) {
          return { range: range3, expression };
        }
        InlineValueEvaluatableExpression2.create = create3;
        function is(value3) {
          var candidate = value3;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create3(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Range.is(value3.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports2.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value3) {
          return value3 === 1 || value3 === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports2.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create3(value3) {
          return { value: value3 };
        }
        InlayHintLabelPart2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports2.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create3(position2, label, kind) {
          var result = { position: position2, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports2.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value3) {
          return { kind: "snippet", value: value3 };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports2.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create3(insertText, filterText, range3, command2) {
          return { insertText, filterText, range: range3, command: command2 };
        }
        InlineCompletionItem2.create = create3;
      })(InlineCompletionItem || (exports2.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create3(items) {
          return { items };
        }
        InlineCompletionList2.create = create3;
      })(InlineCompletionList || (exports2.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports2.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create3(range3, text2) {
          return { range: range3, text: text2 };
        }
        SelectedCompletionInfo2.create = create3;
      })(SelectedCompletionInfo || (exports2.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create3(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create3;
      })(InlineCompletionContext || (exports2.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value3) {
          var candidate = value3;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports2.WorkspaceFolder = WorkspaceFolder = {}));
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create3(uri2, languageId, version2, content) {
          return new FullTextDocument2(uri2, languageId, version2, content);
        }
        TextDocument3.create = create3;
        function is(value3) {
          var candidate = value3;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits(document, edits) {
          var text2 = document.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text2.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text2 = text2.substring(0, startOffset) + e.newText + text2.substring(endOffset, text2.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text2;
        }
        TextDocument3.applyEdits = applyEdits;
        function mergeSort2(data, compare5) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare5);
          mergeSort2(right, compare5);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare5(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 || (exports2.TextDocument = TextDocument2 = {}));
      var FullTextDocument2 = (
        /** @class */
        function() {
          function FullTextDocument3(uri2, languageId, version2, content) {
            this._uri = uri2;
            this._languageId = languageId;
            this._version = version2;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range3) {
            if (range3) {
              var start = this.offsetAt(range3.start);
              var end = this.offsetAt(range3.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version2) {
            this._content = event.text;
            this._version = version2;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text2 = this._content;
              var isLineStart = true;
              for (var i = 0; i < text2.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text2.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text2.length && text2.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text2.length > 0) {
                lineOffsets.push(text2.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position2.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line2 = low - 1;
            return Position2.create(line2, offset - lineOffsets[line2]);
          };
          FullTextDocument3.prototype.offsetAt = function(position2) {
            var lineOffsets = this.getLineOffsets();
            if (position2.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position2.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position2.line];
            var nextLineOffset = position2.line + 1 < lineOffsets.length ? lineOffsets[position2.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position2.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        }()
      );
      var Is;
      (function(Is2) {
        var toString7 = Object.prototype.toString;
        function defined(value3) {
          return typeof value3 !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value3) {
          return typeof value3 === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value3) {
          return value3 === true || value3 === false;
        }
        Is2.boolean = boolean;
        function string5(value3) {
          return toString7.call(value3) === "[object String]";
        }
        Is2.string = string5;
        function number2(value3) {
          return toString7.call(value3) === "[object Number]";
        }
        Is2.number = number2;
        function numberRange(value3, min5, max4) {
          return toString7.call(value3) === "[object Number]" && min5 <= value3 && value3 <= max4;
        }
        Is2.numberRange = numberRange;
        function integer2(value3) {
          return toString7.call(value3) === "[object Number]" && -2147483648 <= value3 && value3 <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value3) {
          return toString7.call(value3) === "[object Number]" && 0 <= value3 && value3 <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value3) {
          return toString7.call(value3) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value3) {
          return value3 !== null && typeof value3 === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value3, check) {
          return Array.isArray(value3) && value3.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value3) {
      return value3 === true || value3 === false;
    }
    exports.boolean = boolean;
    function string5(value3) {
      return typeof value3 === "string" || value3 instanceof String;
    }
    exports.string = string5;
    function number2(value3) {
      return typeof value3 === "number" || value3 instanceof Number;
    }
    exports.number = number2;
    function error5(value3) {
      return value3 instanceof Error;
    }
    exports.error = error5;
    function func(value3) {
      return typeof value3 === "function";
    }
    exports.func = func;
    function array2(value3) {
      return Array.isArray(value3);
    }
    exports.array = array2;
    function stringArray(value3) {
      return array2(value3) && value3.every((elem4) => string5(elem4));
    }
    exports.stringArray = stringArray;
    function typedArray(value3, check) {
      return Array.isArray(value3) && value3.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value3) {
      return value3 !== null && typeof value3 === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value3) {
        return value3 === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value3) {
        const candidate = value3;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value3) {
        return value3 === 1 || value3 === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create3(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create3;
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one2, other) {
        if (one2 === other) {
          return true;
        }
        if (one2 === null || one2 === void 0 || other === null || other === void 0) {
          return false;
        }
        return one2.executionOrder === other.executionOrder && one2.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create3(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create3;
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one2, two) {
        const result = /* @__PURE__ */ new Set();
        if (one2.document !== two.document) {
          result.add("document");
        }
        if (one2.kind !== two.kind) {
          result.add("kind");
        }
        if (one2.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one2.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one2.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one2.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one2.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one2, other) {
        if (one2 === other) {
          return true;
        }
        if (one2 === null || one2 === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one2 !== typeof other) {
          return false;
        }
        if (typeof one2 !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one2);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one2.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one2.length; i++) {
            if (!equalsMetadata(one2[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one2) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one2);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop2 = oneKeys[i];
            if (!equalsMetadata(one2[prop2], other[prop2])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create3(uri2, notebookType, version2, cells) {
        return { uri: uri2, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create3;
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create3(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create3;
    })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value3) {
        const candidate = value3;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value3) {
        if (!Array.isArray(value3)) {
          return false;
        }
        for (let elem4 of value3) {
          if (!Is.string(elem4) && !TextDocumentFilter.is(elem4) && !NotebookCellTextDocumentFilter.is(elem4)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value3) {
        const candidate = value3;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value3) {
        const candidate = value3;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value3) {
        const candidate = value3;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value3) {
        const candidate = value3;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar(require_main2(), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array2) {
        return array2[Math.floor(array2.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value3) {
      return _UUIDPattern.test(value3);
    }
    exports.isUUID = isUUID;
    function parse3(value3) {
      if (!isUUID(value3)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value3);
    }
    exports.parse = parse3;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title2, percentage, message2, cancellable) {
        let param = {
          kind: "begin",
          title: title2,
          percentage,
          message: message2,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection, token2) {
        super(connection, token2);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token2 = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection, token2);
    }
    exports.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token2) {
          if (token2 === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token2);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token2 = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token: token2 }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token2);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token2 = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection, token2);
    }
    exports.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line2, char2, length9, tokenType, tokenModifiers) {
        let pushLine = line2;
        let pushChar = char2;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length9;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line2;
        this._prevChar = char2;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri2) {
        return this._syncedDocuments.get(uri2);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version: version2 } = td;
          if (version2 === null || version2 === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version2);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token2) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token2);
          } else {
            return [];
          }
        }));
        disposables.push(connection.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports.TextDocuments = TextDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotebookDocuments = exports.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri2) {
        return this.notebookDocuments.get(uri2);
      }
      getNotebookCell(uri2) {
        const value3 = this.notebookCellMap.get(uri2);
        return value3 && value3[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value3 = this.notebookCellMap.get(key);
        return value3 && value3[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text2 = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array2 = changedCells.structure.array;
              notebookDocument.cells.splice(array2.start, array2.deleteCount, ...array2.cells !== void 0 ? array2.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text2.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text2) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value3) {
      if (value3 === null) {
        return void 0;
      }
      return value3;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message2) {
        let count = this._messages[message2];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message2] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message2) => {
          connection.window.showErrorMessage(message2);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message2) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message2);
      }
      warn(message2) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message2);
      }
      info(message2) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message2);
      }
      log(message2) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message2);
      }
      debug(message2) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message2);
      }
      send(type, message2) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message: message2 }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message2, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message: message2, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message2, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message: message2, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message2, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message: message2, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create3() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create3;
    })(BulkRegistration || (exports.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create3() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create3;
    })(BulkUnregistration || (exports.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value3) {
          return value3 && !!value3.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value3) {
        this._trace = value3;
      }
      log(message2, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message: message2,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one2, two) {
      return function(Base) {
        return two(one2(Base));
      };
    }
    exports.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one2, two) {
      function combine(one3, two2, func) {
        if (one3 && two2) {
          return func(one3, two2);
        } else if (one3) {
          return one3;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one2.console, two.console, combineConsoleFeatures),
        tracer: combine(one2.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one2.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one2.client, two.client, combineClientFeatures),
        window: combine(one2.window, two.window, combineWindowFeatures),
        workspace: combine(one2.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one2.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one2.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection3(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = connectionFactory(logger);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value3) {
        if (value3 instanceof Promise) {
          return value3;
        } else if (Is.thenable(value3)) {
          return new Promise((resolve2, reject) => {
            value3.then((resolved) => resolve2(resolved), (error5) => reject(error5));
          });
        } else {
          return Promise.resolve(value3);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          return connection.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), void 0);
          return asPromise(result).then((value3) => {
            if (value3 instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value3;
            }
            let result2 = value3;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports.createConnection = createConnection3;
  }
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/node/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
    var url = __require("url");
    var path3 = __require("path");
    var fs = __require("fs");
    var child_process_1 = __require("child_process");
    function uriToFilePath(uri2) {
      let parsed = url.parse(uri2);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second2 = segments[1];
        if (first.length === 0 && second2.length > 1 && second2[1] === ":") {
          segments.shift();
        }
      }
      return path3.normalize(segments.join("/"));
    }
    exports.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve2(moduleName, nodePath, cwd2, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve3, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path3.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd: cwd2,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error5) => {
            reject(error5);
          });
          cp.on("message", (message3) => {
            if (message3.c === "r") {
              cp.send({ c: "e" });
              if (message3.s) {
                resolve3(message3.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message2 = {
            c: "rs",
            a: moduleName
          };
          cp.send(message2);
        } catch (error5) {
          reject(error5);
        }
      });
    }
    exports.resolve = resolve2;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout2 = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout2) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix2 = stdout2.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix2}`);
        }
        if (prefix2.length > 0) {
          if (isWindows()) {
            return path3.join(prefix2, "node_modules");
          } else {
            return path3.join(prefix2, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout2 = results.stdout;
        if (!stdout2) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines2 = stdout2.trim().split(/\r?\n/);
        for (let line2 of lines2) {
          try {
            let yarn = JSON.parse(line2);
            if (yarn.type === "log") {
              return path3.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path3.normalize(child).indexOf(path3.normalize(parent)) === 0;
        } else {
          return path3.normalize(child).toLowerCase().indexOf(path3.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem || (exports.FileSystem = FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path3.isAbsolute(nodePath)) {
          nodePath = path3.join(workspaceRoot, nodePath);
        }
        return resolve2(moduleName, nodePath, nodePath, tracer).then((value3) => {
          if (FileSystem.isParent(nodePath, value3)) {
            return value3;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve2(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve2(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports, module) {
    "use strict";
    module.exports = require_main3();
  }
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main3(), exports);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.Files = void 0;
    var node_util_1 = __require("node:util");
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports);
    __exportStar(require_api3(), exports);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files || (exports.Files = Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value3) {
        try {
          let processId = parseInt(value3);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value3) {
        _shutdownReceived = value3;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection3(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports.createConnection = createConnection3;
    function _createConnection(input, output, options, factories) {
      let stdio = false;
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv2 = process.argv.slice(2);
        for (let i = 0; i < argv2.length; i++) {
          let arg = argv2[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            stdio = true;
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv2[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv2[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        if (stdio) {
          patchConsole(logger);
        }
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
    function patchConsole(logger) {
      function serialize(args) {
        return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
      }
      const counters = /* @__PURE__ */ new Map();
      console.assert = function assert(assertion, ...args) {
        if (assertion) {
          return;
        }
        if (args.length === 0) {
          logger.error("Assertion failed");
        } else {
          const [message2, ...rest] = args;
          logger.error(`Assertion failed: ${message2} ${serialize(rest)}`);
        }
      };
      console.count = function count(label = "default") {
        const message2 = String(label);
        let counter = counters.get(message2) ?? 0;
        counter += 1;
        counters.set(message2, counter);
        logger.log(`${message2}: ${message2}`);
      };
      console.countReset = function countReset(label) {
        if (label === void 0) {
          counters.clear();
        } else {
          counters.delete(String(label));
        }
      };
      console.debug = function debug3(...args) {
        logger.log(serialize(args));
      };
      console.dir = function dir(arg, options) {
        logger.log((0, node_util_1.inspect)(arg, options));
      };
      console.log = function log6(...args) {
        logger.log(serialize(args));
      };
      console.error = function error5(...args) {
        logger.error(serialize(args));
      };
      console.trace = function trace(...args) {
        const stack = new Error().stack.replace(/(.+\n){2}/, "");
        let message2 = "Trace";
        if (args.length !== 0) {
          message2 += `: ${serialize(args)}`;
        }
        logger.log(`${message2}
${stack}`);
      };
      console.warn = function warn3(...args) {
        logger.warn(serialize(args));
      };
    }
  }
});

// node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver/node.js"(exports, module) {
    "use strict";
    module.exports = require_main4();
  }
});

// output/Data.Semigroup/foreign.js
var concatString = function(s1) {
  return function(s2) {
    return s1 + s2;
  };
};
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0) return ys;
    if (ys.length === 0) return xs;
    return xs.concat(ys);
  };
};

// output/Type.Proxy/index.js
var $$Proxy = /* @__PURE__ */ function() {
  function $$Proxy2() {
  }
  ;
  $$Proxy2.value = new $$Proxy2();
  return $$Proxy2;
}();

// output/Data.Symbol/index.js
var reflectSymbol = function(dict) {
  return dict.reflectSymbol;
};

// output/Data.Unit/foreign.js
var unit = void 0;

// output/Data.Void/index.js
var absurd = function(a) {
  var spin = function($copy_v) {
    var $tco_result;
    function $tco_loop(v) {
      $copy_v = v;
      return;
    }
    ;
    while (true) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return spin(a);
};

// output/Record.Unsafe/foreign.js
var unsafeGet = function(label) {
  return function(rec) {
    return rec[label];
  };
};
var unsafeSet = function(label) {
  return function(value3) {
    return function(rec) {
      var copy = {};
      for (var key in rec) {
        if ({}.hasOwnProperty.call(rec, key)) {
          copy[key] = rec[key];
        }
      }
      copy[label] = value3;
      return copy;
    };
  };
};

// output/Data.Semigroup/index.js
var semigroupString = {
  append: concatString
};
var semigroupRecordNil = {
  appendRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  }
};
var semigroupArray = {
  append: concatArray
};
var appendRecord = function(dict) {
  return dict.appendRecord;
};
var semigroupRecord = function() {
  return function(dictSemigroupRecord) {
    return {
      append: appendRecord(dictSemigroupRecord)($$Proxy.value)
    };
  };
};
var append = function(dict) {
  return dict.append;
};
var semigroupRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictSemigroupRecord) {
      var appendRecord1 = appendRecord(dictSemigroupRecord);
      return function(dictSemigroup) {
        var append110 = append(dictSemigroup);
        return {
          appendRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail2 = appendRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert6 = unsafeSet(key);
                var get3 = unsafeGet(key);
                return insert6(append110(get3(ra))(get3(rb)))(tail2);
              };
            };
          }
        };
      };
    };
  };
};

// output/Control.Apply/foreign.js
var arrayApply = function(fs) {
  return function(xs) {
    var l = fs.length;
    var k = xs.length;
    var result = new Array(l * k);
    var n = 0;
    for (var i = 0; i < l; i++) {
      var f = fs[i];
      for (var j = 0; j < k; j++) {
        result[n++] = f(xs[j]);
      }
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};
var compose = function(dict) {
  return dict.compose;
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var on = function(f) {
  return function(g) {
    return function(x) {
      return function(y) {
        return f(g(x))(g(y));
      };
    };
  };
};
var flip = function(f) {
  return function(b) {
    return function(a) {
      return f(a)(b);
    };
  };
};
var $$const = function(a) {
  return function(v) {
    return a;
  };
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var mapFlipped = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return function(fa) {
    return function(f) {
      return map117(f)(fa);
    };
  };
};
var $$void = function(dictFunctor) {
  return map(dictFunctor)($$const(unit));
};
var voidRight = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return function(x) {
    return map117($$const(x));
  };
};
var functorFn = {
  map: /* @__PURE__ */ compose(semigroupoidFn)
};
var functorArray = {
  map: arrayMap
};
var flap = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return function(ff2) {
    return function(x) {
      return map117(function(f) {
        return f(x);
      })(ff2);
    };
  };
};

// output/Control.Apply/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var applyArray = {
  apply: arrayApply,
  Functor0: function() {
    return functorArray;
  }
};
var apply = function(dict) {
  return dict.apply;
};
var applyFirst = function(dictApply) {
  var apply15 = apply(dictApply);
  var map47 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply15(map47($$const)(a))(b);
    };
  };
};
var applySecond = function(dictApply) {
  var apply15 = apply(dictApply);
  var map47 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply15(map47($$const(identity2))(a))(b);
    };
  };
};

// output/Control.Applicative/index.js
var pure = function(dict) {
  return dict.pure;
};
var unless = function(dictApplicative) {
  var pure114 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (!v) {
        return v1;
      }
      ;
      if (v) {
        return pure114(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var when = function(dictApplicative) {
  var pure114 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return pure114(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var liftA1 = function(dictApplicative) {
  var apply15 = apply(dictApplicative.Apply0());
  var pure114 = pure(dictApplicative);
  return function(f) {
    return function(a) {
      return apply15(pure114(f))(a);
    };
  };
};
var applicativeArray = {
  pure: function(x) {
    return [x];
  },
  Apply0: function() {
    return applyArray;
  }
};

// output/Data.Array/foreign.js
var rangeImpl = function(start, end) {
  var step3 = start > end ? -1 : 1;
  var result = new Array(step3 * (end - start) + 1);
  var i = start, n = 0;
  while (i !== end) {
    result[n++] = i;
    i += step3;
  }
  result[n] = i;
  return result;
};
var replicateFill = function(count, value3) {
  if (count < 1) {
    return [];
  }
  var result = new Array(count);
  return result.fill(value3);
};
var replicatePolyfill = function(count, value3) {
  var result = [];
  var n = 0;
  for (var i = 0; i < count; i++) {
    result[n++] = value3;
  }
  return result;
};
var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var fromFoldableImpl = /* @__PURE__ */ function() {
  function Cons4(head4, tail2) {
    this.head = head4;
    this.tail = tail2;
  }
  var emptyList = {};
  function curryCons(head4) {
    return function(tail2) {
      return new Cons4(head4, tail2);
    };
  }
  function listToArray(list) {
    var result = [];
    var count = 0;
    var xs = list;
    while (xs !== emptyList) {
      result[count++] = xs.head;
      xs = xs.tail;
    }
    return result;
  }
  return function(foldr7, xs) {
    return listToArray(foldr7(curryCons)(emptyList)(xs));
  };
}();
var length = function(xs) {
  return xs.length;
};
var unconsImpl = function(empty10, next2, xs) {
  return xs.length === 0 ? empty10({}) : next2(xs[0])(xs.slice(1));
};
var indexImpl = function(just, nothing, xs, i) {
  return i < 0 || i >= xs.length ? nothing : just(xs[i]);
};
var findMapImpl = function(nothing, isJust2, f, xs) {
  for (var i = 0; i < xs.length; i++) {
    var result = f(xs[i]);
    if (isJust2(result)) return result;
  }
  return nothing;
};
var reverse = function(l) {
  return l.slice().reverse();
};
var filterImpl = function(f, xs) {
  return xs.filter(f);
};
var partitionImpl = function(f, xs) {
  var yes = [];
  var no = [];
  for (var i = 0; i < xs.length; i++) {
    var x = xs[i];
    if (f(x))
      yes.push(x);
    else
      no.push(x);
  }
  return { yes, no };
};
var sortByImpl = /* @__PURE__ */ function() {
  function mergeFromTo(compare5, fromOrdering, xs1, xs2, from3, to2) {
    var mid;
    var i;
    var j;
    var k;
    var x;
    var y;
    var c;
    mid = from3 + (to2 - from3 >> 1);
    if (mid - from3 > 1) mergeFromTo(compare5, fromOrdering, xs2, xs1, from3, mid);
    if (to2 - mid > 1) mergeFromTo(compare5, fromOrdering, xs2, xs1, mid, to2);
    i = from3;
    j = mid;
    k = from3;
    while (i < mid && j < to2) {
      x = xs2[i];
      y = xs2[j];
      c = fromOrdering(compare5(x)(y));
      if (c > 0) {
        xs1[k++] = y;
        ++j;
      } else {
        xs1[k++] = x;
        ++i;
      }
    }
    while (i < mid) {
      xs1[k++] = xs2[i++];
    }
    while (j < to2) {
      xs1[k++] = xs2[j++];
    }
  }
  return function(compare5, fromOrdering, xs) {
    var out;
    if (xs.length < 2) return xs;
    out = xs.slice(0);
    mergeFromTo(compare5, fromOrdering, out, xs.slice(0), 0, xs.length);
    return out;
  };
}();
var sliceImpl = function(s, e, l) {
  return l.slice(s, e);
};
var zipWithImpl = function(f, xs, ys) {
  var l = xs.length < ys.length ? xs.length : ys.length;
  var result = new Array(l);
  for (var i = 0; i < l; i++) {
    result[i] = f(xs[i])(ys[i]);
  }
  return result;
};
var unsafeIndexImpl = function(xs, n) {
  return xs[n];
};

// output/Control.Alt/index.js
var altArray = {
  alt: /* @__PURE__ */ append(semigroupArray),
  Functor0: function() {
    return functorArray;
  }
};
var alt = function(dict) {
  return dict.alt;
};

// output/Control.Bind/foreign.js
var arrayBind = function(arr) {
  return function(f) {
    var result = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      Array.prototype.push.apply(result, f(arr[i]));
    }
    return result;
  };
};

// output/Control.Bind/index.js
var discard = function(dict) {
  return dict.discard;
};
var bindArray = {
  bind: arrayBind,
  Apply0: function() {
    return applyArray;
  }
};
var bind = function(dict) {
  return dict.bind;
};
var bindFlipped = function(dictBind) {
  return flip(bind(dictBind));
};
var composeKleisliFlipped = function(dictBind) {
  var bindFlipped12 = bindFlipped(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bindFlipped12(f)(g(a));
      };
    };
  };
};
var discardUnit = {
  discard: function(dictBind) {
    return bind(dictBind);
  }
};

// output/Control.Lazy/index.js
var defer = function(dict) {
  return dict.defer;
};

// output/Control.Monad/index.js
var liftM1 = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure34 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind30(a)(function(a$prime) {
        return pure34(f(a$prime));
      });
    };
  };
};
var ap = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure34 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind30(f)(function(f$prime) {
        return bind30(a)(function(a$prime) {
          return pure34(f$prime(a$prime));
        });
      });
    };
  };
};

// output/Data.Bounded/foreign.js
var topInt = 2147483647;
var bottomInt = -2147483648;
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq6) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq6 : gt;
        };
      };
    };
  };
};
var ordIntImpl = unsafeCompareImpl;
var ordStringImpl = unsafeCompareImpl;
var ordCharImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqBooleanImpl = refEq;
var eqIntImpl = refEq;
var eqCharImpl = refEq;
var eqStringImpl = refEq;

// output/Data.Eq/index.js
var eqString = {
  eq: eqStringImpl
};
var eqRowNil = {
  eqRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return true;
      };
    };
  }
};
var eqRecord = function(dict) {
  return dict.eqRecord;
};
var eqRec = function() {
  return function(dictEqRecord) {
    return {
      eq: eqRecord(dictEqRecord)($$Proxy.value)
    };
  };
};
var eqInt = {
  eq: eqIntImpl
};
var eqChar = {
  eq: eqCharImpl
};
var eqBoolean = {
  eq: eqBooleanImpl
};
var eq = function(dict) {
  return dict.eq;
};
var eq2 = /* @__PURE__ */ eq(eqBoolean);
var eqRowCons = function(dictEqRecord) {
  var eqRecord1 = eqRecord(dictEqRecord);
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return function(dictEq) {
        var eq32 = eq(dictEq);
        return {
          eqRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail2 = eqRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var get3 = unsafeGet(key);
                return eq32(get3(ra))(get3(rb)) && tail2;
              };
            };
          }
        };
      };
    };
  };
};
var notEq = function(dictEq) {
  var eq32 = eq(dictEq);
  return function(x) {
    return function(y) {
      return eq2(eq32(x)(y))(false);
    };
  };
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
}();
var GT = /* @__PURE__ */ function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
}();
var EQ = /* @__PURE__ */ function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
}();
var eqOrdering = {
  eq: function(v) {
    return function(v1) {
      if (v instanceof LT && v1 instanceof LT) {
        return true;
      }
      ;
      if (v instanceof GT && v1 instanceof GT) {
        return true;
      }
      ;
      if (v instanceof EQ && v1 instanceof EQ) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};

// output/Data.Semiring/index.js
var zero = function(dict) {
  return dict.zero;
};
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};
var add = function(dict) {
  return dict.add;
};

// output/Data.Ring/index.js
var sub = function(dict) {
  return dict.sub;
};
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};
var negate = function(dictRing) {
  var sub1 = sub(dictRing);
  var zero2 = zero(dictRing.Semiring0());
  return function(a) {
    return sub1(zero2)(a);
  };
};

// output/Data.Ord/index.js
var eqRec2 = /* @__PURE__ */ eqRec();
var notEq2 = /* @__PURE__ */ notEq(eqOrdering);
var ordString = /* @__PURE__ */ function() {
  return {
    compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqString;
    }
  };
}();
var ordRecordNil = {
  compareRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return EQ.value;
      };
    };
  },
  EqRecord0: function() {
    return eqRowNil;
  }
};
var ordInt = /* @__PURE__ */ function() {
  return {
    compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqInt;
    }
  };
}();
var ordChar = /* @__PURE__ */ function() {
  return {
    compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqChar;
    }
  };
}();
var compareRecord = function(dict) {
  return dict.compareRecord;
};
var ordRecord = function() {
  return function(dictOrdRecord) {
    var eqRec1 = eqRec2(dictOrdRecord.EqRecord0());
    return {
      compare: compareRecord(dictOrdRecord)($$Proxy.value),
      Eq0: function() {
        return eqRec1;
      }
    };
  };
};
var compare = function(dict) {
  return dict.compare;
};
var comparing = function(dictOrd) {
  var compare32 = compare(dictOrd);
  return function(f) {
    return function(x) {
      return function(y) {
        return compare32(f(x))(f(y));
      };
    };
  };
};
var greaterThan = function(dictOrd) {
  var compare32 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare32(a1)(a2);
      if (v instanceof GT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var greaterThanOrEq = function(dictOrd) {
  var compare32 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare32(a1)(a2);
      if (v instanceof LT) {
        return false;
      }
      ;
      return true;
    };
  };
};
var max = function(dictOrd) {
  var compare32 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare32(x)(y);
      if (v instanceof LT) {
        return y;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return x;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): " + [v.constructor.name]);
    };
  };
};
var min = function(dictOrd) {
  var compare32 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare32(x)(y);
      if (v instanceof LT) {
        return x;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return y;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v.constructor.name]);
    };
  };
};
var ordRecordCons = function(dictOrdRecord) {
  var compareRecord1 = compareRecord(dictOrdRecord);
  var eqRowCons2 = eqRowCons(dictOrdRecord.EqRecord0())();
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      var eqRowCons1 = eqRowCons2(dictIsSymbol);
      return function(dictOrd) {
        var compare32 = compare(dictOrd);
        var eqRowCons22 = eqRowCons1(dictOrd.Eq0());
        return {
          compareRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var key = reflectSymbol2($$Proxy.value);
                var left = compare32(unsafeGet(key)(ra))(unsafeGet(key)(rb));
                var $95 = notEq2(left)(EQ.value);
                if ($95) {
                  return left;
                }
                ;
                return compareRecord1($$Proxy.value)(ra)(rb);
              };
            };
          },
          EqRecord0: function() {
            return eqRowCons22;
          }
        };
      };
    };
  };
};
var abs = function(dictOrd) {
  var greaterThanOrEq1 = greaterThanOrEq(dictOrd);
  return function(dictRing) {
    var zero2 = zero(dictRing.Semiring0());
    var negate1 = negate(dictRing);
    return function(x) {
      var $99 = greaterThanOrEq1(x)(zero2);
      if ($99) {
        return x;
      }
      ;
      return negate1(x);
    };
  };
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedInt = {
  top: topInt,
  bottom: bottomInt,
  Ord0: function() {
    return ordInt;
  }
};
var boundedChar = {
  top: topChar,
  bottom: bottomChar,
  Ord0: function() {
    return ordChar;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Show/foreign.js
var showIntImpl = function(n) {
  return n.toString();
};
var showCharImpl = function(c) {
  var code = c.charCodeAt(0);
  if (code < 32 || code === 127) {
    switch (c) {
      case "\x07":
        return "'\\a'";
      case "\b":
        return "'\\b'";
      case "\f":
        return "'\\f'";
      case "\n":
        return "'\\n'";
      case "\r":
        return "'\\r'";
      case "	":
        return "'\\t'";
      case "\v":
        return "'\\v'";
    }
    return "'\\" + code.toString(10) + "'";
  }
  return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
};
var showStringImpl = function(s) {
  var l = s.length;
  return '"' + s.replace(
    /[\0-\x1F\x7F"\\]/g,
    // eslint-disable-line no-control-regex
    function(c, i) {
      switch (c) {
        case '"':
        case "\\":
          return "\\" + c;
        case "\x07":
          return "\\a";
        case "\b":
          return "\\b";
        case "\f":
          return "\\f";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "	":
          return "\\t";
        case "\v":
          return "\\v";
      }
      var k = i + 1;
      var empty10 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
      return "\\" + c.charCodeAt(0).toString(10) + empty10;
    }
  ) + '"';
};
var showArrayImpl = function(f) {
  return function(xs) {
    var ss = [];
    for (var i = 0, l = xs.length; i < l; i++) {
      ss[i] = f(xs[i]);
    }
    return "[" + ss.join(",") + "]";
  };
};

// output/Data.Show/index.js
var showString = {
  show: showStringImpl
};
var showInt = {
  show: showIntImpl
};
var showChar = {
  show: showCharImpl
};
var show = function(dict) {
  return dict.show;
};
var showArray = function(dictShow) {
  return {
    show: showArrayImpl(show(dictShow))
  };
};

// output/Data.Maybe/index.js
var identity3 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
}();
var Just = /* @__PURE__ */ function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
}();
var showMaybe = function(dictShow) {
  var show11 = show(dictShow);
  return {
    show: function(v) {
      if (v instanceof Just) {
        return "(Just " + (show11(v.value0) + ")");
      }
      ;
      if (v instanceof Nothing) {
        return "Nothing";
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 223, column 1 - line 225, column 28): " + [v.constructor.name]);
    }
  };
};
var semigroupMaybe = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return v1;
        }
        ;
        if (v1 instanceof Nothing) {
          return v;
        }
        ;
        if (v instanceof Just && v1 instanceof Just) {
          return new Just(append110(v.value0)(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 182, column 1 - line 185, column 43): " + [v.constructor.name, v1.constructor.name]);
      };
    }
  };
};
var monoidMaybe = function(dictSemigroup) {
  var semigroupMaybe1 = semigroupMaybe(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupMaybe1;
    }
  };
};
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));
var functorMaybe = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      ;
      return Nothing.value;
    };
  }
};
var map2 = /* @__PURE__ */ map(functorMaybe);
var fromMaybe = function(a) {
  return maybe(a)(identity3);
};
var fromJust = function() {
  return function(v) {
    if (v instanceof Just) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
  };
};
var eqMaybe = function(dictEq) {
  var eq6 = eq(dictEq);
  return {
    eq: function(x) {
      return function(y) {
        if (x instanceof Nothing && y instanceof Nothing) {
          return true;
        }
        ;
        if (x instanceof Just && y instanceof Just) {
          return eq6(x.value0)(y.value0);
        }
        ;
        return false;
      };
    }
  };
};
var ordMaybe = function(dictOrd) {
  var compare5 = compare(dictOrd);
  var eqMaybe1 = eqMaybe(dictOrd.Eq0());
  return {
    compare: function(x) {
      return function(y) {
        if (x instanceof Nothing && y instanceof Nothing) {
          return EQ.value;
        }
        ;
        if (x instanceof Nothing) {
          return LT.value;
        }
        ;
        if (y instanceof Nothing) {
          return GT.value;
        }
        ;
        if (x instanceof Just && y instanceof Just) {
          return compare5(x.value0)(y.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
      };
    },
    Eq0: function() {
      return eqMaybe1;
    }
  };
};
var applyMaybe = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return map2(v.value0)(v1);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var bindMaybe = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v1(v.value0);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyMaybe;
  }
};
var applicativeMaybe = /* @__PURE__ */ function() {
  return {
    pure: Just.create,
    Apply0: function() {
      return applyMaybe;
    }
  };
}();
var altMaybe = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Nothing) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var plusMaybe = /* @__PURE__ */ function() {
  return {
    empty: Nothing.value,
    Alt0: function() {
      return altMaybe;
    }
  };
}();
var alternativeMaybe = {
  Applicative0: function() {
    return applicativeMaybe;
  },
  Plus1: function() {
    return plusMaybe;
  }
};

// output/Data.Either/index.js
var Left = /* @__PURE__ */ function() {
  function Left2(value0) {
    this.value0 = value0;
  }
  ;
  Left2.create = function(value0) {
    return new Left2(value0);
  };
  return Left2;
}();
var Right = /* @__PURE__ */ function() {
  function Right2(value0) {
    this.value0 = value0;
  }
  ;
  Right2.create = function(value0) {
    return new Right2(value0);
  };
  return Right2;
}();
var functorEither = {
  map: function(f) {
    return function(m) {
      if (m instanceof Left) {
        return new Left(m.value0);
      }
      ;
      if (m instanceof Right) {
        return new Right(f(m.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map3 = /* @__PURE__ */ map(functorEither);
var either = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Left) {
        return v(v2.value0);
      }
      ;
      if (v2 instanceof Right) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var hush = /* @__PURE__ */ function() {
  return either($$const(Nothing.value))(Just.create);
}();
var applyEither = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return new Left(v.value0);
      }
      ;
      if (v instanceof Right) {
        return map3(v.value0)(v1);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorEither;
  }
};
var bindEither = {
  bind: /* @__PURE__ */ either(function(e) {
    return function(v) {
      return new Left(e);
    };
  })(function(a) {
    return function(f) {
      return f(a);
    };
  }),
  Apply0: function() {
    return applyEither;
  }
};

// output/Data.Identity/index.js
var Identity = function(x) {
  return x;
};
var functorIdentity = {
  map: function(f) {
    return function(m) {
      return f(m);
    };
  }
};
var applyIdentity = {
  apply: function(v) {
    return function(v1) {
      return v(v1);
    };
  },
  Functor0: function() {
    return functorIdentity;
  }
};
var bindIdentity = {
  bind: function(v) {
    return function(f) {
      return f(v);
    };
  },
  Apply0: function() {
    return applyIdentity;
  }
};
var applicativeIdentity = {
  pure: Identity,
  Apply0: function() {
    return applyIdentity;
  }
};
var monadIdentity = {
  Applicative0: function() {
    return applicativeIdentity;
  },
  Bind1: function() {
    return bindIdentity;
  }
};

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0) return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0) return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};
var div = function(dict) {
  return dict.div;
};

// output/Data.Monoid/index.js
var semigroupRecord2 = /* @__PURE__ */ semigroupRecord();
var monoidString = {
  mempty: "",
  Semigroup0: function() {
    return semigroupString;
  }
};
var monoidRecordNil = {
  memptyRecord: function(v) {
    return {};
  },
  SemigroupRecord0: function() {
    return semigroupRecordNil;
  }
};
var monoidArray = {
  mempty: [],
  Semigroup0: function() {
    return semigroupArray;
  }
};
var memptyRecord = function(dict) {
  return dict.memptyRecord;
};
var monoidRecord = function() {
  return function(dictMonoidRecord) {
    var semigroupRecord1 = semigroupRecord2(dictMonoidRecord.SemigroupRecord0());
    return {
      mempty: memptyRecord(dictMonoidRecord)($$Proxy.value),
      Semigroup0: function() {
        return semigroupRecord1;
      }
    };
  };
};
var mempty = function(dict) {
  return dict.mempty;
};
var monoidRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  var semigroupRecordCons2 = semigroupRecordCons(dictIsSymbol)();
  return function(dictMonoid) {
    var mempty15 = mempty(dictMonoid);
    var Semigroup0 = dictMonoid.Semigroup0();
    return function() {
      return function(dictMonoidRecord) {
        var memptyRecord1 = memptyRecord(dictMonoidRecord);
        var semigroupRecordCons1 = semigroupRecordCons2(dictMonoidRecord.SemigroupRecord0())(Semigroup0);
        return {
          memptyRecord: function(v) {
            var tail2 = memptyRecord1($$Proxy.value);
            var key = reflectSymbol2($$Proxy.value);
            var insert6 = unsafeSet(key);
            return insert6(mempty15)(tail2);
          },
          SemigroupRecord0: function() {
            return semigroupRecordCons1;
          }
        };
      };
    };
  };
};

// output/Effect/foreign.js
var pureE = function(a) {
  return function() {
    return a;
  };
};
var bindE = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};

// output/Effect/index.js
var $runtime_lazy = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var monadEffect = {
  Applicative0: function() {
    return applicativeEffect;
  },
  Bind1: function() {
    return bindEffect;
  }
};
var bindEffect = {
  bind: bindE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var applicativeEffect = {
  pure: pureE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
  return {
    map: liftA1(applicativeEffect)
  };
});
var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
  return {
    apply: ap(monadEffect),
    Functor0: function() {
      return $lazy_functorEffect(0);
    }
  };
});
var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);
var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);

// output/Control.Monad.Rec.Class/index.js
var Loop = /* @__PURE__ */ function() {
  function Loop2(value0) {
    this.value0 = value0;
  }
  ;
  Loop2.create = function(value0) {
    return new Loop2(value0);
  };
  return Loop2;
}();
var Done = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var tailRecM = function(dict) {
  return dict.tailRecM;
};
var tailRec = function(f) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Loop) {
        $copy_v = f(v.value0);
        return;
      }
      ;
      if (v instanceof Done) {
        $tco_done = true;
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 103, column 3 - line 103, column 25): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return function($85) {
    return go(f($85));
  };
};
var monadRecIdentity = {
  tailRecM: function(f) {
    var runIdentity = function(v) {
      return v;
    };
    var $86 = tailRec(function($88) {
      return runIdentity(f($88));
    });
    return function($87) {
      return Identity($86($87));
    };
  },
  Monad0: function() {
    return monadIdentity;
  }
};
var bifunctorStep = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Loop) {
          return new Loop(v(v2.value0));
        }
        ;
        if (v2 instanceof Done) {
          return new Done(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 33, column 1 - line 35, column 34): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Control.Monad.ST.Internal/foreign.js
var map_ = function(f) {
  return function(a) {
    return function() {
      return f(a());
    };
  };
};
var pure_ = function(a) {
  return function() {
    return a;
  };
};
var bind_ = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};
var foreach = function(as) {
  return function(f) {
    return function() {
      for (var i = 0, l = as.length; i < l; i++) {
        f(as[i])();
      }
    };
  };
};
function newSTRef(val) {
  return function() {
    return { value: val };
  };
}
var read2 = function(ref) {
  return function() {
    return ref.value;
  };
};
var modifyImpl2 = function(f) {
  return function(ref) {
    return function() {
      var t = f(ref.value);
      ref.value = t.state;
      return t.value;
    };
  };
};
var write2 = function(a) {
  return function(ref) {
    return function() {
      return ref.value = a;
    };
  };
};

// output/Control.Monad.ST.Internal/index.js
var $runtime_lazy2 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var modify$prime = modifyImpl2;
var modify = function(f) {
  return modify$prime(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var functorST = {
  map: map_
};
var monadST = {
  Applicative0: function() {
    return applicativeST;
  },
  Bind1: function() {
    return bindST;
  }
};
var bindST = {
  bind: bind_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var applicativeST = {
  pure: pure_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2("applyST", "Control.Monad.ST.Internal", function() {
  return {
    apply: ap(monadST),
    Functor0: function() {
      return functorST;
    }
  };
});

// output/Data.Array.ST/foreign.js
function newSTArray() {
  return [];
}
function unsafeFreezeThawImpl(xs) {
  return xs;
}
var unsafeFreezeImpl = unsafeFreezeThawImpl;
var unsafeThawImpl = unsafeFreezeThawImpl;
function copyImpl(xs) {
  return xs.slice();
}
var thawImpl = copyImpl;
var pushImpl = function(a, xs) {
  return xs.push(a);
};

// output/Control.Monad.ST.Uncurried/foreign.js
var runSTFn1 = function runSTFn12(fn) {
  return function(a) {
    return function() {
      return fn(a);
    };
  };
};
var runSTFn2 = function runSTFn22(fn) {
  return function(a) {
    return function(b) {
      return function() {
        return fn(a, b);
      };
    };
  };
};

// output/Data.Array.ST/index.js
var unsafeThaw = /* @__PURE__ */ runSTFn1(unsafeThawImpl);
var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);
var thaw = /* @__PURE__ */ runSTFn1(thawImpl);
var withArray = function(f) {
  return function(xs) {
    return function __do() {
      var result = thaw(xs)();
      f(result)();
      return unsafeFreeze(result)();
    };
  };
};
var push = /* @__PURE__ */ runSTFn2(pushImpl);

// output/Data.HeytingAlgebra/foreign.js
var boolConj = function(b1) {
  return function(b2) {
    return b1 && b2;
  };
};
var boolDisj = function(b1) {
  return function(b2) {
    return b1 || b2;
  };
};
var boolNot = function(b) {
  return !b;
};

// output/Data.HeytingAlgebra/index.js
var tt = function(dict) {
  return dict.tt;
};
var not = function(dict) {
  return dict.not;
};
var implies = function(dict) {
  return dict.implies;
};
var ff = function(dict) {
  return dict.ff;
};
var disj = function(dict) {
  return dict.disj;
};
var heytingAlgebraBoolean = {
  ff: false,
  tt: true,
  implies: function(a) {
    return function(b) {
      return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
    };
  },
  conj: boolConj,
  disj: boolDisj,
  not: boolNot
};
var conj = function(dict) {
  return dict.conj;
};
var heytingAlgebraFunction = function(dictHeytingAlgebra) {
  var ff1 = ff(dictHeytingAlgebra);
  var tt1 = tt(dictHeytingAlgebra);
  var implies1 = implies(dictHeytingAlgebra);
  var conj1 = conj(dictHeytingAlgebra);
  var disj1 = disj(dictHeytingAlgebra);
  var not1 = not(dictHeytingAlgebra);
  return {
    ff: function(v) {
      return ff1;
    },
    tt: function(v) {
      return tt1;
    },
    implies: function(f) {
      return function(g) {
        return function(a) {
          return implies1(f(a))(g(a));
        };
      };
    },
    conj: function(f) {
      return function(g) {
        return function(a) {
          return conj1(f(a))(g(a));
        };
      };
    },
    disj: function(f) {
      return function(g) {
        return function(a) {
          return disj1(f(a))(g(a));
        };
      };
    },
    not: function(f) {
      return function(a) {
        return not1(f(a));
      };
    }
  };
};

// output/Data.Array.ST.Iterator/index.js
var map4 = /* @__PURE__ */ map(functorST);
var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);
var $$void2 = /* @__PURE__ */ $$void(functorST);
var Iterator = /* @__PURE__ */ function() {
  function Iterator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Iterator2.create = function(value0) {
    return function(value12) {
      return new Iterator2(value0, value12);
    };
  };
  return Iterator2;
}();
var peek = function(v) {
  return function __do() {
    var i = read2(v.value1)();
    return v.value0(i);
  };
};
var next = function(v) {
  return function __do() {
    var i = read2(v.value1)();
    modify(function(v1) {
      return v1 + 1 | 0;
    })(v.value1)();
    return v.value0(i);
  };
};
var pushWhile = function(p) {
  return function(iter) {
    return function(array2) {
      return function __do() {
        var $$break = newSTRef(false)();
        while (map4(not2)(read2($$break))()) {
          (function __do2() {
            var mx = peek(iter)();
            if (mx instanceof Just && p(mx.value0)) {
              push(mx.value0)(array2)();
              return $$void2(next(iter))();
            }
            ;
            return $$void2(write2(true)($$break))();
          })();
        }
        ;
        return {};
      };
    };
  };
};
var iterator = function(f) {
  return map4(Iterator.create(f))(newSTRef(0));
};
var iterate = function(iter) {
  return function(f) {
    return function __do() {
      var $$break = newSTRef(false)();
      while (map4(not2)(read2($$break))()) {
        (function __do2() {
          var mx = next(iter)();
          if (mx instanceof Just) {
            return f(mx.value0)();
          }
          ;
          if (mx instanceof Nothing) {
            return $$void2(write2(true)($$break))();
          }
          ;
          throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [mx.constructor.name]);
        })();
      }
      ;
      return {};
    };
  };
};

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init3) {
    return function(xs) {
      var acc = init3;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init3) {
    return function(xs) {
      var acc = init3;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Control.Plus/index.js
var plusArray = {
  empty: [],
  Alt0: function() {
    return altArray;
  }
};
var empty = function(dict) {
  return dict.empty;
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ function() {
  function Tuple2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value12) {
      return new Tuple2(value0, value12);
    };
  };
  return Tuple2;
}();
var uncurry = function(f) {
  return function(v) {
    return f(v.value0)(v.value1);
  };
};
var snd = function(v) {
  return v.value1;
};
var showTuple = function(dictShow) {
  var show11 = show(dictShow);
  return function(dictShow1) {
    var show15 = show(dictShow1);
    return {
      show: function(v) {
        return "(Tuple " + (show11(v.value0) + (" " + (show15(v.value1) + ")")));
      }
    };
  };
};
var semigroupTuple = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return function(dictSemigroup1) {
    var append22 = append(dictSemigroup1);
    return {
      append: function(v) {
        return function(v1) {
          return new Tuple(append110(v.value0)(v1.value0), append22(v.value1)(v1.value1));
        };
      }
    };
  };
};
var monoidTuple = function(dictMonoid) {
  var mempty9 = mempty(dictMonoid);
  var semigroupTuple1 = semigroupTuple(dictMonoid.Semigroup0());
  return function(dictMonoid1) {
    var semigroupTuple2 = semigroupTuple1(dictMonoid1.Semigroup0());
    return {
      mempty: new Tuple(mempty9, mempty(dictMonoid1)),
      Semigroup0: function() {
        return semigroupTuple2;
      }
    };
  };
};
var functorTuple = {
  map: function(f) {
    return function(m) {
      return new Tuple(m.value0, f(m.value1));
    };
  }
};
var fst = function(v) {
  return v.value0;
};
var curry = function(f) {
  return function(a) {
    return function(b) {
      return f(new Tuple(a, b));
    };
  };
};
var applyTuple = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return {
    apply: function(v) {
      return function(v1) {
        return new Tuple(append110(v.value0)(v1.value0), v.value1(v1.value1));
      };
    },
    Functor0: function() {
      return functorTuple;
    }
  };
};
var applicativeTuple = function(dictMonoid) {
  var applyTuple1 = applyTuple(dictMonoid.Semigroup0());
  return {
    pure: Tuple.create(mempty(dictMonoid)),
    Apply0: function() {
      return applyTuple1;
    }
  };
};

// output/Data.Bifunctor/index.js
var identity4 = /* @__PURE__ */ identity(categoryFn);
var bimap = function(dict) {
  return dict.bimap;
};
var lmap = function(dictBifunctor) {
  var bimap1 = bimap(dictBifunctor);
  return function(f) {
    return bimap1(f)(identity4);
  };
};
var bifunctorTuple = {
  bimap: function(f) {
    return function(g) {
      return function(v) {
        return new Tuple(f(v.value0), g(v.value1));
      };
    };
  }
};
var bifunctorEither = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return new Left(v(v2.value0));
        }
        ;
        if (v2 instanceof Right) {
          return new Right(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Data.Maybe.First/index.js
var semigroupFirst = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v;
      }
      ;
      return v1;
    };
  }
};
var monoidFirst = /* @__PURE__ */ function() {
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupFirst;
    }
  };
}();

// output/Data.Monoid.Conj/index.js
var Conj = function(x) {
  return x;
};
var semigroupConj = function(dictHeytingAlgebra) {
  var conj2 = conj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return conj2(v)(v1);
      };
    }
  };
};
var monoidConj = function(dictHeytingAlgebra) {
  var semigroupConj1 = semigroupConj(dictHeytingAlgebra);
  return {
    mempty: tt(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupConj1;
    }
  };
};

// output/Data.Monoid.Disj/index.js
var Disj = function(x) {
  return x;
};
var semigroupDisj = function(dictHeytingAlgebra) {
  var disj2 = disj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return disj2(v)(v1);
      };
    }
  };
};
var monoidDisj = function(dictHeytingAlgebra) {
  var semigroupDisj1 = semigroupDisj(dictHeytingAlgebra);
  return {
    mempty: ff(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupDisj1;
    }
  };
};

// output/Unsafe.Coerce/foreign.js
var unsafeCoerce2 = function(x) {
  return x;
};

// output/Safe.Coerce/index.js
var coerce = function() {
  return unsafeCoerce2;
};

// output/Data.Newtype/index.js
var coerce2 = /* @__PURE__ */ coerce();
var wrap = function() {
  return coerce2;
};
var wrap1 = /* @__PURE__ */ wrap();
var unwrap = function() {
  return coerce2;
};
var unwrap1 = /* @__PURE__ */ unwrap();
var un = function() {
  return function(v) {
    return unwrap1;
  };
};
var over = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var alaF = function() {
  return function() {
    return function() {
      return function() {
        return function(v) {
          return coerce2;
        };
      };
    };
  };
};
var ala = function() {
  return function() {
    return function() {
      return function(v) {
        return function(f) {
          return coerce2(f(wrap1));
        };
      };
    };
  };
};

// output/Data.Foldable/index.js
var identity5 = /* @__PURE__ */ identity(categoryFn);
var unwrap2 = /* @__PURE__ */ unwrap();
var alaF2 = /* @__PURE__ */ alaF()()()();
var foldr = function(dict) {
  return dict.foldr;
};
var oneOf = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    return foldr22(alt(dictPlus.Alt0()))(empty(dictPlus));
  };
};
var traverse_ = function(dictApplicative) {
  var applySecond4 = applySecond(dictApplicative.Apply0());
  var pure34 = pure(dictApplicative);
  return function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(f) {
      return foldr22(function($454) {
        return applySecond4(f($454));
      })(pure34(unit));
    };
  };
};
var for_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return flip(traverse_1(dictFoldable));
  };
};
var foldl = function(dict) {
  return dict.foldl;
};
var intercalate = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictMonoid) {
    var append11 = append(dictMonoid.Semigroup0());
    var mempty9 = mempty(dictMonoid);
    return function(sep3) {
      return function(xs) {
        var go = function(v) {
          return function(v1) {
            if (v.init) {
              return {
                init: false,
                acc: v1
              };
            }
            ;
            return {
              init: false,
              acc: append11(v.acc)(append11(sep3)(v1))
            };
          };
        };
        return foldl22(go)({
          init: true,
          acc: mempty9
        })(xs).acc;
      };
    };
  };
};
var foldableTuple = {
  foldr: function(f) {
    return function(z) {
      return function(v) {
        return f(v.value1)(z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      return function(v) {
        return f(z)(v.value1);
      };
    };
  },
  foldMap: function(dictMonoid) {
    return function(f) {
      return function(v) {
        return f(v.value1);
      };
    };
  }
};
var foldableMaybe = {
  foldr: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldl: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v1)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty9 = mempty(dictMonoid);
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return mempty9;
        }
        ;
        if (v1 instanceof Just) {
          return v(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  }
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append11 = append(dictMonoid.Semigroup0());
    var mempty9 = mempty(dictMonoid);
    return function(f) {
      return foldr22(function(x) {
        return function(acc) {
          return append11(f(x))(acc);
        };
      })(mempty9);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};
var foldMap = function(dict) {
  return dict.foldMap;
};
var lookup = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable)(monoidFirst);
  return function(dictEq) {
    var eq23 = eq(dictEq);
    return function(a) {
      var $460 = foldMap22(function(v) {
        var $444 = eq23(a)(v.value0);
        if ($444) {
          return new Just(v.value1);
        }
        ;
        return Nothing.value;
      });
      return function($461) {
        return unwrap2($460($461));
      };
    };
  };
};
var fold = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable);
  return function(dictMonoid) {
    return foldMap22(dictMonoid)(identity5);
  };
};
var find = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(p) {
    var go = function(v) {
      return function(v1) {
        if (v instanceof Nothing && p(v1)) {
          return new Just(v1);
        }
        ;
        return v;
      };
    };
    return foldl22(go)(Nothing.value);
  };
};
var any = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Disj)(foldMap22(monoidDisj(dictHeytingAlgebra)));
  };
};
var elem = function(dictFoldable) {
  var any1 = any(dictFoldable)(heytingAlgebraBoolean);
  return function(dictEq) {
    var $462 = eq(dictEq);
    return function($463) {
      return any1($462($463));
    };
  };
};
var or = function(dictFoldable) {
  var any1 = any(dictFoldable);
  return function(dictHeytingAlgebra) {
    return any1(dictHeytingAlgebra)(identity5);
  };
};
var all = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Conj)(foldMap22(monoidConj(dictHeytingAlgebra)));
  };
};

// output/Data.Function.Uncurried/foreign.js
var mkFn5 = function(fn) {
  return function(a, b, c, d, e) {
    return fn(a)(b)(c)(d)(e);
  };
};
var runFn2 = function(fn) {
  return function(a) {
    return function(b) {
      return fn(a, b);
    };
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.FunctorWithIndex/foreign.js
var mapWithIndexArray = function(f) {
  return function(xs) {
    var l = xs.length;
    var result = Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(i)(xs[i]);
    }
    return result;
  };
};

// output/Data.FunctorWithIndex/index.js
var mapWithIndex = function(dict) {
  return dict.mapWithIndex;
};
var functorWithIndexArray = {
  mapWithIndex: mapWithIndexArray,
  Functor0: function() {
    return functorArray;
  }
};

// output/Data.Traversable/foreign.js
var traverseArrayImpl = /* @__PURE__ */ function() {
  function array1(a) {
    return [a];
  }
  function array2(a) {
    return function(b) {
      return [a, b];
    };
  }
  function array3(a) {
    return function(b) {
      return function(c) {
        return [a, b, c];
      };
    };
  }
  function concat22(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }
  return function(apply15) {
    return function(map47) {
      return function(pure34) {
        return function(f) {
          return function(array4) {
            function go(bot, top3) {
              switch (top3 - bot) {
                case 0:
                  return pure34([]);
                case 1:
                  return map47(array1)(f(array4[bot]));
                case 2:
                  return apply15(map47(array2)(f(array4[bot])))(f(array4[bot + 1]));
                case 3:
                  return apply15(apply15(map47(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                default:
                  var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                  return apply15(map47(concat22)(go(bot, pivot)))(go(pivot, top3));
              }
            }
            return go(0, array4.length);
          };
        };
      };
    };
  };
}();

// output/Data.Traversable/index.js
var identity6 = /* @__PURE__ */ identity(categoryFn);
var traverse = function(dict) {
  return dict.traverse;
};
var traversableTuple = {
  traverse: function(dictApplicative) {
    var map47 = map(dictApplicative.Apply0().Functor0());
    return function(f) {
      return function(v) {
        return map47(Tuple.create(v.value0))(f(v.value1));
      };
    };
  },
  sequence: function(dictApplicative) {
    var map47 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return map47(Tuple.create(v.value0))(v.value1);
    };
  },
  Functor0: function() {
    return functorTuple;
  },
  Foldable1: function() {
    return foldableTuple;
  }
};
var traversableMaybe = {
  traverse: function(dictApplicative) {
    var pure34 = pure(dictApplicative);
    var map47 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return pure34(Nothing.value);
        }
        ;
        if (v1 instanceof Just) {
          return map47(Just.create)(v(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  sequence: function(dictApplicative) {
    var pure34 = pure(dictApplicative);
    var map47 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      if (v instanceof Nothing) {
        return pure34(Nothing.value);
      }
      ;
      if (v instanceof Just) {
        return map47(Just.create)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  },
  Foldable1: function() {
    return foldableMaybe;
  }
};
var sequenceDefault = function(dictTraversable) {
  var traverse23 = traverse(dictTraversable);
  return function(dictApplicative) {
    return traverse23(dictApplicative)(identity6);
  };
};
var traversableArray = {
  traverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
  },
  sequence: function(dictApplicative) {
    return sequenceDefault(traversableArray)(dictApplicative);
  },
  Functor0: function() {
    return functorArray;
  },
  Foldable1: function() {
    return foldableArray;
  }
};
var sequence = function(dict) {
  return dict.sequence;
};
var $$for = function(dictApplicative) {
  return function(dictTraversable) {
    var traverse23 = traverse(dictTraversable)(dictApplicative);
    return function(x) {
      return function(f) {
        return traverse23(f)(x);
      };
    };
  };
};

// output/Data.Unfoldable/foreign.js
var unfoldrArrayImpl = function(isNothing2) {
  return function(fromJust9) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value3 = b;
            while (true) {
              var maybe2 = f(value3);
              if (isNothing2(maybe2)) return result;
              var tuple = fromJust9(maybe2);
              result.push(fst2(tuple));
              value3 = snd2(tuple);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/foreign.js
var unfoldr1ArrayImpl = function(isNothing2) {
  return function(fromJust9) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value3 = b;
            while (true) {
              var tuple = f(value3);
              result.push(fst2(tuple));
              var maybe2 = snd2(tuple);
              if (isNothing2(maybe2)) return result;
              value3 = fromJust9(maybe2);
            }
          };
        };
      };
    };
  };
};

// output/Data.Ord.Min/index.js
var Min = function(x) {
  return x;
};
var semigroupMin = function(dictOrd) {
  var min5 = min(dictOrd);
  return {
    append: function(v) {
      return function(v1) {
        return min5(v)(v1);
      };
    }
  };
};

// output/Data.Semigroup.Foldable/index.js
var ala2 = /* @__PURE__ */ ala()()();
var foldMap1 = function(dict) {
  return dict.foldMap1;
};
var minimum2 = function(dictOrd) {
  var semigroupMin2 = semigroupMin(dictOrd);
  return function(dictFoldable1) {
    return ala2(Min)(foldMap1(dictFoldable1)(semigroupMin2));
  };
};

// output/Data.Unfoldable1/index.js
var fromJust2 = /* @__PURE__ */ fromJust();
var unfoldable1Array = {
  unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
};

// output/Data.Unfoldable/index.js
var fromJust3 = /* @__PURE__ */ fromJust();
var unfoldr = function(dict) {
  return dict.unfoldr;
};
var unfoldableArray = {
  unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
  Unfoldable10: function() {
    return unfoldable1Array;
  }
};

// output/Data.Array/index.js
var $$void3 = /* @__PURE__ */ $$void(functorST);
var apply2 = /* @__PURE__ */ apply(applyMaybe);
var map5 = /* @__PURE__ */ map(functorMaybe);
var map1 = /* @__PURE__ */ map(functorArray);
var map22 = /* @__PURE__ */ map(functorST);
var fromJust4 = /* @__PURE__ */ fromJust();
var when2 = /* @__PURE__ */ when(applicativeST);
var notEq3 = /* @__PURE__ */ notEq(eqOrdering);
var eq12 = /* @__PURE__ */ eq(eqOrdering);
var fold1 = /* @__PURE__ */ fold(foldableArray);
var append2 = /* @__PURE__ */ append(semigroupArray);
var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);
var zip = /* @__PURE__ */ function() {
  return zipWith(Tuple.create);
}();
var unsafeIndex = function() {
  return runFn2(unsafeIndexImpl);
};
var uncons = /* @__PURE__ */ function() {
  return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {
    return function(xs) {
      return new Just({
        head: x,
        tail: xs
      });
    };
  });
}();
var sortBy = function(comp) {
  return runFn3(sortByImpl)(comp)(function(v) {
    if (v instanceof GT) {
      return 1;
    }
    ;
    if (v instanceof EQ) {
      return 0;
    }
    ;
    if (v instanceof LT) {
      return -1 | 0;
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 897, column 38 - line 900, column 11): " + [v.constructor.name]);
  });
};
var sortWith = function(dictOrd) {
  var comparing2 = comparing(dictOrd);
  return function(f) {
    return sortBy(comparing2(f));
  };
};
var sortWith1 = /* @__PURE__ */ sortWith(ordInt);
var sort = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(xs) {
    return sortBy(compare5)(xs);
  };
};
var snoc = function(xs) {
  return function(x) {
    return withArray(push(x))(xs)();
  };
};
var slice = /* @__PURE__ */ runFn3(sliceImpl);
var take = function(n) {
  return function(xs) {
    var $152 = n < 1;
    if ($152) {
      return [];
    }
    ;
    return slice(0)(n)(xs);
  };
};
var singleton2 = function(a) {
  return [a];
};
var replicate = /* @__PURE__ */ runFn2(replicateImpl);
var range2 = /* @__PURE__ */ runFn2(rangeImpl);
var partition = /* @__PURE__ */ runFn2(partitionImpl);
var $$null = function(xs) {
  return length(xs) === 0;
};
var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var init = function(xs) {
  if ($$null(xs)) {
    return Nothing.value;
  }
  ;
  if (otherwise) {
    return new Just(slice(0)(length(xs) - 1 | 0)(xs));
  }
  ;
  throw new Error("Failed pattern match at Data.Array (line 351, column 1 - line 351, column 45): " + [xs.constructor.name]);
};
var index = /* @__PURE__ */ function() {
  return runFn4(indexImpl)(Just.create)(Nothing.value);
}();
var last = function(xs) {
  return index(xs)(length(xs) - 1 | 0);
};
var unsnoc = function(xs) {
  return apply2(map5(function(v) {
    return function(v1) {
      return {
        init: v,
        last: v1
      };
    };
  })(init(xs)))(last(xs));
};
var head = function(xs) {
  return index(xs)(0);
};
var nubBy = function(comp) {
  return function(xs) {
    var indexedAndSorted = sortBy(function(x) {
      return function(y) {
        return comp(snd(x))(snd(y));
      };
    })(mapWithIndex2(Tuple.create)(xs));
    var v = head(indexedAndSorted);
    if (v instanceof Nothing) {
      return [];
    }
    ;
    if (v instanceof Just) {
      return map1(snd)(sortWith1(fst)(function __do() {
        var result = unsafeThaw(singleton2(v.value0))();
        foreach(indexedAndSorted)(function(v1) {
          return function __do2() {
            var lst = map22(/* @__PURE__ */ function() {
              var $183 = function($185) {
                return fromJust4(last($185));
              };
              return function($184) {
                return snd($183($184));
              };
            }())(unsafeFreeze(result))();
            return when2(notEq3(comp(lst)(v1.value1))(EQ.value))($$void3(push(v1)(result)))();
          };
        })();
        return unsafeFreeze(result)();
      }()));
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 1115, column 17 - line 1123, column 28): " + [v.constructor.name]);
  };
};
var nub = function(dictOrd) {
  return nubBy(compare(dictOrd));
};
var groupBy = function(op) {
  return function(xs) {
    return function __do() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function(x) {
        return $$void3(function __do2() {
          var sub1 = newSTArray();
          push(x)(sub1)();
          pushWhile(op(x))(iter)(sub1)();
          var grp = unsafeFreeze(sub1)();
          return push(grp)(result)();
        });
      })();
      return unsafeFreeze(result)();
    }();
  };
};
var groupAllBy = function(cmp) {
  var $186 = groupBy(function(x) {
    return function(y) {
      return eq12(cmp(x)(y))(EQ.value);
    };
  });
  var $187 = sortBy(cmp);
  return function($188) {
    return $186($187($188));
  };
};
var fromFoldable = function(dictFoldable) {
  return runFn2(fromFoldableImpl)(foldr(dictFoldable));
};
var foldr2 = /* @__PURE__ */ foldr(foldableArray);
var foldl2 = /* @__PURE__ */ foldl(foldableArray);
var fold2 = function(dictMonoid) {
  return fold1(dictMonoid);
};
var findMap = /* @__PURE__ */ function() {
  return runFn4(findMapImpl)(Nothing.value)(isJust);
}();
var filter = /* @__PURE__ */ runFn2(filterImpl);
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};
var cons = function(x) {
  return function(xs) {
    return append2([x])(xs);
  };
};
var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
var mapMaybe = function(f) {
  return concatMap(function() {
    var $189 = maybe([])(singleton2);
    return function($190) {
      return $189(f($190));
    };
  }());
};
var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));

// output/Data.FoldableWithIndex/index.js
var foldr8 = /* @__PURE__ */ foldr(foldableArray);
var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var foldl8 = /* @__PURE__ */ foldl(foldableArray);
var foldrWithIndex = function(dict) {
  return dict.foldrWithIndex;
};
var traverseWithIndex_ = function(dictApplicative) {
  var applySecond4 = applySecond(dictApplicative.Apply0());
  var pure34 = pure(dictApplicative);
  return function(dictFoldableWithIndex) {
    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
    return function(f) {
      return foldrWithIndex1(function(i) {
        var $289 = f(i);
        return function($290) {
          return applySecond4($289($290));
        };
      })(pure34(unit));
    };
  };
};
var forWithIndex_ = function(dictApplicative) {
  var traverseWithIndex_1 = traverseWithIndex_(dictApplicative);
  return function(dictFoldableWithIndex) {
    return flip(traverseWithIndex_1(dictFoldableWithIndex));
  };
};
var foldlWithIndex = function(dict) {
  return dict.foldlWithIndex;
};
var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {
  var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
  return function(dictMonoid) {
    var append11 = append(dictMonoid.Semigroup0());
    var mempty9 = mempty(dictMonoid);
    return function(f) {
      return foldrWithIndex1(function(i) {
        return function(x) {
          return function(acc) {
            return append11(f(i)(x))(acc);
          };
        };
      })(mempty9);
    };
  };
};
var foldableWithIndexArray = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $291 = foldr8(function(v) {
        return function(y) {
          return f(v.value0)(v.value1)(y);
        };
      })(z);
      var $292 = mapWithIndex3(Tuple.create);
      return function($293) {
        return $291($292($293));
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $294 = foldl8(function(y) {
        return function(v) {
          return f(v.value0)(y)(v.value1);
        };
      })(z);
      var $295 = mapWithIndex3(Tuple.create);
      return function($296) {
        return $294($295($296));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
  },
  Foldable0: function() {
    return foldableArray;
  }
};

// output/Data.TraversableWithIndex/index.js
var traverseWithIndexDefault = function(dictTraversableWithIndex) {
  var sequence3 = sequence(dictTraversableWithIndex.Traversable2());
  var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());
  return function(dictApplicative) {
    var sequence12 = sequence3(dictApplicative);
    return function(f) {
      var $174 = mapWithIndex4(f);
      return function($175) {
        return sequence12($174($175));
      };
    };
  };
};
var traverseWithIndex = function(dict) {
  return dict.traverseWithIndex;
};
var traversableWithIndexArray = {
  traverseWithIndex: function(dictApplicative) {
    return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
  },
  FunctorWithIndex0: function() {
    return functorWithIndexArray;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexArray;
  },
  Traversable2: function() {
    return traversableArray;
  }
};

// output/Data.Array.NonEmpty.Internal/index.js
var NonEmptyArray = function(x) {
  return x;
};
var traversableNonEmptyArray = traversableArray;

// output/Data.NonEmpty/index.js
var NonEmpty = /* @__PURE__ */ function() {
  function NonEmpty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  NonEmpty2.create = function(value0) {
    return function(value12) {
      return new NonEmpty2(value0, value12);
    };
  };
  return NonEmpty2;
}();
var singleton3 = function(dictPlus) {
  var empty10 = empty(dictPlus);
  return function(a) {
    return new NonEmpty(a, empty10);
  };
};
var functorNonEmpty = function(dictFunctor) {
  var map213 = map(dictFunctor);
  return {
    map: function(f) {
      return function(m) {
        return new NonEmpty(f(m.value0), map213(f)(m.value1));
      };
    }
  };
};
var foldableNonEmpty = function(dictFoldable) {
  var foldMap4 = foldMap(dictFoldable);
  var foldl4 = foldl(dictFoldable);
  var foldr7 = foldr(dictFoldable);
  return {
    foldMap: function(dictMonoid) {
      var append110 = append(dictMonoid.Semigroup0());
      var foldMap14 = foldMap4(dictMonoid);
      return function(f) {
        return function(v) {
          return append110(f(v.value0))(foldMap14(f)(v.value1));
        };
      };
    },
    foldl: function(f) {
      return function(b) {
        return function(v) {
          return foldl4(f)(f(b)(v.value0))(v.value1);
        };
      };
    },
    foldr: function(f) {
      return function(b) {
        return function(v) {
          return f(v.value0)(foldr7(f)(b)(v.value1));
        };
      };
    }
  };
};
var foldable1NonEmpty = function(dictFoldable) {
  var foldl4 = foldl(dictFoldable);
  var foldr7 = foldr(dictFoldable);
  var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);
  return {
    foldMap1: function(dictSemigroup) {
      var append110 = append(dictSemigroup);
      return function(f) {
        return function(v) {
          return foldl4(function(s) {
            return function(a1) {
              return append110(s)(f(a1));
            };
          })(f(v.value0))(v.value1);
        };
      };
    },
    foldr1: function(f) {
      return function(v) {
        return maybe(v.value0)(f(v.value0))(foldr7(function(a1) {
          var $250 = maybe(a1)(f(a1));
          return function($251) {
            return Just.create($250($251));
          };
        })(Nothing.value)(v.value1));
      };
    },
    foldl1: function(f) {
      return function(v) {
        return foldl4(f)(v.value0)(v.value1);
      };
    },
    Foldable0: function() {
      return foldableNonEmpty1;
    }
  };
};

// output/Data.Array.NonEmpty/index.js
var fromJust5 = /* @__PURE__ */ fromJust();
var unsafeFromArray = NonEmptyArray;
var toArray = function(v) {
  return v;
};
var singleton4 = function($110) {
  return unsafeFromArray(singleton2($110));
};
var fromArray = function(xs) {
  if (length(xs) > 0) {
    return new Just(unsafeFromArray(xs));
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): " + [xs.constructor.name]);
};
var fromFoldable2 = function(dictFoldable) {
  var $119 = fromFoldable(dictFoldable);
  return function($120) {
    return fromArray($119($120));
  };
};
var cons$prime = function(x) {
  return function(xs) {
    return unsafeFromArray(cons(x)(xs));
  };
};
var adaptMaybe = function(f) {
  return function($126) {
    return fromJust5(f(toArray($126)));
  };
};
var head2 = /* @__PURE__ */ adaptMaybe(head);
var last2 = /* @__PURE__ */ adaptMaybe(last);
var uncons2 = /* @__PURE__ */ adaptMaybe(uncons);
var adaptAny = function(f) {
  return function($128) {
    return f(toArray($128));
  };
};
var length2 = /* @__PURE__ */ adaptAny(length);

// output/Data.String.Common/foreign.js
var replaceAll = function(s1) {
  return function(s2) {
    return function(s3) {
      return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
    };
  };
};
var split = function(sep3) {
  return function(s) {
    return s.split(sep3);
  };
};
var trim = function(s) {
  return s.trim();
};
var joinWith = function(s) {
  return function(xs) {
    return xs.join(s);
  };
};

// output/Data.String.Common/index.js
var $$null2 = function(s) {
  return s === "";
};

// output/JSON/foreign.js
var coerce3 = (x) => x;
var _null = null;
var fromBoolean = coerce3;
var fromString = coerce3;
var fromJArray = coerce3;
var fromJObject = coerce3;

// output/Data.Int/foreign.js
var fromNumberImpl = function(just) {
  return function(nothing) {
    return function(n) {
      return (n | 0) === n ? just(n) : nothing;
    };
  };
};
var toNumber = function(n) {
  return n;
};
var fromStringAsImpl = function(just) {
  return function(nothing) {
    return function(radix) {
      var digits;
      if (radix < 11) {
        digits = "[0-" + (radix - 1).toString() + "]";
      } else if (radix === 11) {
        digits = "[0-9a]";
      } else {
        digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
      }
      var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");
      return function(s) {
        if (pattern.test(s)) {
          var i = parseInt(s, radix);
          return (i | 0) === i ? just(i) : nothing;
        } else {
          return nothing;
        }
      };
    };
  };
};

// output/Data.Number/foreign.js
var isFiniteImpl = isFinite;
function fromStringImpl(str2, isFinite2, just, nothing) {
  var num = parseFloat(str2);
  if (isFinite2(num)) {
    return just(num);
  } else {
    return nothing;
  }
}
var floor = Math.floor;
var round = Math.round;

// output/Data.Number/index.js
var fromString2 = function(str2) {
  return fromStringImpl(str2, isFiniteImpl, Just.create, Nothing.value);
};

// output/Data.Int/index.js
var top2 = /* @__PURE__ */ top(boundedInt);
var bottom2 = /* @__PURE__ */ bottom(boundedInt);
var hexadecimal = 16;
var fromStringAs = /* @__PURE__ */ function() {
  return fromStringAsImpl(Just.create)(Nothing.value);
}();
var fromString3 = /* @__PURE__ */ fromStringAs(10);
var fromNumber = /* @__PURE__ */ function() {
  return fromNumberImpl(Just.create)(Nothing.value);
}();
var unsafeClamp = function(x) {
  if (!isFiniteImpl(x)) {
    return 0;
  }
  ;
  if (x >= toNumber(top2)) {
    return top2;
  }
  ;
  if (x <= toNumber(bottom2)) {
    return bottom2;
  }
  ;
  if (otherwise) {
    return fromMaybe(0)(fromNumber(x));
  }
  ;
  throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
};
var round2 = function($37) {
  return unsafeClamp(round($37));
};
var floor2 = function($39) {
  return unsafeClamp(floor($39));
};

// output/JSON.Internal/foreign.js
var toString = Object.prototype.toString;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var _case = (isNull3, isBool, isNum, isStr, isArr, isObj, j) => {
  if (j == null) return isNull3(null);
  const ty = typeof j;
  if (ty === "boolean") return isBool(j);
  if (ty === "number") return isNum(j);
  if (ty === "string") return isStr(j);
  if (toString.call(j) === "[object Array]") return isArr(j);
  return isObj(j);
};
var toArray2 = (js) => js;
var fromArray2 = (js) => js;
var _fromEntries = (fst2, snd2, entries2) => {
  const result = {};
  for (var i = 0; i < entries2.length; i++) {
    result[fst2(entries2[i])] = snd2(entries2[i]);
  }
  return result;
};
var _entries = (tuple, obj) => Object.entries(obj).map(([k, v]) => tuple(k)(v));
var _lookup = (nothing, just, key, obj) => hasOwnProperty2.call(obj, key) ? just(obj[key]) : nothing;
var isNull = (json2) => json2 == null;

// output/JSON/index.js
var $$null3 = _null;
var fromArray3 = function(js) {
  return fromJArray(fromArray2(js));
};
var fail = function(v) {
  return Nothing.value;
};
var toBoolean = function(json2) {
  return _case(fail, Just.create, fail, fail, fail, fail, json2);
};
var toJArray = function(json2) {
  return _case(fail, fail, fail, fail, Just.create, fail, json2);
};
var toJObject = function(json2) {
  return _case(fail, fail, fail, fail, fail, Just.create, json2);
};
var toString2 = function(json2) {
  return _case(fail, fail, fail, Just.create, fail, fail, json2);
};

// output/JSON.Object/index.js
var lookup2 = function(k) {
  return function(obj) {
    return _lookup(Nothing.value, Just.create, k, obj);
  };
};
var keys = function(obj) {
  return _entries(function(k) {
    return function(v) {
      return k;
    };
  }, obj);
};
var fromEntries = function(kvs) {
  return _fromEntries(fst, snd, kvs);
};
var fromFoldable3 = function(dictFoldable) {
  var fromFoldable110 = fromFoldable(dictFoldable);
  return function(kvs) {
    return fromEntries(fromFoldable110(kvs));
  };
};
var fromFoldableWithIndex = function(dictFoldableWithIndex) {
  var foldrWithIndex2 = foldrWithIndex(dictFoldableWithIndex);
  return function(kvs) {
    return fromEntries(foldrWithIndex2(function(k) {
      return function(v) {
        return cons(new Tuple(k, v));
      };
    })([])(kvs));
  };
};
var entries = function(obj) {
  return _entries(Tuple.create, obj);
};

// output/JSON.Path/index.js
var show1 = /* @__PURE__ */ show(showInt);
var Tip = /* @__PURE__ */ function() {
  function Tip2() {
  }
  ;
  Tip2.value = new Tip2();
  return Tip2;
}();
var AtKey = /* @__PURE__ */ function() {
  function AtKey2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtKey2.create = function(value0) {
    return function(value12) {
      return new AtKey2(value0, value12);
    };
  };
  return AtKey2;
}();
var AtIndex = /* @__PURE__ */ function() {
  function AtIndex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtIndex2.create = function(value0) {
    return function(value12) {
      return new AtIndex2(value0, value12);
    };
  };
  return AtIndex2;
}();
var eqPath = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Tip && y instanceof Tip) {
        return true;
      }
      ;
      if (x instanceof AtKey && y instanceof AtKey) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      if (x instanceof AtIndex && y instanceof AtIndex) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      return false;
    };
  }
};
var stripPrefix = function($copy_v) {
  return function($copy_v1) {
    var $tco_var_v = $copy_v;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v, v1) {
      if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof Tip) {
        $tco_done = true;
        return new Just(v1);
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_v, $copy_v1);
    }
    ;
    return $tco_result;
  };
};
var print2 = function(path3) {
  var go = function(p) {
    if (p instanceof Tip) {
      return "";
    }
    ;
    if (p instanceof AtKey) {
      return "." + (p.value0 + go(p.value1));
    }
    ;
    if (p instanceof AtIndex) {
      return "[" + (show1(p.value0) + ("]" + go(p.value1)));
    }
    ;
    throw new Error("Failed pattern match at JSON.Path (line 41, column 10 - line 44, column 56): " + [p.constructor.name]);
  };
  return "$" + go(path3);
};
var findCommonPrefix = function(v) {
  return function(v1) {
    if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
      return new AtKey(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
      return new AtIndex(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    return Tip.value;
  };
};

// output/Codec.JSON.DecodeError/index.js
var append1 = /* @__PURE__ */ append(semigroupArray);
var eq13 = /* @__PURE__ */ eq(eqPath);
var over2 = /* @__PURE__ */ over()();
var map6 = /* @__PURE__ */ map(functorArray);
var DecodeError = function(x) {
  return x;
};
var semigroupDecodeError = {
  append: function(v) {
    return function(v1) {
      return {
        path: findCommonPrefix(v.path)(v1.path),
        message: "Failed to decode alternatives",
        causes: append1(function() {
          var $50 = v.message === "Failed to decode alternatives";
          if ($50) {
            return v.causes;
          }
          ;
          return [v];
        }())(function() {
          var $51 = v1.message === "Failed to decode alternatives";
          if ($51) {
            return v1.causes;
          }
          ;
          return [v1];
        }())
      };
    };
  }
};
var withPath = function(f) {
  return over2(DecodeError)(function(err) {
    return {
      message: err.message,
      path: f(err.path),
      causes: map6(withPath(f))(err.causes)
    };
  });
};
var withContext = function(message2) {
  return over2(DecodeError)(function(err) {
    return {
      path: err.path,
      message: message2,
      causes: [err]
    };
  });
};
var print3 = function(v) {
  var pathPart = function() {
    var $61 = eq13(v.path)(Tip.value);
    if ($61) {
      return "";
    }
    ;
    return print2(v.path) + ": ";
  }();
  var causes = map6(function(e) {
    return replaceAll("\n")(function() {
      var $62 = length(v.causes) === 1;
      if ($62) {
        return "\n  ";
      }
      ;
      return "\n    ";
    }())(print3(withPath(function(p) {
      return fromMaybe(p)(stripPrefix(v.path)(p));
    })(e)));
  })(v.causes);
  var details = function() {
    var v1 = length(v.causes);
    if (v1 === 0) {
      return "";
    }
    ;
    if (v1 === 1) {
      return ":\n  " + joinWith("\n  ")(causes);
    }
    ;
    return ":\n  - " + joinWith("\n  - ")(causes);
  }();
  return pathPart + (v.message + details);
};
var error = function(path3) {
  return function(message2) {
    return {
      path: path3,
      message: message2,
      causes: []
    };
  };
};
var noValueFound = function(path3) {
  return error(path3)("No value found");
};
var basic = /* @__PURE__ */ function() {
  return error(Tip.value);
}();

// output/Effect.Exception/foreign.js
function error2(msg) {
  return new Error(msg);
}
function message(e) {
  return e.message;
}
function throwException(e) {
  return function() {
    throw e;
  };
}
function catchException(c) {
  return function(t) {
    return function() {
      try {
        return t();
      } catch (e) {
        if (e instanceof Error || Object.prototype.toString.call(e) === "[object Error]") {
          return c(e)();
        } else {
          return c(new Error(e.toString()))();
        }
      }
    };
  };
}

// output/Control.Monad.Error.Class/index.js
var throwError = function(dict) {
  return dict.throwError;
};
var monadThrowEffect = {
  throwError: throwException,
  Monad0: function() {
    return monadEffect;
  }
};
var monadErrorEffect = {
  catchError: /* @__PURE__ */ flip(catchException),
  MonadThrow0: function() {
    return monadThrowEffect;
  }
};
var catchError = function(dict) {
  return dict.catchError;
};
var $$try = function(dictMonadError) {
  var catchError1 = catchError(dictMonadError);
  var Monad0 = dictMonadError.MonadThrow0().Monad0();
  var map47 = map(Monad0.Bind1().Apply0().Functor0());
  var pure34 = pure(Monad0.Applicative0());
  return function(a) {
    return catchError1(map47(Right.create)(a))(function($52) {
      return pure34(Left.create($52));
    });
  };
};

// output/Control.Monad.Reader.Class/index.js
var ask = function(dict) {
  return dict.ask;
};

// output/Control.Monad.State.Class/index.js
var state = function(dict) {
  return dict.state;
};
var put = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(s) {
    return state1(function(v) {
      return new Tuple(unit, s);
    });
  };
};
var modify_ = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(f) {
    return state1(function(s) {
      return new Tuple(unit, f(s));
    });
  };
};
var get = function(dictMonadState) {
  return state(dictMonadState)(function(s) {
    return new Tuple(s, s);
  });
};

// output/Control.Monad.Trans.Class/index.js
var lift = function(dict) {
  return dict.lift;
};

// output/Control.Monad.Writer.Class/index.js
var tell = function(dict) {
  return dict.tell;
};

// output/Effect.Class/index.js
var liftEffect = function(dict) {
  return dict.liftEffect;
};

// output/Control.Monad.Except.Trans/index.js
var map7 = /* @__PURE__ */ map(functorEither);
var ExceptT = function(x) {
  return x;
};
var withExceptT = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return function(f) {
    return function(v) {
      var mapLeft = function(v1) {
        return function(v2) {
          if (v2 instanceof Right) {
            return new Right(v2.value0);
          }
          ;
          if (v2 instanceof Left) {
            return new Left(v1(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 43, column 3 - line 43, column 32): " + [v1.constructor.name, v2.constructor.name]);
        };
      };
      return map117(mapLeft(f))(v);
    };
  };
};
var runExceptT = function(v) {
  return v;
};
var monadTransExceptT = {
  lift: function(dictMonad) {
    var bind30 = bind(dictMonad.Bind1());
    var pure34 = pure(dictMonad.Applicative0());
    return function(m) {
      return bind30(m)(function(a) {
        return pure34(new Right(a));
      });
    };
  }
};
var mapExceptT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorExceptT = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return {
    map: function(f) {
      return mapExceptT(map117(map7(f)));
    }
  };
};
var except = function(dictApplicative) {
  var $191 = pure(dictApplicative);
  return function($192) {
    return ExceptT($191($192));
  };
};
var monadExceptT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeExceptT(dictMonad);
    },
    Bind1: function() {
      return bindExceptT(dictMonad);
    }
  };
};
var bindExceptT = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure34 = pure(dictMonad.Applicative0());
  return {
    bind: function(v) {
      return function(k) {
        return bind30(v)(either(function($193) {
          return pure34(Left.create($193));
        })(function(a) {
          var v1 = k(a);
          return v1;
        }));
      };
    },
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var applyExceptT = function(dictMonad) {
  var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadExceptT(dictMonad)),
    Functor0: function() {
      return functorExceptT1;
    }
  };
};
var applicativeExceptT = function(dictMonad) {
  return {
    pure: function() {
      var $194 = pure(dictMonad.Applicative0());
      return function($195) {
        return ExceptT($194(Right.create($195)));
      };
    }(),
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var monadThrowExceptT = function(dictMonad) {
  var monadExceptT1 = monadExceptT(dictMonad);
  return {
    throwError: function() {
      var $204 = pure(dictMonad.Applicative0());
      return function($205) {
        return ExceptT($204(Left.create($205)));
      };
    }(),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var altExceptT = function(dictSemigroup) {
  var append11 = append(dictSemigroup);
  return function(dictMonad) {
    var Bind1 = dictMonad.Bind1();
    var bind30 = bind(Bind1);
    var pure34 = pure(dictMonad.Applicative0());
    var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
    return {
      alt: function(v) {
        return function(v1) {
          return bind30(v)(function(rm) {
            if (rm instanceof Right) {
              return pure34(new Right(rm.value0));
            }
            ;
            if (rm instanceof Left) {
              return bind30(v1)(function(rn) {
                if (rn instanceof Right) {
                  return pure34(new Right(rn.value0));
                }
                ;
                if (rn instanceof Left) {
                  return pure34(new Left(append11(rm.value0)(rn.value0)));
                }
                ;
                throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 87, column 9 - line 89, column 49): " + [rn.constructor.name]);
              });
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 83, column 5 - line 89, column 49): " + [rm.constructor.name]);
          });
        };
      },
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
};

// output/Control.Monad.Except/index.js
var unwrap3 = /* @__PURE__ */ unwrap();
var withExcept = /* @__PURE__ */ withExceptT(functorIdentity);
var runExcept = function($3) {
  return unwrap3(runExceptT($3));
};

// output/Data.Codec/index.js
var map8 = /* @__PURE__ */ map(functorTuple);
var Codec = /* @__PURE__ */ function() {
  function Codec2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Codec2.create = function(value0) {
    return function(value12) {
      return new Codec2(value0, value12);
    };
  };
  return Codec2;
}();
var profunctorCodec = function(dictFunctor) {
  var map117 = map(dictFunctor);
  return {
    dimap: function(f) {
      return function(g) {
        return function(v) {
          return new Codec(function() {
            var $91 = map117(g);
            return function($92) {
              return $91(v.value0($92));
            };
          }(), function() {
            var $93 = map8(g);
            return function($94) {
              return $93(v.value1(f($94)));
            };
          }());
        };
      };
    }
  };
};
var encode = function(v) {
  return function($100) {
    return fst(v.value1($100));
  };
};
var decode = function(v) {
  return v.value0;
};
var codec$prime = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};
var codec = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};

// output/Data.List.Types/index.js
var Nil = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var NonEmptyList = function(x) {
  return x;
};
var toList = function(v) {
  return new Cons(v.value0, v.value1);
};
var listMap = function(f) {
  var chunkedRevMap = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {
          $tco_var_v = new Cons(v1, v);
          $copy_v1 = v1.value1.value1.value1;
          return;
        }
        ;
        var unrolledMap = function(v2) {
          if (v2 instanceof Cons && (v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil)) {
            return new Cons(f(v2.value0), new Cons(f(v2.value1.value0), Nil.value));
          }
          ;
          if (v2 instanceof Cons && v2.value1 instanceof Nil) {
            return new Cons(f(v2.value0), Nil.value);
          }
          ;
          return Nil.value;
        };
        var reverseUnrolledMap = function($copy_v2) {
          return function($copy_v3) {
            var $tco_var_v2 = $copy_v2;
            var $tco_done1 = false;
            var $tco_result2;
            function $tco_loop2(v2, v3) {
              if (v2 instanceof Cons && (v2.value0 instanceof Cons && (v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons))) {
                $tco_var_v2 = v2.value1;
                $copy_v3 = new Cons(f(v2.value0.value0), new Cons(f(v2.value0.value1.value0), new Cons(f(v2.value0.value1.value1.value0), v3)));
                return;
              }
              ;
              $tco_done1 = true;
              return v3;
            }
            ;
            while (!$tco_done1) {
              $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);
            }
            ;
            return $tco_result2;
          };
        };
        $tco_done = true;
        return reverseUnrolledMap(v)(unrolledMap(v1));
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return chunkedRevMap(Nil.value);
};
var functorList = {
  map: listMap
};
var map9 = /* @__PURE__ */ map(functorList);
var functorNonEmptyList = /* @__PURE__ */ functorNonEmpty(functorList);
var foldableList = {
  foldr: function(f) {
    return function(b) {
      var rev = function() {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 instanceof Nil) {
                $tco_done = true;
                return v;
              }
              ;
              if (v1 instanceof Cons) {
                $tco_var_v = new Cons(v1.value0, v);
                $copy_v1 = v1.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(Nil.value);
      }();
      var $284 = foldl(foldableList)(flip(f))(b);
      return function($285) {
        return $284(rev($285));
      };
    };
  },
  foldl: function(f) {
    var go = function($copy_b) {
      return function($copy_v) {
        var $tco_var_b = $copy_b;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(b, v) {
          if (v instanceof Nil) {
            $tco_done1 = true;
            return b;
          }
          ;
          if (v instanceof Cons) {
            $tco_var_b = f(b)(v.value0);
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_b, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append22 = append(dictMonoid.Semigroup0());
    var mempty9 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList)(function(acc) {
        var $286 = append22(acc);
        return function($287) {
          return $286(f($287));
        };
      })(mempty9);
    };
  }
};
var foldr3 = /* @__PURE__ */ foldr(foldableList);
var foldableNonEmptyList = /* @__PURE__ */ foldableNonEmpty(foldableList);
var semigroupList = {
  append: function(xs) {
    return function(ys) {
      return foldr3(Cons.create)(ys)(xs);
    };
  }
};
var append12 = /* @__PURE__ */ append(semigroupList);
var monoidList = /* @__PURE__ */ function() {
  return {
    mempty: Nil.value,
    Semigroup0: function() {
      return semigroupList;
    }
  };
}();
var semigroupNonEmptyList = {
  append: function(v) {
    return function(as$prime) {
      return new NonEmpty(v.value0, append12(v.value1)(toList(as$prime)));
    };
  }
};
var applyList = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Nil) {
        return Nil.value;
      }
      ;
      if (v instanceof Cons) {
        return append12(map9(v.value0)(v1))(apply(applyList)(v.value1)(v1));
      }
      ;
      throw new Error("Failed pattern match at Data.List.Types (line 157, column 1 - line 159, column 48): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorList;
  }
};
var apply3 = /* @__PURE__ */ apply(applyList);
var applyNonEmptyList = {
  apply: function(v) {
    return function(v1) {
      return new NonEmpty(v.value0(v1.value0), append12(apply3(v.value1)(new Cons(v1.value0, Nil.value)))(apply3(new Cons(v.value0, v.value1))(v1.value1)));
    };
  },
  Functor0: function() {
    return functorNonEmptyList;
  }
};
var altList = {
  alt: append12,
  Functor0: function() {
    return functorList;
  }
};
var plusList = /* @__PURE__ */ function() {
  return {
    empty: Nil.value,
    Alt0: function() {
      return altList;
    }
  };
}();
var applicativeNonEmptyList = {
  pure: /* @__PURE__ */ function() {
    var $315 = singleton3(plusList);
    return function($316) {
      return NonEmptyList($315($316));
    };
  }(),
  Apply0: function() {
    return applyNonEmptyList;
  }
};

// output/Data.String.CodePoints/foreign.js
var hasArrayFrom = typeof Array.from === "function";
var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
var hasCodePointAt = typeof String.prototype.codePointAt === "function";
var _unsafeCodePointAt0 = function(fallback) {
  return hasCodePointAt ? function(str2) {
    return str2.codePointAt(0);
  } : fallback;
};
var _codePointAt = function(fallback) {
  return function(Just2) {
    return function(Nothing2) {
      return function(unsafeCodePointAt02) {
        return function(index5) {
          return function(str2) {
            var length9 = str2.length;
            if (index5 < 0 || index5 >= length9) return Nothing2;
            if (hasStringIterator) {
              var iter = str2[Symbol.iterator]();
              for (var i = index5; ; --i) {
                var o = iter.next();
                if (o.done) return Nothing2;
                if (i === 0) return Just2(unsafeCodePointAt02(o.value));
              }
            }
            return fallback(index5)(str2);
          };
        };
      };
    };
  };
};
var _singleton = function(fallback) {
  return hasFromCodePoint ? String.fromCodePoint : fallback;
};
var _take = function(fallback) {
  return function(n) {
    if (hasStringIterator) {
      return function(str2) {
        var accum = "";
        var iter = str2[Symbol.iterator]();
        for (var i = 0; i < n; ++i) {
          var o = iter.next();
          if (o.done) return accum;
          accum += o.value;
        }
        return accum;
      };
    }
    return fallback(n);
  };
};
var _toCodePointArray = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasArrayFrom) {
      return function(str2) {
        return Array.from(str2, unsafeCodePointAt02);
      };
    }
    return fallback;
  };
};

// output/Data.Enum/foreign.js
function toCharCode(c) {
  return c.charCodeAt(0);
}
function fromCharCode(c) {
  return String.fromCharCode(c);
}

// output/Control.Alternative/index.js
var guard = function(dictAlternative) {
  var pure34 = pure(dictAlternative.Applicative0());
  var empty10 = empty(dictAlternative.Plus1());
  return function(v) {
    if (v) {
      return pure34(unit);
    }
    ;
    if (!v) {
      return empty10;
    }
    ;
    throw new Error("Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): " + [v.constructor.name]);
  };
};
var alternativeArray = {
  Applicative0: function() {
    return applicativeArray;
  },
  Plus1: function() {
    return plusArray;
  }
};

// output/Data.Enum/index.js
var bottom1 = /* @__PURE__ */ bottom(boundedChar);
var top1 = /* @__PURE__ */ top(boundedChar);
var toEnum = function(dict) {
  return dict.toEnum;
};
var fromEnum = function(dict) {
  return dict.fromEnum;
};
var toEnumWithDefaults = function(dictBoundedEnum) {
  var toEnum1 = toEnum(dictBoundedEnum);
  var fromEnum12 = fromEnum(dictBoundedEnum);
  var bottom22 = bottom(dictBoundedEnum.Bounded0());
  return function(low) {
    return function(high) {
      return function(x) {
        var v = toEnum1(x);
        if (v instanceof Just) {
          return v.value0;
        }
        ;
        if (v instanceof Nothing) {
          var $140 = x < fromEnum12(bottom22);
          if ($140) {
            return low;
          }
          ;
          return high;
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v.constructor.name]);
      };
    };
  };
};
var defaultSucc = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) + 1 | 0);
    };
  };
};
var defaultPred = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) - 1 | 0);
    };
  };
};
var charToEnum = function(v) {
  if (v >= toCharCode(bottom1) && v <= toCharCode(top1)) {
    return new Just(fromCharCode(v));
  }
  ;
  return Nothing.value;
};
var enumChar = {
  succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
  pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
  Ord0: function() {
    return ordChar;
  }
};
var boundedEnumChar = /* @__PURE__ */ function() {
  return {
    cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
    toEnum: charToEnum,
    fromEnum: toCharCode,
    Bounded0: function() {
      return boundedChar;
    },
    Enum1: function() {
      return enumChar;
    }
  };
}();

// output/Data.String.CodeUnits/foreign.js
var fromCharArray = function(a) {
  return a.join("");
};
var toCharArray = function(s) {
  return s.split("");
};
var singleton6 = function(c) {
  return c;
};
var _charAt = function(just) {
  return function(nothing) {
    return function(i) {
      return function(s) {
        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
      };
    };
  };
};
var length4 = function(s) {
  return s.length;
};
var _indexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.indexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var _indexOfStartingAt = function(just) {
  return function(nothing) {
    return function(x) {
      return function(startAt) {
        return function(s) {
          if (startAt < 0 || startAt > s.length) return nothing;
          var i = s.indexOf(x, startAt);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };
};
var _lastIndexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.lastIndexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var take2 = function(n) {
  return function(s) {
    return s.substr(0, n);
  };
};
var drop2 = function(n) {
  return function(s) {
    return s.substring(n);
  };
};
var splitAt2 = function(i) {
  return function(s) {
    return { before: s.substring(0, i), after: s.substring(i) };
  };
};

// output/Data.String.Unsafe/foreign.js
var charAt = function(i) {
  return function(s) {
    if (i >= 0 && i < s.length) return s.charAt(i);
    throw new Error("Data.String.Unsafe.charAt: Invalid index.");
  };
};

// output/Data.String.CodeUnits/index.js
var stripPrefix2 = function(v) {
  return function(str2) {
    var v1 = splitAt2(length4(v))(str2);
    var $20 = v1.before === v;
    if ($20) {
      return new Just(v1.after);
    }
    ;
    return Nothing.value;
  };
};
var lastIndexOf = /* @__PURE__ */ function() {
  return _lastIndexOf(Just.create)(Nothing.value);
}();
var indexOf$prime = /* @__PURE__ */ function() {
  return _indexOfStartingAt(Just.create)(Nothing.value);
}();
var indexOf = /* @__PURE__ */ function() {
  return _indexOf(Just.create)(Nothing.value);
}();
var dropRight = function(i) {
  return function(s) {
    return take2(length4(s) - i | 0)(s);
  };
};
var charAt2 = /* @__PURE__ */ function() {
  return _charAt(Just.create)(Nothing.value);
}();

// output/Data.String.CodePoints/index.js
var $runtime_lazy3 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var map10 = /* @__PURE__ */ map(functorMaybe);
var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
var div2 = /* @__PURE__ */ div(euclideanRingInt);
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var compare2 = /* @__PURE__ */ compare(ordInt);
var CodePoint = function(x) {
  return x;
};
var unsurrogate = function(lead) {
  return function(trail) {
    return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
  };
};
var isTrail = function(cu) {
  return 56320 <= cu && cu <= 57343;
};
var isLead = function(cu) {
  return 55296 <= cu && cu <= 56319;
};
var uncons3 = function(s) {
  var v = length4(s);
  if (v === 0) {
    return Nothing.value;
  }
  ;
  if (v === 1) {
    return new Just({
      head: fromEnum2(charAt(0)(s)),
      tail: ""
    });
  }
  ;
  var cu1 = fromEnum2(charAt(1)(s));
  var cu0 = fromEnum2(charAt(0)(s));
  var $43 = isLead(cu0) && isTrail(cu1);
  if ($43) {
    return new Just({
      head: unsurrogate(cu0)(cu1),
      tail: drop2(2)(s)
    });
  }
  ;
  return new Just({
    head: cu0,
    tail: drop2(1)(s)
  });
};
var unconsButWithTuple = function(s) {
  return map10(function(v) {
    return new Tuple(v.head, v.tail);
  })(uncons3(s));
};
var toCodePointArrayFallback = function(s) {
  return unfoldr2(unconsButWithTuple)(s);
};
var unsafeCodePointAt0Fallback = function(s) {
  var cu0 = fromEnum2(charAt(0)(s));
  var $47 = isLead(cu0) && length4(s) > 1;
  if ($47) {
    var cu1 = fromEnum2(charAt(1)(s));
    var $48 = isTrail(cu1);
    if ($48) {
      return unsurrogate(cu0)(cu1);
    }
    ;
    return cu0;
  }
  ;
  return cu0;
};
var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
var length5 = function($74) {
  return length(toCodePointArray($74));
};
var lastIndexOf2 = function(p) {
  return function(s) {
    return map10(function(i) {
      return length5(take2(i)(s));
    })(lastIndexOf(p)(s));
  };
};
var indexOf2 = function(p) {
  return function(s) {
    return map10(function(i) {
      return length5(take2(i)(s));
    })(indexOf(p)(s));
  };
};
var fromCharCode2 = /* @__PURE__ */ function() {
  var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
  return function($76) {
    return singleton6($75($76));
  };
}();
var singletonFallback = function(v) {
  if (v <= 65535) {
    return fromCharCode2(v);
  }
  ;
  var lead = div2(v - 65536 | 0)(1024) + 55296 | 0;
  var trail = mod2(v - 65536 | 0)(1024) + 56320 | 0;
  return fromCharCode2(lead) + fromCharCode2(trail);
};
var singleton7 = /* @__PURE__ */ _singleton(singletonFallback);
var takeFallback = function(v) {
  return function(v1) {
    if (v < 1) {
      return "";
    }
    ;
    var v2 = uncons3(v1);
    if (v2 instanceof Just) {
      return singleton7(v2.value0.head) + takeFallback(v - 1 | 0)(v2.value0.tail);
    }
    ;
    return v1;
  };
};
var take3 = /* @__PURE__ */ _take(takeFallback);
var eqCodePoint = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordCodePoint = {
  compare: function(x) {
    return function(y) {
      return compare2(x)(y);
    };
  },
  Eq0: function() {
    return eqCodePoint;
  }
};
var drop3 = function(n) {
  return function(s) {
    return drop2(length4(take3(n)(s)))(s);
  };
};
var codePointFromChar = function($77) {
  return CodePoint(fromEnum2($77));
};
var codePointAtFallback = function($copy_n) {
  return function($copy_s) {
    var $tco_var_n = $copy_n;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(n, s) {
      var v = uncons3(s);
      if (v instanceof Just) {
        var $66 = n === 0;
        if ($66) {
          $tco_done = true;
          return new Just(v.value0.head);
        }
        ;
        $tco_var_n = n - 1 | 0;
        $copy_s = v.value0.tail;
        return;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_n, $copy_s);
    }
    ;
    return $tco_result;
  };
};
var codePointAt = function(v) {
  return function(v1) {
    if (v < 0) {
      return Nothing.value;
    }
    ;
    if (v === 0 && v1 === "") {
      return Nothing.value;
    }
    ;
    if (v === 0) {
      return new Just(unsafeCodePointAt0(v1));
    }
    ;
    return _codePointAt(codePointAtFallback)(Just.create)(Nothing.value)(unsafeCodePointAt0)(v)(v1);
  };
};
var boundedCodePoint = {
  bottom: 0,
  top: 1114111,
  Ord0: function() {
    return ordCodePoint;
  }
};
var boundedEnumCodePoint = /* @__PURE__ */ function() {
  return {
    cardinality: 1114111 + 1 | 0,
    fromEnum: function(v) {
      return v;
    },
    toEnum: function(n) {
      if (n >= 0 && n <= 1114111) {
        return new Just(n);
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.String.CodePoints (line 63, column 1 - line 68, column 26): " + [n.constructor.name]);
    },
    Bounded0: function() {
      return boundedCodePoint;
    },
    Enum1: function() {
      return $lazy_enumCodePoint(0);
    }
  };
}();
var $lazy_enumCodePoint = /* @__PURE__ */ $runtime_lazy3("enumCodePoint", "Data.String.CodePoints", function() {
  return {
    succ: defaultSucc(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    pred: defaultPred(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    Ord0: function() {
      return ordCodePoint;
    }
  };
});

// output/Data.Codec.JSON/index.js
var applicativeExceptT2 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var pure2 = /* @__PURE__ */ pure(applicativeExceptT2);
var except2 = /* @__PURE__ */ except(applicativeIdentity);
var bindExceptT2 = /* @__PURE__ */ bindExceptT(monadIdentity);
var bindFlipped1 = /* @__PURE__ */ bindFlipped(bindExceptT2);
var fromFoldable1 = /* @__PURE__ */ fromFoldable3(foldableList);
var bind2 = /* @__PURE__ */ bind(bindExceptT2);
var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeExceptT2);
var map12 = /* @__PURE__ */ map(functorArray);
var record = /* @__PURE__ */ function() {
  return new Codec($$const(pure2({})), pure(applicativeTuple(monoidList)));
}();
var jsonPrimCodec = function(ty) {
  return function(f) {
    return codec$prime(function(j) {
      return except2(function() {
        var v = f(j);
        if (v instanceof Just) {
          return new Right(v.value0);
        }
        ;
        if (v instanceof Nothing) {
          return new Left({
            path: Tip.value,
            message: "Expected value of type " + ty,
            causes: []
          });
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 81, column 12 - line 89, column 10): " + [v.constructor.name]);
      }());
    });
  };
};
var string = /* @__PURE__ */ jsonPrimCodec("String")(toString2)(fromString);
var json = /* @__PURE__ */ codec$prime(pure2)(/* @__PURE__ */ identity(categoryFn));
var jobject = /* @__PURE__ */ jsonPrimCodec("Object")(toJObject)(fromJObject);
var jarray = /* @__PURE__ */ jsonPrimCodec("Array")(toJArray)(fromJArray);
var encode2 = encode;
var object = function(codec4) {
  return codec$prime(function(j) {
    return bindFlipped1(decode(codec4))(decode(jobject)(j));
  })(function(a) {
    return encode2(jobject)(fromFoldable1(encode2(codec4)(a)));
  });
};
var decode2 = function(codec4) {
  return function(j) {
    return runExcept(decode(codec4)(j));
  };
};
var prismaticCodec = function(name3) {
  return function(f) {
    return function(g) {
      return function(codec4) {
        return codec$prime(function(j) {
          return except2(function() {
            var v = decode2(codec4)(j);
            if (v instanceof Left) {
              return new Left(withContext("Could not decode " + name3)(v.value0));
            }
            ;
            if (v instanceof Right) {
              var v1 = f(v.value0);
              if (v1 instanceof Just) {
                return new Right(v1.value0);
              }
              ;
              if (v1 instanceof Nothing) {
                return new Left(basic("Could not decode " + (name3 + ", unexpected value found")));
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON (line 424, column 13 - line 428, column 95): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Data.Codec.JSON (line 420, column 18 - line 428, column 95): " + [v.constructor.name]);
          }());
        })(function(b) {
          return encode2(codec4)(g(b));
        });
      };
    };
  };
};
var recordProp = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var enc$prime = function(key2) {
          return function(val) {
            return new Cons(new Tuple(key2, encode(codecA)(unsafeGet(key2)(val))), encode(codecR)(val));
          };
        };
        var dec$prime = function(key2) {
          return function(obj) {
            return bind2(decode(codecR)(obj))(function(r) {
              return bind2(except2(function() {
                var v = lookup2(key2)(obj);
                if (v instanceof Just) {
                  var v1 = decode2(codecA)(v.value0);
                  if (v1 instanceof Left) {
                    return new Left(withPath(AtKey.create(key2))(v1.value0));
                  }
                  ;
                  return v1;
                }
                ;
                if (v instanceof Nothing) {
                  return new Left(noValueFound(new AtKey(key2, Tip.value)));
                }
                ;
                throw new Error("Failed pattern match at Data.Codec.JSON (line 279, column 16 - line 285, column 56): " + [v.constructor.name]);
              }()))(function(a) {
                return pure2(unsafeSet(key2)(a)(r));
              });
            });
          };
        };
        var key = reflectSymbol2($$Proxy.value);
        return codec(dec$prime(key))(enc$prime(key));
      };
    };
  };
};
var $$boolean = /* @__PURE__ */ jsonPrimCodec("Boolean")(toBoolean)(fromBoolean);
var array = function(codec4) {
  return codec$prime(function(j) {
    return bind2(decode(jarray)(j))(function(arr) {
      return traverseWithIndex2(function(ix) {
        return function(a) {
          return except2(function() {
            var v = decode2(codec4)(a);
            if (v instanceof Left) {
              return new Left(withPath(AtIndex.create(ix))(v.value0));
            }
            ;
            return v;
          }());
        };
      })(toArray2(arr));
    });
  })(function(a) {
    return fromArray3(map12(encode2(codec4))(a));
  });
};

// output/PureScript.CST.Types/index.js
var ASCII = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var Unicode = /* @__PURE__ */ function() {
  function Unicode2() {
  }
  ;
  Unicode2.value = new Unicode2();
  return Unicode2;
}();
var Nominal = /* @__PURE__ */ function() {
  function Nominal2() {
  }
  ;
  Nominal2.value = new Nominal2();
  return Nominal2;
}();
var Representational = /* @__PURE__ */ function() {
  function Representational2() {
  }
  ;
  Representational2.value = new Representational2();
  return Representational2;
}();
var Phantom = /* @__PURE__ */ function() {
  function Phantom2() {
  }
  ;
  Phantom2.value = new Phantom2();
  return Phantom2;
}();
var LF = /* @__PURE__ */ function() {
  function LF2() {
  }
  ;
  LF2.value = new LF2();
  return LF2;
}();
var CRLF = /* @__PURE__ */ function() {
  function CRLF2() {
  }
  ;
  CRLF2.value = new CRLF2();
  return CRLF2;
}();
var SmallInt = /* @__PURE__ */ function() {
  function SmallInt2(value0) {
    this.value0 = value0;
  }
  ;
  SmallInt2.create = function(value0) {
    return new SmallInt2(value0);
  };
  return SmallInt2;
}();
var BigInt2 = /* @__PURE__ */ function() {
  function BigInt3(value0) {
    this.value0 = value0;
  }
  ;
  BigInt3.create = function(value0) {
    return new BigInt3(value0);
  };
  return BigInt3;
}();
var BigHex = /* @__PURE__ */ function() {
  function BigHex2(value0) {
    this.value0 = value0;
  }
  ;
  BigHex2.create = function(value0) {
    return new BigHex2(value0);
  };
  return BigHex2;
}();
var TokLeftParen = /* @__PURE__ */ function() {
  function TokLeftParen2() {
  }
  ;
  TokLeftParen2.value = new TokLeftParen2();
  return TokLeftParen2;
}();
var TokRightParen = /* @__PURE__ */ function() {
  function TokRightParen2() {
  }
  ;
  TokRightParen2.value = new TokRightParen2();
  return TokRightParen2;
}();
var TokLeftBrace = /* @__PURE__ */ function() {
  function TokLeftBrace2() {
  }
  ;
  TokLeftBrace2.value = new TokLeftBrace2();
  return TokLeftBrace2;
}();
var TokRightBrace = /* @__PURE__ */ function() {
  function TokRightBrace2() {
  }
  ;
  TokRightBrace2.value = new TokRightBrace2();
  return TokRightBrace2;
}();
var TokLeftSquare = /* @__PURE__ */ function() {
  function TokLeftSquare2() {
  }
  ;
  TokLeftSquare2.value = new TokLeftSquare2();
  return TokLeftSquare2;
}();
var TokRightSquare = /* @__PURE__ */ function() {
  function TokRightSquare2() {
  }
  ;
  TokRightSquare2.value = new TokRightSquare2();
  return TokRightSquare2;
}();
var TokLeftArrow = /* @__PURE__ */ function() {
  function TokLeftArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokLeftArrow2.create = function(value0) {
    return new TokLeftArrow2(value0);
  };
  return TokLeftArrow2;
}();
var TokRightArrow = /* @__PURE__ */ function() {
  function TokRightArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightArrow2.create = function(value0) {
    return new TokRightArrow2(value0);
  };
  return TokRightArrow2;
}();
var TokRightFatArrow = /* @__PURE__ */ function() {
  function TokRightFatArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightFatArrow2.create = function(value0) {
    return new TokRightFatArrow2(value0);
  };
  return TokRightFatArrow2;
}();
var TokDoubleColon = /* @__PURE__ */ function() {
  function TokDoubleColon2(value0) {
    this.value0 = value0;
  }
  ;
  TokDoubleColon2.create = function(value0) {
    return new TokDoubleColon2(value0);
  };
  return TokDoubleColon2;
}();
var TokForall = /* @__PURE__ */ function() {
  function TokForall2(value0) {
    this.value0 = value0;
  }
  ;
  TokForall2.create = function(value0) {
    return new TokForall2(value0);
  };
  return TokForall2;
}();
var TokEquals = /* @__PURE__ */ function() {
  function TokEquals2() {
  }
  ;
  TokEquals2.value = new TokEquals2();
  return TokEquals2;
}();
var TokPipe = /* @__PURE__ */ function() {
  function TokPipe2() {
  }
  ;
  TokPipe2.value = new TokPipe2();
  return TokPipe2;
}();
var TokTick = /* @__PURE__ */ function() {
  function TokTick2() {
  }
  ;
  TokTick2.value = new TokTick2();
  return TokTick2;
}();
var TokDot = /* @__PURE__ */ function() {
  function TokDot2() {
  }
  ;
  TokDot2.value = new TokDot2();
  return TokDot2;
}();
var TokComma = /* @__PURE__ */ function() {
  function TokComma2() {
  }
  ;
  TokComma2.value = new TokComma2();
  return TokComma2;
}();
var TokUnderscore = /* @__PURE__ */ function() {
  function TokUnderscore2() {
  }
  ;
  TokUnderscore2.value = new TokUnderscore2();
  return TokUnderscore2;
}();
var TokBackslash = /* @__PURE__ */ function() {
  function TokBackslash2() {
  }
  ;
  TokBackslash2.value = new TokBackslash2();
  return TokBackslash2;
}();
var TokAt = /* @__PURE__ */ function() {
  function TokAt2() {
  }
  ;
  TokAt2.value = new TokAt2();
  return TokAt2;
}();
var TokLowerName = /* @__PURE__ */ function() {
  function TokLowerName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokLowerName2.create = function(value0) {
    return function(value12) {
      return new TokLowerName2(value0, value12);
    };
  };
  return TokLowerName2;
}();
var TokUpperName = /* @__PURE__ */ function() {
  function TokUpperName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokUpperName2.create = function(value0) {
    return function(value12) {
      return new TokUpperName2(value0, value12);
    };
  };
  return TokUpperName2;
}();
var TokOperator = /* @__PURE__ */ function() {
  function TokOperator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokOperator2.create = function(value0) {
    return function(value12) {
      return new TokOperator2(value0, value12);
    };
  };
  return TokOperator2;
}();
var TokSymbolName = /* @__PURE__ */ function() {
  function TokSymbolName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokSymbolName2.create = function(value0) {
    return function(value12) {
      return new TokSymbolName2(value0, value12);
    };
  };
  return TokSymbolName2;
}();
var TokSymbolArrow = /* @__PURE__ */ function() {
  function TokSymbolArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokSymbolArrow2.create = function(value0) {
    return new TokSymbolArrow2(value0);
  };
  return TokSymbolArrow2;
}();
var TokHole = /* @__PURE__ */ function() {
  function TokHole2(value0) {
    this.value0 = value0;
  }
  ;
  TokHole2.create = function(value0) {
    return new TokHole2(value0);
  };
  return TokHole2;
}();
var TokChar = /* @__PURE__ */ function() {
  function TokChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokChar2.create = function(value0) {
    return function(value12) {
      return new TokChar2(value0, value12);
    };
  };
  return TokChar2;
}();
var TokString = /* @__PURE__ */ function() {
  function TokString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokString2.create = function(value0) {
    return function(value12) {
      return new TokString2(value0, value12);
    };
  };
  return TokString2;
}();
var TokRawString = /* @__PURE__ */ function() {
  function TokRawString2(value0) {
    this.value0 = value0;
  }
  ;
  TokRawString2.create = function(value0) {
    return new TokRawString2(value0);
  };
  return TokRawString2;
}();
var TokInt = /* @__PURE__ */ function() {
  function TokInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokInt2.create = function(value0) {
    return function(value12) {
      return new TokInt2(value0, value12);
    };
  };
  return TokInt2;
}();
var TokNumber = /* @__PURE__ */ function() {
  function TokNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokNumber2.create = function(value0) {
    return function(value12) {
      return new TokNumber2(value0, value12);
    };
  };
  return TokNumber2;
}();
var TokLayoutStart = /* @__PURE__ */ function() {
  function TokLayoutStart2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutStart2.create = function(value0) {
    return new TokLayoutStart2(value0);
  };
  return TokLayoutStart2;
}();
var TokLayoutSep = /* @__PURE__ */ function() {
  function TokLayoutSep2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutSep2.create = function(value0) {
    return new TokLayoutSep2(value0);
  };
  return TokLayoutSep2;
}();
var TokLayoutEnd = /* @__PURE__ */ function() {
  function TokLayoutEnd2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutEnd2.create = function(value0) {
    return new TokLayoutEnd2(value0);
  };
  return TokLayoutEnd2;
}();
var Infix = /* @__PURE__ */ function() {
  function Infix2() {
  }
  ;
  Infix2.value = new Infix2();
  return Infix2;
}();
var Infixl = /* @__PURE__ */ function() {
  function Infixl2() {
  }
  ;
  Infixl2.value = new Infixl2();
  return Infixl2;
}();
var Infixr = /* @__PURE__ */ function() {
  function Infixr2() {
  }
  ;
  Infixr2.value = new Infixr2();
  return Infixr2;
}();
var Comment = /* @__PURE__ */ function() {
  function Comment2(value0) {
    this.value0 = value0;
  }
  ;
  Comment2.create = function(value0) {
    return new Comment2(value0);
  };
  return Comment2;
}();
var Space = /* @__PURE__ */ function() {
  function Space2(value0) {
    this.value0 = value0;
  }
  ;
  Space2.create = function(value0) {
    return new Space2(value0);
  };
  return Space2;
}();
var Line = /* @__PURE__ */ function() {
  function Line3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Line3.create = function(value0) {
    return function(value12) {
      return new Line3(value0, value12);
    };
  };
  return Line3;
}();
var FixityValue = /* @__PURE__ */ function() {
  function FixityValue2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FixityValue2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FixityValue2(value0, value12, value22);
      };
    };
  };
  return FixityValue2;
}();
var FixityType = /* @__PURE__ */ function() {
  function FixityType2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  FixityType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new FixityType2(value0, value12, value22, value3);
        };
      };
    };
  };
  return FixityType2;
}();
var RecordPun = /* @__PURE__ */ function() {
  function RecordPun2(value0) {
    this.value0 = value0;
  }
  ;
  RecordPun2.create = function(value0) {
    return new RecordPun2(value0);
  };
  return RecordPun2;
}();
var RecordField = /* @__PURE__ */ function() {
  function RecordField2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordField2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordField2(value0, value12, value22);
      };
    };
  };
  return RecordField2;
}();
var DataAll = /* @__PURE__ */ function() {
  function DataAll2(value0) {
    this.value0 = value0;
  }
  ;
  DataAll2.create = function(value0) {
    return new DataAll2(value0);
  };
  return DataAll2;
}();
var DataEnumerated = /* @__PURE__ */ function() {
  function DataEnumerated2(value0) {
    this.value0 = value0;
  }
  ;
  DataEnumerated2.create = function(value0) {
    return new DataEnumerated2(value0);
  };
  return DataEnumerated2;
}();
var ExportValue = /* @__PURE__ */ function() {
  function ExportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ExportValue2.create = function(value0) {
    return new ExportValue2(value0);
  };
  return ExportValue2;
}();
var ExportOp = /* @__PURE__ */ function() {
  function ExportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ExportOp2.create = function(value0) {
    return new ExportOp2(value0);
  };
  return ExportOp2;
}();
var ExportType = /* @__PURE__ */ function() {
  function ExportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportType2.create = function(value0) {
    return function(value12) {
      return new ExportType2(value0, value12);
    };
  };
  return ExportType2;
}();
var ExportTypeOp = /* @__PURE__ */ function() {
  function ExportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ExportTypeOp2(value0, value12);
    };
  };
  return ExportTypeOp2;
}();
var ExportClass = /* @__PURE__ */ function() {
  function ExportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportClass2.create = function(value0) {
    return function(value12) {
      return new ExportClass2(value0, value12);
    };
  };
  return ExportClass2;
}();
var ExportModule = /* @__PURE__ */ function() {
  function ExportModule2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportModule2.create = function(value0) {
    return function(value12) {
      return new ExportModule2(value0, value12);
    };
  };
  return ExportModule2;
}();
var ImportValue = /* @__PURE__ */ function() {
  function ImportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ImportValue2.create = function(value0) {
    return new ImportValue2(value0);
  };
  return ImportValue2;
}();
var ImportOp = /* @__PURE__ */ function() {
  function ImportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ImportOp2.create = function(value0) {
    return new ImportOp2(value0);
  };
  return ImportOp2;
}();
var ImportType = /* @__PURE__ */ function() {
  function ImportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportType2.create = function(value0) {
    return function(value12) {
      return new ImportType2(value0, value12);
    };
  };
  return ImportType2;
}();
var ImportTypeOp = /* @__PURE__ */ function() {
  function ImportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ImportTypeOp2(value0, value12);
    };
  };
  return ImportTypeOp2;
}();
var ImportClass = /* @__PURE__ */ function() {
  function ImportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportClass2.create = function(value0) {
    return function(value12) {
      return new ImportClass2(value0, value12);
    };
  };
  return ImportClass2;
}();
var One = /* @__PURE__ */ function() {
  function One2(value0) {
    this.value0 = value0;
  }
  ;
  One2.create = function(value0) {
    return new One2(value0);
  };
  return One2;
}();
var Many = /* @__PURE__ */ function() {
  function Many2(value0) {
    this.value0 = value0;
  }
  ;
  Many2.create = function(value0) {
    return new Many2(value0);
  };
  return Many2;
}();
var TypeVarKinded = /* @__PURE__ */ function() {
  function TypeVarKinded2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarKinded2.create = function(value0) {
    return new TypeVarKinded2(value0);
  };
  return TypeVarKinded2;
}();
var TypeVarName = /* @__PURE__ */ function() {
  function TypeVarName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarName2.create = function(value0) {
    return new TypeVarName2(value0);
  };
  return TypeVarName2;
}();
var TypeVar = /* @__PURE__ */ function() {
  function TypeVar2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVar2.create = function(value0) {
    return new TypeVar2(value0);
  };
  return TypeVar2;
}();
var TypeConstructor = /* @__PURE__ */ function() {
  function TypeConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  TypeConstructor2.create = function(value0) {
    return new TypeConstructor2(value0);
  };
  return TypeConstructor2;
}();
var TypeWildcard = /* @__PURE__ */ function() {
  function TypeWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  TypeWildcard2.create = function(value0) {
    return new TypeWildcard2(value0);
  };
  return TypeWildcard2;
}();
var TypeHole = /* @__PURE__ */ function() {
  function TypeHole2(value0) {
    this.value0 = value0;
  }
  ;
  TypeHole2.create = function(value0) {
    return new TypeHole2(value0);
  };
  return TypeHole2;
}();
var TypeString = /* @__PURE__ */ function() {
  function TypeString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeString2.create = function(value0) {
    return function(value12) {
      return new TypeString2(value0, value12);
    };
  };
  return TypeString2;
}();
var TypeInt = /* @__PURE__ */ function() {
  function TypeInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeInt2(value0, value12, value22);
      };
    };
  };
  return TypeInt2;
}();
var TypeRow = /* @__PURE__ */ function() {
  function TypeRow2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRow2.create = function(value0) {
    return new TypeRow2(value0);
  };
  return TypeRow2;
}();
var TypeRecord = /* @__PURE__ */ function() {
  function TypeRecord2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRecord2.create = function(value0) {
    return new TypeRecord2(value0);
  };
  return TypeRecord2;
}();
var TypeForall = /* @__PURE__ */ function() {
  function TypeForall2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  TypeForall2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new TypeForall2(value0, value12, value22, value3);
        };
      };
    };
  };
  return TypeForall2;
}();
var TypeKinded = /* @__PURE__ */ function() {
  function TypeKinded2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeKinded2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeKinded2(value0, value12, value22);
      };
    };
  };
  return TypeKinded2;
}();
var TypeApp = /* @__PURE__ */ function() {
  function TypeApp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeApp2.create = function(value0) {
    return function(value12) {
      return new TypeApp2(value0, value12);
    };
  };
  return TypeApp2;
}();
var TypeOp = /* @__PURE__ */ function() {
  function TypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeOp2.create = function(value0) {
    return function(value12) {
      return new TypeOp2(value0, value12);
    };
  };
  return TypeOp2;
}();
var TypeOpName = /* @__PURE__ */ function() {
  function TypeOpName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeOpName2.create = function(value0) {
    return new TypeOpName2(value0);
  };
  return TypeOpName2;
}();
var TypeArrow = /* @__PURE__ */ function() {
  function TypeArrow2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeArrow2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeArrow2(value0, value12, value22);
      };
    };
  };
  return TypeArrow2;
}();
var TypeArrowName = /* @__PURE__ */ function() {
  function TypeArrowName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeArrowName2.create = function(value0) {
    return new TypeArrowName2(value0);
  };
  return TypeArrowName2;
}();
var TypeConstrained = /* @__PURE__ */ function() {
  function TypeConstrained2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeConstrained2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeConstrained2(value0, value12, value22);
      };
    };
  };
  return TypeConstrained2;
}();
var TypeParens = /* @__PURE__ */ function() {
  function TypeParens2(value0) {
    this.value0 = value0;
  }
  ;
  TypeParens2.create = function(value0) {
    return new TypeParens2(value0);
  };
  return TypeParens2;
}();
var $$TypeError = /* @__PURE__ */ function() {
  function $$TypeError2(value0) {
    this.value0 = value0;
  }
  ;
  $$TypeError2.create = function(value0) {
    return new $$TypeError2(value0);
  };
  return $$TypeError2;
}();
var ForeignValue = /* @__PURE__ */ function() {
  function ForeignValue2(value0) {
    this.value0 = value0;
  }
  ;
  ForeignValue2.create = function(value0) {
    return new ForeignValue2(value0);
  };
  return ForeignValue2;
}();
var ForeignData = /* @__PURE__ */ function() {
  function ForeignData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignData2.create = function(value0) {
    return function(value12) {
      return new ForeignData2(value0, value12);
    };
  };
  return ForeignData2;
}();
var ForeignKind = /* @__PURE__ */ function() {
  function ForeignKind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignKind2.create = function(value0) {
    return function(value12) {
      return new ForeignKind2(value0, value12);
    };
  };
  return ForeignKind2;
}();
var FundepDetermined = /* @__PURE__ */ function() {
  function FundepDetermined2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FundepDetermined2.create = function(value0) {
    return function(value12) {
      return new FundepDetermined2(value0, value12);
    };
  };
  return FundepDetermined2;
}();
var FundepDetermines = /* @__PURE__ */ function() {
  function FundepDetermines2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FundepDetermines2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FundepDetermines2(value0, value12, value22);
      };
    };
  };
  return FundepDetermines2;
}();
var BinderWildcard = /* @__PURE__ */ function() {
  function BinderWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  BinderWildcard2.create = function(value0) {
    return new BinderWildcard2(value0);
  };
  return BinderWildcard2;
}();
var BinderVar = /* @__PURE__ */ function() {
  function BinderVar2(value0) {
    this.value0 = value0;
  }
  ;
  BinderVar2.create = function(value0) {
    return new BinderVar2(value0);
  };
  return BinderVar2;
}();
var BinderNamed = /* @__PURE__ */ function() {
  function BinderNamed2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNamed2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNamed2(value0, value12, value22);
      };
    };
  };
  return BinderNamed2;
}();
var BinderConstructor = /* @__PURE__ */ function() {
  function BinderConstructor2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderConstructor2.create = function(value0) {
    return function(value12) {
      return new BinderConstructor2(value0, value12);
    };
  };
  return BinderConstructor2;
}();
var BinderBoolean = /* @__PURE__ */ function() {
  function BinderBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderBoolean2.create = function(value0) {
    return function(value12) {
      return new BinderBoolean2(value0, value12);
    };
  };
  return BinderBoolean2;
}();
var BinderChar = /* @__PURE__ */ function() {
  function BinderChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderChar2.create = function(value0) {
    return function(value12) {
      return new BinderChar2(value0, value12);
    };
  };
  return BinderChar2;
}();
var BinderString = /* @__PURE__ */ function() {
  function BinderString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderString2.create = function(value0) {
    return function(value12) {
      return new BinderString2(value0, value12);
    };
  };
  return BinderString2;
}();
var BinderInt = /* @__PURE__ */ function() {
  function BinderInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderInt2(value0, value12, value22);
      };
    };
  };
  return BinderInt2;
}();
var BinderNumber = /* @__PURE__ */ function() {
  function BinderNumber2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNumber2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNumber2(value0, value12, value22);
      };
    };
  };
  return BinderNumber2;
}();
var BinderArray = /* @__PURE__ */ function() {
  function BinderArray2(value0) {
    this.value0 = value0;
  }
  ;
  BinderArray2.create = function(value0) {
    return new BinderArray2(value0);
  };
  return BinderArray2;
}();
var BinderRecord = /* @__PURE__ */ function() {
  function BinderRecord2(value0) {
    this.value0 = value0;
  }
  ;
  BinderRecord2.create = function(value0) {
    return new BinderRecord2(value0);
  };
  return BinderRecord2;
}();
var BinderParens = /* @__PURE__ */ function() {
  function BinderParens2(value0) {
    this.value0 = value0;
  }
  ;
  BinderParens2.create = function(value0) {
    return new BinderParens2(value0);
  };
  return BinderParens2;
}();
var BinderTyped = /* @__PURE__ */ function() {
  function BinderTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderTyped2(value0, value12, value22);
      };
    };
  };
  return BinderTyped2;
}();
var BinderOp = /* @__PURE__ */ function() {
  function BinderOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderOp2.create = function(value0) {
    return function(value12) {
      return new BinderOp2(value0, value12);
    };
  };
  return BinderOp2;
}();
var BinderError = /* @__PURE__ */ function() {
  function BinderError2(value0) {
    this.value0 = value0;
  }
  ;
  BinderError2.create = function(value0) {
    return new BinderError2(value0);
  };
  return BinderError2;
}();
var AppType = /* @__PURE__ */ function() {
  function AppType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AppType2.create = function(value0) {
    return function(value12) {
      return new AppType2(value0, value12);
    };
  };
  return AppType2;
}();
var AppTerm = /* @__PURE__ */ function() {
  function AppTerm2(value0) {
    this.value0 = value0;
  }
  ;
  AppTerm2.create = function(value0) {
    return new AppTerm2(value0);
  };
  return AppTerm2;
}();
var DoLet = /* @__PURE__ */ function() {
  function DoLet2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DoLet2.create = function(value0) {
    return function(value12) {
      return new DoLet2(value0, value12);
    };
  };
  return DoLet2;
}();
var DoDiscard = /* @__PURE__ */ function() {
  function DoDiscard2(value0) {
    this.value0 = value0;
  }
  ;
  DoDiscard2.create = function(value0) {
    return new DoDiscard2(value0);
  };
  return DoDiscard2;
}();
var DoBind = /* @__PURE__ */ function() {
  function DoBind2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DoBind2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DoBind2(value0, value12, value22);
      };
    };
  };
  return DoBind2;
}();
var DoError = /* @__PURE__ */ function() {
  function DoError2(value0) {
    this.value0 = value0;
  }
  ;
  DoError2.create = function(value0) {
    return new DoError2(value0);
  };
  return DoError2;
}();
var LetBindingSignature = /* @__PURE__ */ function() {
  function LetBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingSignature2.create = function(value0) {
    return new LetBindingSignature2(value0);
  };
  return LetBindingSignature2;
}();
var LetBindingName = /* @__PURE__ */ function() {
  function LetBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingName2.create = function(value0) {
    return new LetBindingName2(value0);
  };
  return LetBindingName2;
}();
var LetBindingPattern = /* @__PURE__ */ function() {
  function LetBindingPattern2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  LetBindingPattern2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new LetBindingPattern2(value0, value12, value22);
      };
    };
  };
  return LetBindingPattern2;
}();
var LetBindingError = /* @__PURE__ */ function() {
  function LetBindingError2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingError2.create = function(value0) {
    return new LetBindingError2(value0);
  };
  return LetBindingError2;
}();
var Unconditional = /* @__PURE__ */ function() {
  function Unconditional2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Unconditional2.create = function(value0) {
    return function(value12) {
      return new Unconditional2(value0, value12);
    };
  };
  return Unconditional2;
}();
var Guarded = /* @__PURE__ */ function() {
  function Guarded2(value0) {
    this.value0 = value0;
  }
  ;
  Guarded2.create = function(value0) {
    return new Guarded2(value0);
  };
  return Guarded2;
}();
var ExprHole = /* @__PURE__ */ function() {
  function ExprHole2(value0) {
    this.value0 = value0;
  }
  ;
  ExprHole2.create = function(value0) {
    return new ExprHole2(value0);
  };
  return ExprHole2;
}();
var ExprSection = /* @__PURE__ */ function() {
  function ExprSection2(value0) {
    this.value0 = value0;
  }
  ;
  ExprSection2.create = function(value0) {
    return new ExprSection2(value0);
  };
  return ExprSection2;
}();
var ExprIdent = /* @__PURE__ */ function() {
  function ExprIdent2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIdent2.create = function(value0) {
    return new ExprIdent2(value0);
  };
  return ExprIdent2;
}();
var ExprConstructor = /* @__PURE__ */ function() {
  function ExprConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprConstructor2.create = function(value0) {
    return new ExprConstructor2(value0);
  };
  return ExprConstructor2;
}();
var ExprBoolean = /* @__PURE__ */ function() {
  function ExprBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprBoolean2.create = function(value0) {
    return function(value12) {
      return new ExprBoolean2(value0, value12);
    };
  };
  return ExprBoolean2;
}();
var ExprChar = /* @__PURE__ */ function() {
  function ExprChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprChar2.create = function(value0) {
    return function(value12) {
      return new ExprChar2(value0, value12);
    };
  };
  return ExprChar2;
}();
var ExprString = /* @__PURE__ */ function() {
  function ExprString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprString2.create = function(value0) {
    return function(value12) {
      return new ExprString2(value0, value12);
    };
  };
  return ExprString2;
}();
var ExprInt = /* @__PURE__ */ function() {
  function ExprInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInt2.create = function(value0) {
    return function(value12) {
      return new ExprInt2(value0, value12);
    };
  };
  return ExprInt2;
}();
var ExprNumber = /* @__PURE__ */ function() {
  function ExprNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNumber2.create = function(value0) {
    return function(value12) {
      return new ExprNumber2(value0, value12);
    };
  };
  return ExprNumber2;
}();
var ExprArray = /* @__PURE__ */ function() {
  function ExprArray2(value0) {
    this.value0 = value0;
  }
  ;
  ExprArray2.create = function(value0) {
    return new ExprArray2(value0);
  };
  return ExprArray2;
}();
var ExprRecord = /* @__PURE__ */ function() {
  function ExprRecord2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecord2.create = function(value0) {
    return new ExprRecord2(value0);
  };
  return ExprRecord2;
}();
var ExprParens = /* @__PURE__ */ function() {
  function ExprParens2(value0) {
    this.value0 = value0;
  }
  ;
  ExprParens2.create = function(value0) {
    return new ExprParens2(value0);
  };
  return ExprParens2;
}();
var ExprTyped = /* @__PURE__ */ function() {
  function ExprTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ExprTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ExprTyped2(value0, value12, value22);
      };
    };
  };
  return ExprTyped2;
}();
var ExprInfix = /* @__PURE__ */ function() {
  function ExprInfix2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInfix2.create = function(value0) {
    return function(value12) {
      return new ExprInfix2(value0, value12);
    };
  };
  return ExprInfix2;
}();
var ExprOp = /* @__PURE__ */ function() {
  function ExprOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprOp2.create = function(value0) {
    return function(value12) {
      return new ExprOp2(value0, value12);
    };
  };
  return ExprOp2;
}();
var ExprOpName = /* @__PURE__ */ function() {
  function ExprOpName2(value0) {
    this.value0 = value0;
  }
  ;
  ExprOpName2.create = function(value0) {
    return new ExprOpName2(value0);
  };
  return ExprOpName2;
}();
var ExprNegate = /* @__PURE__ */ function() {
  function ExprNegate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNegate2.create = function(value0) {
    return function(value12) {
      return new ExprNegate2(value0, value12);
    };
  };
  return ExprNegate2;
}();
var ExprRecordAccessor = /* @__PURE__ */ function() {
  function ExprRecordAccessor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecordAccessor2.create = function(value0) {
    return new ExprRecordAccessor2(value0);
  };
  return ExprRecordAccessor2;
}();
var ExprRecordUpdate = /* @__PURE__ */ function() {
  function ExprRecordUpdate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprRecordUpdate2.create = function(value0) {
    return function(value12) {
      return new ExprRecordUpdate2(value0, value12);
    };
  };
  return ExprRecordUpdate2;
}();
var ExprApp = /* @__PURE__ */ function() {
  function ExprApp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprApp2.create = function(value0) {
    return function(value12) {
      return new ExprApp2(value0, value12);
    };
  };
  return ExprApp2;
}();
var ExprLambda = /* @__PURE__ */ function() {
  function ExprLambda2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLambda2.create = function(value0) {
    return new ExprLambda2(value0);
  };
  return ExprLambda2;
}();
var ExprIf = /* @__PURE__ */ function() {
  function ExprIf2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIf2.create = function(value0) {
    return new ExprIf2(value0);
  };
  return ExprIf2;
}();
var ExprCase = /* @__PURE__ */ function() {
  function ExprCase2(value0) {
    this.value0 = value0;
  }
  ;
  ExprCase2.create = function(value0) {
    return new ExprCase2(value0);
  };
  return ExprCase2;
}();
var ExprLet = /* @__PURE__ */ function() {
  function ExprLet2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLet2.create = function(value0) {
    return new ExprLet2(value0);
  };
  return ExprLet2;
}();
var ExprDo = /* @__PURE__ */ function() {
  function ExprDo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprDo2.create = function(value0) {
    return new ExprDo2(value0);
  };
  return ExprDo2;
}();
var ExprAdo = /* @__PURE__ */ function() {
  function ExprAdo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprAdo2.create = function(value0) {
    return new ExprAdo2(value0);
  };
  return ExprAdo2;
}();
var ExprError = /* @__PURE__ */ function() {
  function ExprError2(value0) {
    this.value0 = value0;
  }
  ;
  ExprError2.create = function(value0) {
    return new ExprError2(value0);
  };
  return ExprError2;
}();
var RecordUpdateLeaf = /* @__PURE__ */ function() {
  function RecordUpdateLeaf2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordUpdateLeaf2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordUpdateLeaf2(value0, value12, value22);
      };
    };
  };
  return RecordUpdateLeaf2;
}();
var RecordUpdateBranch = /* @__PURE__ */ function() {
  function RecordUpdateBranch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RecordUpdateBranch2.create = function(value0) {
    return function(value12) {
      return new RecordUpdateBranch2(value0, value12);
    };
  };
  return RecordUpdateBranch2;
}();
var InstanceBindingSignature = /* @__PURE__ */ function() {
  function InstanceBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingSignature2.create = function(value0) {
    return new InstanceBindingSignature2(value0);
  };
  return InstanceBindingSignature2;
}();
var InstanceBindingName = /* @__PURE__ */ function() {
  function InstanceBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingName2.create = function(value0) {
    return new InstanceBindingName2(value0);
  };
  return InstanceBindingName2;
}();
var DeclData = /* @__PURE__ */ function() {
  function DeclData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclData2.create = function(value0) {
    return function(value12) {
      return new DeclData2(value0, value12);
    };
  };
  return DeclData2;
}();
var DeclType = /* @__PURE__ */ function() {
  function DeclType2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclType2(value0, value12, value22);
      };
    };
  };
  return DeclType2;
}();
var DeclNewtype = /* @__PURE__ */ function() {
  function DeclNewtype2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  DeclNewtype2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new DeclNewtype2(value0, value12, value22, value3);
        };
      };
    };
  };
  return DeclNewtype2;
}();
var DeclClass = /* @__PURE__ */ function() {
  function DeclClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclClass2.create = function(value0) {
    return function(value12) {
      return new DeclClass2(value0, value12);
    };
  };
  return DeclClass2;
}();
var DeclInstanceChain = /* @__PURE__ */ function() {
  function DeclInstanceChain2(value0) {
    this.value0 = value0;
  }
  ;
  DeclInstanceChain2.create = function(value0) {
    return new DeclInstanceChain2(value0);
  };
  return DeclInstanceChain2;
}();
var DeclDerive = /* @__PURE__ */ function() {
  function DeclDerive2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclDerive2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclDerive2(value0, value12, value22);
      };
    };
  };
  return DeclDerive2;
}();
var DeclKindSignature = /* @__PURE__ */ function() {
  function DeclKindSignature2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclKindSignature2.create = function(value0) {
    return function(value12) {
      return new DeclKindSignature2(value0, value12);
    };
  };
  return DeclKindSignature2;
}();
var DeclSignature = /* @__PURE__ */ function() {
  function DeclSignature2(value0) {
    this.value0 = value0;
  }
  ;
  DeclSignature2.create = function(value0) {
    return new DeclSignature2(value0);
  };
  return DeclSignature2;
}();
var DeclValue = /* @__PURE__ */ function() {
  function DeclValue2(value0) {
    this.value0 = value0;
  }
  ;
  DeclValue2.create = function(value0) {
    return new DeclValue2(value0);
  };
  return DeclValue2;
}();
var DeclFixity = /* @__PURE__ */ function() {
  function DeclFixity2(value0) {
    this.value0 = value0;
  }
  ;
  DeclFixity2.create = function(value0) {
    return new DeclFixity2(value0);
  };
  return DeclFixity2;
}();
var DeclForeign = /* @__PURE__ */ function() {
  function DeclForeign2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclForeign2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclForeign2(value0, value12, value22);
      };
    };
  };
  return DeclForeign2;
}();
var DeclRole = /* @__PURE__ */ function() {
  function DeclRole2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  DeclRole2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new DeclRole2(value0, value12, value22, value3);
        };
      };
    };
  };
  return DeclRole2;
}();
var DeclError = /* @__PURE__ */ function() {
  function DeclError2(value0) {
    this.value0 = value0;
  }
  ;
  DeclError2.create = function(value0) {
    return new DeclError2(value0);
  };
  return DeclError2;
}();
var ordModuleName = ordString;
var eqModuleName = eqString;

// output/Whine.Types/index.js
var map11 = /* @__PURE__ */ map(functorEither);
var reportViolation = function(dict) {
  return dict.reportViolation;
};
var emptyRule = {
  onModule: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onModuleImport: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onModuleExport: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onDecl: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onBinder: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onExpr: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  },
  onType: function(dictMonadRules) {
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      return function(v) {
        return pure34(unit);
      };
    };
  }
};
var ruleFactory = function(rid) {
  return function(argsCodec) {
    return function(construct) {
      return new Tuple(rid, function(args) {
        var v = map11(construct)(decode2(argsCodec)(args));
        if (v instanceof Left && isNull(args)) {
          return new Right(emptyRule);
        }
        ;
        if (v instanceof Left) {
          return new Left(print3(v.value0));
        }
        ;
        if (v instanceof Right) {
          return new Right(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Whine.Types (line 105, column 5 - line 110, column 31): " + [v.constructor.name]);
      });
    };
  };
};
var currentModule = function(dict) {
  return dict.currentModule;
};

// output/PSExtract.WhineRules/index.js
var all3 = /* @__PURE__ */ all(foldableArray)(heytingAlgebraBoolean);
var map13 = /* @__PURE__ */ map(functorArray);
var any3 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var unwrap4 = /* @__PURE__ */ unwrap();
var compare3 = /* @__PURE__ */ compare(ordModuleName);
var eq3 = /* @__PURE__ */ eq(eqModuleName);
var qualifiedImportsOnlyRule = function(v) {
  var isSymbol = function(v1) {
    if (v1 instanceof ImportTypeOp) {
      return true;
    }
    ;
    if (v1 instanceof ImportOp) {
      return true;
    }
    ;
    if (v1 instanceof ImportClass) {
      return true;
    }
    ;
    return false;
  };
  var isSymbolOnlyImport = function(v1) {
    return isSymbol(v1.value.head) && all3(function($117) {
      return isSymbol(snd($117));
    })(v1.value.tail);
  };
  var isMixedImport = function(v1) {
    var allItems = cons(v1.value.head)(map13(snd)(v1.value.tail));
    var hasOperator = any3(isSymbol)(allItems);
    var hasRegular = any3(function($118) {
      return !isSymbol($118);
    })(allItems);
    return hasOperator && hasRegular;
  };
  var onImport = function(dictMonadRules) {
    var MonadReport3 = dictMonadRules.MonadReport3();
    var pure34 = pure(MonadReport3.Monad0().Applicative0());
    var reportViolation2 = reportViolation(MonadReport3);
    return function(dictRangeOf) {
      return function(v1) {
        if (v1.qualified instanceof Nothing && v1.module.name === "Prelude") {
          return pure34(unit);
        }
        ;
        if (v1.qualified instanceof Nothing && (v1.names instanceof Just && isSymbolOnlyImport(v1.names.value0.value1))) {
          return pure34(unit);
        }
        ;
        if (v1.qualified instanceof Nothing && (v1.names instanceof Just && isMixedImport(v1.names.value0.value1))) {
          return reportViolation2({
            source: new Just(v1.module.token.range),
            message: "Mixed import contains both regular items and operators/classes. Split into two imports:\n" + ("  (1) import " + (unwrap4(v1.module.name) + (" as " + (unwrap4(v1.module.name) + ("  -- for types/functions\n" + ("  (2) import " + (unwrap4(v1.module.name) + " (<operators/classes>)  -- for operators and type classes only")))))))
          });
        }
        ;
        if (v1.qualified instanceof Nothing) {
          return reportViolation2({
            source: new Just(v1.module.token.range),
            message: "Import must be qualified with 'as " + (unwrap4(v1.module.name) + ("'. Use: import " + (unwrap4(v1.module.name) + (" as " + unwrap4(v1.module.name)))))
          });
        }
        ;
        if (v1.qualified instanceof Just) {
          return pure34(unit);
        }
        ;
        throw new Error("Failed pattern match at PSExtract.WhineRules (line 28, column 7 - line 58, column 34): " + [v1.qualified.constructor.name, v1.module.name.constructor.name, v1.names.constructor.name]);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onExpr: emptyRule.onExpr,
    onType: emptyRule.onType,
    onModuleImport: onImport
  };
};
var noDuplicateImportsRule = function(v) {
  var isSymbol = function(v1) {
    if (v1 instanceof ImportTypeOp) {
      return true;
    }
    ;
    if (v1 instanceof ImportOp) {
      return true;
    }
    ;
    if (v1 instanceof ImportClass) {
      return true;
    }
    ;
    return false;
  };
  var isSymbolOnlyImport = function(v1) {
    return isSymbol(v1.value.head) && all3(function($119) {
      return isSymbol(snd($119));
    })(v1.value.tail);
  };
  var isSymbolOnlyImportDecl = function(v1) {
    if (v1.names instanceof Just) {
      return isSymbolOnlyImport(v1.names.value0.value1);
    }
    ;
    return false;
  };
  var compareModuleName = function(v1) {
    return function(v2) {
      return compare3(v1.module.name)(v2.module.name);
    };
  };
  var onModule = function(dictMonadRules) {
    var MonadReport3 = dictMonadRules.MonadReport3();
    var for_2 = for_(MonadReport3.Monad0().Applicative0())(foldableArray);
    var reportViolation2 = reportViolation(MonadReport3);
    return function(dictRangeOf) {
      return function(v1) {
        var grouped = groupAllBy(compareModuleName)(v1.header.imports);
        var duplicates = filter(function(g) {
          return length2(g) > 1;
        })(grouped);
        return for_2(duplicates)(function(group5) {
          var v2 = uncons2(group5);
          var nonSymbolDuplicates = filter(function($120) {
            return !isSymbolOnlyImportDecl($120);
          })(v2.tail);
          return for_2(nonSymbolDuplicates)(function(v3) {
            return reportViolation2({
              source: new Just(v3.module.token.range),
              message: "Duplicate import of module '" + (unwrap4(v2.head.module.name) + "'. Remove duplicate imports.")
            });
          });
        });
      };
    };
  };
  return {
    onModuleImport: emptyRule.onModuleImport,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onExpr: emptyRule.onExpr,
    onType: emptyRule.onType,
    onModule
  };
};
var matchingAliasesRule = function(v) {
  var onImport = function(dictMonadRules) {
    var MonadReport3 = dictMonadRules.MonadReport3();
    var pure34 = pure(MonadReport3.Monad0().Applicative0());
    var reportViolation2 = reportViolation(MonadReport3);
    return function(dictRangeOf) {
      return function(v1) {
        if (v1.qualified instanceof Just) {
          var $111 = eq3(v1.module.name)(v1.qualified.value0.value1.name);
          if ($111) {
            return pure34(unit);
          }
          ;
          return reportViolation2({
            source: new Just(v1.qualified.value0.value1.token.range),
            message: "Import alias must match module name. Use: as " + (unwrap4(v1.module.name) + (" (not as " + (unwrap4(v1.qualified.value0.value1.name) + ")")))
          });
        }
        ;
        return pure34(unit);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onExpr: emptyRule.onExpr,
    onType: emptyRule.onType,
    onModuleImport: onImport
  };
};
var rules = [/* @__PURE__ */ ruleFactory("QualifiedImportsOnly")(json)(qualifiedImportsOnlyRule), /* @__PURE__ */ ruleFactory("MatchingAliases")(json)(matchingAliasesRule), /* @__PURE__ */ ruleFactory("NoDuplicateImports")(json)(noDuplicateImportsRule)];

// output/PureScript.CST.Range/index.js
var rangeOfWrapped = {
  rangeOf: function(v) {
    return {
      start: v.open.range.start,
      end: v.close.range.end
    };
  }
};
var rangeOfVoid = {
  rangeOf: absurd
};
var rangeOfRecoveredError = {
  rangeOf: function(v) {
    var v1 = fromArray(v.tokens);
    if (v1 instanceof Just) {
      return {
        start: head2(v1.value0).range.start,
        end: last2(v1.value0).range.end
      };
    }
    ;
    if (v1 instanceof Nothing) {
      return {
        start: v.position,
        end: v.position
      };
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Range (line 49, column 5 - line 57, column 10): " + [v1.constructor.name]);
  }
};
var rangeOfQualifiedName = {
  rangeOf: function(v) {
    return v.token.range;
  }
};
var rangeOfName = {
  rangeOf: function(v) {
    return v.token.range;
  }
};
var rangeOf = function(dict) {
  return dict.rangeOf;
};
var rangeOf1 = /* @__PURE__ */ rangeOf(rangeOfName);
var rangeOf2 = /* @__PURE__ */ rangeOf(rangeOfWrapped);
var rangeOf3 = /* @__PURE__ */ rangeOf(rangeOfQualifiedName);
var rangeOfLabeled = function(dictRangeOf) {
  var rangeOf9 = rangeOf(dictRangeOf);
  return function(dictRangeOf1) {
    var rangeOf10 = rangeOf(dictRangeOf1);
    return {
      rangeOf: function(v) {
        return {
          start: rangeOf9(v.label).start,
          end: rangeOf10(v.value).end
        };
      }
    };
  };
};
var rangeOfLabeled1 = /* @__PURE__ */ rangeOfLabeled(rangeOfName);
var rangeOfSeparated = function(dictRangeOf) {
  var rangeOf9 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      var v1 = last(v.tail);
      if (v1 instanceof Just) {
        return {
          start: rangeOf9(v.head).start,
          end: rangeOf9(v1.value0.value1).end
        };
      }
      ;
      if (v1 instanceof Nothing) {
        return rangeOf9(v.head);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 101, column 5 - line 107, column 21): " + [v1.constructor.name]);
    }
  };
};
var rangeOf6 = /* @__PURE__ */ rangeOf(/* @__PURE__ */ rangeOfSeparated(rangeOfName));
var rangeOfType = function(dictRangeOf) {
  var rangeOf9 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      if (v instanceof TypeVar) {
        return rangeOf1(v.value0);
      }
      ;
      if (v instanceof TypeConstructor) {
        return rangeOf3(v.value0);
      }
      ;
      if (v instanceof TypeWildcard) {
        return v.value0.range;
      }
      ;
      if (v instanceof TypeHole) {
        return rangeOf1(v.value0);
      }
      ;
      if (v instanceof TypeString) {
        return v.value0.range;
      }
      ;
      if (v instanceof TypeInt) {
        if (v.value0 instanceof Nothing) {
          return v.value1.range;
        }
        ;
        if (v.value0 instanceof Just) {
          return {
            start: v.value0.value0.range.start,
            end: v.value1.range.end
          };
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Range (line 165, column 7 - line 171, column 12): " + [v.value0.constructor.name]);
      }
      ;
      if (v instanceof TypeRow) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof TypeRecord) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof TypeForall) {
        return {
          start: v.value0.range.start,
          end: rangeOf(rangeOfType(dictRangeOf))(v.value3).end
        };
      }
      ;
      if (v instanceof TypeKinded) {
        return {
          start: rangeOf(rangeOfType(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfType(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof TypeApp) {
        return {
          start: rangeOf(rangeOfType(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfType(dictRangeOf))(last2(v.value1)).end
        };
      }
      ;
      if (v instanceof TypeOp) {
        return {
          start: rangeOf(rangeOfType(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfType(dictRangeOf))(snd(last2(v.value1))).end
        };
      }
      ;
      if (v instanceof TypeOpName) {
        return rangeOf3(v.value0);
      }
      ;
      if (v instanceof TypeArrow) {
        return {
          start: rangeOf(rangeOfType(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfType(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof TypeArrowName) {
        return v.value0.range;
      }
      ;
      if (v instanceof TypeConstrained) {
        return {
          start: rangeOf(rangeOfType(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfType(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof TypeParens) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof $$TypeError) {
        return rangeOf9(v.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 153, column 13 - line 207, column 16): " + [v.constructor.name]);
    }
  };
};
var rangeOfAppSpine = function(dictRangeOf) {
  var rangeOf9 = rangeOf(rangeOfType(dictRangeOf));
  return function(dictRangeOf1) {
    var rangeOf10 = rangeOf(dictRangeOf1);
    return {
      rangeOf: function(v) {
        if (v instanceof AppType) {
          return {
            start: v.value0.range.start,
            end: rangeOf9(v.value1).end
          };
        }
        ;
        if (v instanceof AppTerm) {
          return rangeOf10(v.value0);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Range (line 847, column 13 - line 853, column 16): " + [v.constructor.name]);
      }
    };
  };
};
var rangeOfBinder = function(dictRangeOf) {
  var rangeOf9 = rangeOf(rangeOfType(dictRangeOf));
  var rangeOf10 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      if (v instanceof BinderWildcard) {
        return v.value0.range;
      }
      ;
      if (v instanceof BinderVar) {
        return rangeOf1(v.value0);
      }
      ;
      if (v instanceof BinderNamed) {
        return {
          start: rangeOf1(v.value0).start,
          end: rangeOf(rangeOfBinder(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof BinderConstructor) {
        var v1 = last(v.value1);
        if (v1 instanceof Nothing) {
          return rangeOf3(v.value0);
        }
        ;
        if (v1 instanceof Just) {
          return {
            start: rangeOf3(v.value0).start,
            end: rangeOf(rangeOfBinder(dictRangeOf))(v1.value0).end
          };
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Range (line 932, column 7 - line 938, column 12): " + [v1.constructor.name]);
      }
      ;
      if (v instanceof BinderBoolean) {
        return v.value0.range;
      }
      ;
      if (v instanceof BinderChar) {
        return v.value0.range;
      }
      ;
      if (v instanceof BinderString) {
        return v.value0.range;
      }
      ;
      if (v instanceof BinderInt) {
        if (v.value0 instanceof Nothing) {
          return v.value1.range;
        }
        ;
        if (v.value0 instanceof Just) {
          return {
            start: v.value0.value0.range.start,
            end: v.value1.range.end
          };
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Range (line 946, column 7 - line 952, column 12): " + [v.value0.constructor.name]);
      }
      ;
      if (v instanceof BinderNumber) {
        if (v.value0 instanceof Nothing) {
          return v.value1.range;
        }
        ;
        if (v.value0 instanceof Just) {
          return {
            start: v.value0.value0.range.start,
            end: v.value1.range.end
          };
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Range (line 954, column 7 - line 960, column 12): " + [v.value0.constructor.name]);
      }
      ;
      if (v instanceof BinderArray) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof BinderRecord) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof BinderParens) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof BinderTyped) {
        return {
          start: rangeOf(rangeOfBinder(dictRangeOf))(v.value0).start,
          end: rangeOf9(v.value2).end
        };
      }
      ;
      if (v instanceof BinderOp) {
        return {
          start: rangeOf(rangeOfBinder(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfBinder(dictRangeOf))(snd(last2(v.value1))).end
        };
      }
      ;
      if (v instanceof BinderError) {
        return rangeOf10(v.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 922, column 13 - line 976, column 16): " + [v.constructor.name]);
    }
  };
};
var rangeOfWhere = function(dictRangeOf) {
  return {
    rangeOf: function(v) {
      if (v.bindings instanceof Nothing) {
        return rangeOf(rangeOfExpr(dictRangeOf))(v.expr);
      }
      ;
      if (v.bindings instanceof Just) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.expr).start,
          end: rangeOf(rangeOfLetBinding(dictRangeOf))(last2(v.bindings.value0.value1)).end
        };
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 1019, column 40 - line 1025, column 8): " + [v.bindings.constructor.name]);
    }
  };
};
var rangeOfLetBinding = function(dictRangeOf) {
  var rangeOf9 = rangeOf(rangeOfLabeled1(rangeOfType(dictRangeOf)));
  var rangeOf10 = rangeOf(rangeOfBinder(dictRangeOf));
  var rangeOf11 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      if (v instanceof LetBindingSignature) {
        return rangeOf9(v.value0);
      }
      ;
      if (v instanceof LetBindingName) {
        return {
          start: rangeOf1(v.value0.name).start,
          end: rangeOf(rangeOfGuarded(dictRangeOf))(v.value0.guarded).end
        };
      }
      ;
      if (v instanceof LetBindingPattern) {
        return {
          start: rangeOf10(v.value0).start,
          end: rangeOf(rangeOfWhere(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof LetBindingError) {
        return rangeOf11(v.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 896, column 13 - line 908, column 16): " + [v.constructor.name]);
    }
  };
};
var rangeOfGuardedExpr = function(dictRangeOf) {
  return {
    rangeOf: function(v) {
      return {
        start: v.bar.range.start,
        end: rangeOf(rangeOfWhere(dictRangeOf))(v.where).end
      };
    }
  };
};
var rangeOfGuarded = function(dictRangeOf) {
  return {
    rangeOf: function(v) {
      if (v instanceof Unconditional) {
        return {
          start: v.value0.range.start,
          end: rangeOf(rangeOfWhere(dictRangeOf))(v.value1).end
        };
      }
      ;
      if (v instanceof Guarded) {
        return {
          start: rangeOf(rangeOfGuardedExpr(dictRangeOf))(head2(v.value0)).start,
          end: rangeOf(rangeOfGuardedExpr(dictRangeOf))(last2(v.value0)).end
        };
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 596, column 13 - line 604, column 8): " + [v.constructor.name]);
    }
  };
};
var rangeOfExpr = function(dictRangeOf) {
  var rangeOf9 = rangeOf(rangeOfType(dictRangeOf));
  var rangeOfAppSpine1 = rangeOfAppSpine(dictRangeOf);
  var rangeOf10 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      if (v instanceof ExprHole) {
        return rangeOf1(v.value0);
      }
      ;
      if (v instanceof ExprSection) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprIdent) {
        return rangeOf3(v.value0);
      }
      ;
      if (v instanceof ExprConstructor) {
        return rangeOf3(v.value0);
      }
      ;
      if (v instanceof ExprBoolean) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprChar) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprString) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprInt) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprNumber) {
        return v.value0.range;
      }
      ;
      if (v instanceof ExprArray) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof ExprRecord) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof ExprParens) {
        return rangeOf2(v.value0);
      }
      ;
      if (v instanceof ExprTyped) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0).start,
          end: rangeOf9(v.value2).end
        };
      }
      ;
      if (v instanceof ExprInfix) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(snd(last2(v.value1))).end
        };
      }
      ;
      if (v instanceof ExprOp) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(snd(last2(v.value1))).end
        };
      }
      ;
      if (v instanceof ExprOpName) {
        return rangeOf3(v.value0);
      }
      ;
      if (v instanceof ExprNegate) {
        return {
          start: v.value0.range.start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v.value1).end
        };
      }
      ;
      if (v instanceof ExprRecordAccessor) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0.expr).start,
          end: rangeOf6(v.value0.path).end
        };
      }
      ;
      if (v instanceof ExprRecordUpdate) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0).start,
          end: rangeOf2(v.value1).end
        };
      }
      ;
      if (v instanceof ExprApp) {
        return {
          start: rangeOf(rangeOfExpr(dictRangeOf))(v.value0).start,
          end: rangeOf(rangeOfAppSpine1(rangeOfExpr(dictRangeOf)))(last2(v.value1)).end
        };
      }
      ;
      if (v instanceof ExprLambda) {
        return {
          start: v.value0.symbol.range.start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v.value0.body).end
        };
      }
      ;
      if (v instanceof ExprIf) {
        return {
          start: v.value0.keyword.range.start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v["value0"]["false"]).end
        };
      }
      ;
      if (v instanceof ExprCase) {
        return {
          start: v.value0.keyword.range.start,
          end: rangeOf(rangeOfGuarded(dictRangeOf))(snd(last2(v.value0.branches))).end
        };
      }
      ;
      if (v instanceof ExprLet) {
        return {
          start: v.value0.keyword.range.start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v.value0.body).end
        };
      }
      ;
      if (v instanceof ExprDo) {
        return {
          start: v.value0.keyword.range.start,
          end: rangeOf(rangeOfDoStatement(dictRangeOf))(last2(v.value0.statements)).end
        };
      }
      ;
      if (v instanceof ExprAdo) {
        return {
          start: v.value0.keyword.range.start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v.value0.result).end
        };
      }
      ;
      if (v instanceof ExprError) {
        return rangeOf10(v.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 690, column 13 - line 770, column 16): " + [v.constructor.name]);
    }
  };
};
var rangeOfDoStatement = function(dictRangeOf) {
  var rangeOf9 = rangeOf(rangeOfBinder(dictRangeOf));
  var rangeOf10 = rangeOf(dictRangeOf);
  return {
    rangeOf: function(v) {
      if (v instanceof DoLet) {
        return {
          start: v.value0.range.start,
          end: rangeOf(rangeOfLetBinding(dictRangeOf))(last2(v.value1)).end
        };
      }
      ;
      if (v instanceof DoDiscard) {
        return rangeOf(rangeOfExpr(dictRangeOf))(v.value0);
      }
      ;
      if (v instanceof DoBind) {
        return {
          start: rangeOf9(v.value0).start,
          end: rangeOf(rangeOfExpr(dictRangeOf))(v.value2).end
        };
      }
      ;
      if (v instanceof DoError) {
        return rangeOf10(v.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Range (line 870, column 13 - line 882, column 16): " + [v.constructor.name]);
    }
  };
};

// output/Control.Monad.Writer.Trans/index.js
var WriterT = function(x) {
  return x;
};
var runWriterT = function(v) {
  return v;
};
var monadTransWriterT = function(dictMonoid) {
  var mempty9 = mempty(dictMonoid);
  return {
    lift: function(dictMonad) {
      var bind30 = bind(dictMonad.Bind1());
      var pure34 = pure(dictMonad.Applicative0());
      return function(m) {
        return bind30(m)(function(a) {
          return pure34(new Tuple(a, mempty9));
        });
      };
    }
  };
};
var mapWriterT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorWriterT = function(dictFunctor) {
  var map47 = map(dictFunctor);
  return {
    map: function(f) {
      return mapWriterT(map47(function(v) {
        return new Tuple(f(v.value0), v.value1);
      }));
    }
  };
};
var applyWriterT = function(dictSemigroup) {
  var append11 = append(dictSemigroup);
  return function(dictApply) {
    var apply15 = apply(dictApply);
    var Functor0 = dictApply.Functor0();
    var map47 = map(Functor0);
    var functorWriterT1 = functorWriterT(Functor0);
    return {
      apply: function(v) {
        return function(v1) {
          var k = function(v3) {
            return function(v4) {
              return new Tuple(v3.value0(v4.value0), append11(v3.value1)(v4.value1));
            };
          };
          return apply15(map47(k)(v))(v1);
        };
      },
      Functor0: function() {
        return functorWriterT1;
      }
    };
  };
};
var bindWriterT = function(dictSemigroup) {
  var append11 = append(dictSemigroup);
  var applyWriterT1 = applyWriterT(dictSemigroup);
  return function(dictBind) {
    var bind30 = bind(dictBind);
    var Apply0 = dictBind.Apply0();
    var map47 = map(Apply0.Functor0());
    var applyWriterT22 = applyWriterT1(Apply0);
    return {
      bind: function(v) {
        return function(k) {
          return bind30(v)(function(v1) {
            var v2 = k(v1.value0);
            return map47(function(v3) {
              return new Tuple(v3.value0, append11(v1.value1)(v3.value1));
            })(v2);
          });
        };
      },
      Apply0: function() {
        return applyWriterT22;
      }
    };
  };
};
var applicativeWriterT = function(dictMonoid) {
  var mempty9 = mempty(dictMonoid);
  var applyWriterT1 = applyWriterT(dictMonoid.Semigroup0());
  return function(dictApplicative) {
    var pure34 = pure(dictApplicative);
    var applyWriterT22 = applyWriterT1(dictApplicative.Apply0());
    return {
      pure: function(a) {
        return pure34(new Tuple(a, mempty9));
      },
      Apply0: function() {
        return applyWriterT22;
      }
    };
  };
};
var monadWriterT = function(dictMonoid) {
  var applicativeWriterT1 = applicativeWriterT(dictMonoid);
  var bindWriterT1 = bindWriterT(dictMonoid.Semigroup0());
  return function(dictMonad) {
    var applicativeWriterT22 = applicativeWriterT1(dictMonad.Applicative0());
    var bindWriterT22 = bindWriterT1(dictMonad.Bind1());
    return {
      Applicative0: function() {
        return applicativeWriterT22;
      },
      Bind1: function() {
        return bindWriterT22;
      }
    };
  };
};
var monadAskWriterT = function(dictMonoid) {
  var lift8 = lift(monadTransWriterT(dictMonoid));
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var monadWriterT22 = monadWriterT1(Monad0);
    return {
      ask: lift8(Monad0)(ask(dictMonadAsk)),
      Monad0: function() {
        return monadWriterT22;
      }
    };
  };
};
var monadEffectWriter = function(dictMonoid) {
  var lift8 = lift(monadTransWriterT(dictMonoid));
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonadEffect) {
    var Monad0 = dictMonadEffect.Monad0();
    var monadWriterT22 = monadWriterT1(Monad0);
    return {
      liftEffect: function() {
        var $259 = lift8(Monad0);
        var $260 = liftEffect(dictMonadEffect);
        return function($261) {
          return $259($260($261));
        };
      }(),
      Monad0: function() {
        return monadWriterT22;
      }
    };
  };
};
var monadTellWriterT = function(dictMonoid) {
  var Semigroup0 = dictMonoid.Semigroup0();
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonad) {
    var monadWriterT22 = monadWriterT1(dictMonad);
    return {
      tell: function() {
        var $262 = pure(dictMonad.Applicative0());
        var $263 = Tuple.create(unit);
        return function($264) {
          return WriterT($262($263($264)));
        };
      }(),
      Semigroup0: function() {
        return Semigroup0;
      },
      Monad1: function() {
        return monadWriterT22;
      }
    };
  };
};

// output/Data.Map.Internal/index.js
var $runtime_lazy4 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var Leaf = /* @__PURE__ */ function() {
  function Leaf3() {
  }
  ;
  Leaf3.value = new Leaf3();
  return Leaf3;
}();
var Node = /* @__PURE__ */ function() {
  function Node2(value0, value12, value22, value3, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  Node2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return function(value4) {
            return function(value5) {
              return new Node2(value0, value12, value22, value3, value4, value5);
            };
          };
        };
      };
    };
  };
  return Node2;
}();
var IterLeaf = /* @__PURE__ */ function() {
  function IterLeaf2() {
  }
  ;
  IterLeaf2.value = new IterLeaf2();
  return IterLeaf2;
}();
var IterEmit = /* @__PURE__ */ function() {
  function IterEmit2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  IterEmit2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new IterEmit2(value0, value12, value22);
      };
    };
  };
  return IterEmit2;
}();
var IterNode = /* @__PURE__ */ function() {
  function IterNode2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  IterNode2.create = function(value0) {
    return function(value12) {
      return new IterNode2(value0, value12);
    };
  };
  return IterNode2;
}();
var Split = /* @__PURE__ */ function() {
  function Split2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Split2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Split2(value0, value12, value22);
      };
    };
  };
  return Split2;
}();
var SplitLast = /* @__PURE__ */ function() {
  function SplitLast2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SplitLast2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SplitLast2(value0, value12, value22);
      };
    };
  };
  return SplitLast2;
}();
var unsafeNode = function(k, v, l, r) {
  if (l instanceof Leaf) {
    if (r instanceof Leaf) {
      return new Node(1, 1, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 702, column 5 - line 706, column 39): " + [r.constructor.name]);
  }
  ;
  if (l instanceof Node) {
    if (r instanceof Leaf) {
      return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + function() {
        var $280 = l.value0 > r.value0;
        if ($280) {
          return l.value0;
        }
        ;
        return r.value0;
      }() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 708, column 5 - line 712, column 68): " + [r.constructor.name]);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 700, column 32 - line 712, column 68): " + [l.constructor.name]);
};
var toMapIter = /* @__PURE__ */ function() {
  return flip(IterNode.create)(IterLeaf.value);
}();
var stepWith = function(f) {
  return function(next2) {
    return function(done) {
      var go = function($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
          if (v instanceof IterLeaf) {
            $tco_done = true;
            return done(unit);
          }
          ;
          if (v instanceof IterEmit) {
            $tco_done = true;
            return next2(v.value0, v.value1, v.value2);
          }
          ;
          if (v instanceof IterNode) {
            $copy_v = f(v.value1)(v.value0);
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 940, column 8 - line 946, column 20): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_v);
        }
        ;
        return $tco_result;
      };
      return go;
    };
  };
};
var singleton9 = function(k) {
  return function(v) {
    return new Node(1, 1, k, v, Leaf.value, Leaf.value);
  };
};
var unsafeBalancedNode = /* @__PURE__ */ function() {
  var height = function(v) {
    if (v instanceof Leaf) {
      return 0;
    }
    ;
    if (v instanceof Node) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 757, column 12 - line 759, column 26): " + [v.constructor.name]);
  };
  var rotateLeft = function(k, v, l, rk, rv, rl, rr) {
    if (rl instanceof Node && rl.value0 > height(rr)) {
      return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));
    }
    ;
    return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);
  };
  var rotateRight = function(k, v, lk, lv, ll, lr, r) {
    if (lr instanceof Node && height(ll) <= lr.value0) {
      return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));
    }
    ;
    return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));
  };
  return function(k, v, l, r) {
    if (l instanceof Leaf) {
      if (r instanceof Leaf) {
        return singleton9(k)(v);
      }
      ;
      if (r instanceof Node && r.value0 > 1) {
        return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    if (l instanceof Node) {
      if (r instanceof Node) {
        if (r.value0 > (l.value0 + 1 | 0)) {
          return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
        }
        ;
        if (l.value0 > (r.value0 + 1 | 0)) {
          return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
        }
        ;
      }
      ;
      if (r instanceof Leaf && l.value0 > 1) {
        return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 717, column 40 - line 738, column 34): " + [l.constructor.name]);
  };
}();
var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy4("unsafeSplit", "Data.Map.Internal", function() {
  return function(comp, k, m) {
    if (m instanceof Leaf) {
      return new Split(Nothing.value, Leaf.value, Leaf.value);
    }
    ;
    if (m instanceof Node) {
      var v = comp(k)(m.value2);
      if (v instanceof LT) {
        var v1 = $lazy_unsafeSplit(793)(comp, k, m.value4);
        return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));
      }
      ;
      if (v instanceof GT) {
        var v1 = $lazy_unsafeSplit(796)(comp, k, m.value5);
        return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);
      }
      ;
      if (v instanceof EQ) {
        return new Split(new Just(m.value3), m.value4, m.value5);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 791, column 5 - line 799, column 30): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 787, column 34 - line 799, column 30): " + [m.constructor.name]);
  };
});
var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(786);
var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy4("unsafeSplitLast", "Data.Map.Internal", function() {
  return function(k, v, l, r) {
    if (r instanceof Leaf) {
      return new SplitLast(k, v, l);
    }
    ;
    if (r instanceof Node) {
      var v1 = $lazy_unsafeSplitLast(779)(r.value2, r.value3, r.value4, r.value5);
      return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 776, column 37 - line 780, column 57): " + [r.constructor.name]);
  };
});
var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(775);
var unsafeJoinNodes = function(v, v1) {
  if (v instanceof Leaf) {
    return v1;
  }
  ;
  if (v instanceof Node) {
    var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);
    return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 764, column 25 - line 768, column 38): " + [v.constructor.name, v1.constructor.name]);
};
var $lazy_unsafeDifference = /* @__PURE__ */ $runtime_lazy4("unsafeDifference", "Data.Map.Internal", function() {
  return function(comp, l, r) {
    if (l instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeDifference(841)(comp, v.value1, r.value4);
      var r$prime = $lazy_unsafeDifference(842)(comp, v.value2, r.value5);
      return unsafeJoinNodes(l$prime, r$prime);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 836, column 39 - line 843, column 33): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeDifference = /* @__PURE__ */ $lazy_unsafeDifference(835);
var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy4("unsafeUnionWith", "Data.Map.Internal", function() {
  return function(comp, app, l, r) {
    if (l instanceof Leaf) {
      return r;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeUnionWith(809)(comp, app, v.value1, r.value4);
      var r$prime = $lazy_unsafeUnionWith(810)(comp, app, v.value2, r.value5);
      if (v.value0 instanceof Just) {
        return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);
      }
      ;
      if (v.value0 instanceof Nothing) {
        return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 811, column 5 - line 815, column 46): " + [v.value0.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 804, column 42 - line 815, column 46): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(803);
var unionWith = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(app) {
    return function(m1) {
      return function(m2) {
        return unsafeUnionWith(compare5, app, m1, m2);
      };
    };
  };
};
var union = function(dictOrd) {
  return unionWith(dictOrd)($$const);
};
var member = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return false;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare5(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 459, column 7 - line 462, column 19): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 456, column 8 - line 462, column 19): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var lookup3 = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare5(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value3);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 283, column 7 - line 286, column 22): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 280, column 8 - line 286, column 22): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var iterMapL = /* @__PURE__ */ function() {
  var go = function($copy_iter) {
    return function($copy_v) {
      var $tco_var_iter = $copy_iter;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(iter, v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return iter;
        }
        ;
        if (v instanceof Node) {
          if (v.value5 instanceof Leaf) {
            $tco_var_iter = new IterEmit(v.value2, v.value3, iter);
            $copy_v = v.value4;
            return;
          }
          ;
          $tco_var_iter = new IterEmit(v.value2, v.value3, new IterNode(v.value5, iter));
          $copy_v = v.value4;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 951, column 13 - line 958, column 48): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_iter, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
}();
var stepAscCps = /* @__PURE__ */ stepWith(iterMapL);
var stepUnfoldr = /* @__PURE__ */ function() {
  var step3 = function(k, v, next2) {
    return new Just(new Tuple(new Tuple(k, v), next2));
  };
  return stepAscCps(step3)(function(v) {
    return Nothing.value;
  });
}();
var toUnfoldable2 = function(dictUnfoldable) {
  var $784 = unfoldr(dictUnfoldable)(stepUnfoldr);
  return function($785) {
    return $784(toMapIter($785));
  };
};
var isEmpty = function(v) {
  if (v instanceof Leaf) {
    return true;
  }
  ;
  return false;
};
var insertWith = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(app) {
    return function(k) {
      return function(v) {
        var go = function(v1) {
          if (v1 instanceof Leaf) {
            return singleton9(k)(v);
          }
          ;
          if (v1 instanceof Node) {
            var v2 = compare5(k)(v1.value2);
            if (v2 instanceof LT) {
              return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
            }
            ;
            if (v2 instanceof GT) {
              return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
            }
            ;
            if (v2 instanceof EQ) {
              return new Node(v1.value0, v1.value1, k, app(v1.value3)(v), v1.value4, v1.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 486, column 7 - line 489, column 44): " + [v2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 483, column 8 - line 489, column 44): " + [v1.constructor.name]);
        };
        return go;
      };
    };
  };
};
var insert2 = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(k) {
    return function(v) {
      var go = function(v1) {
        if (v1 instanceof Leaf) {
          return singleton9(k)(v);
        }
        ;
        if (v1 instanceof Node) {
          var v2 = compare5(k)(v1.value2);
          if (v2 instanceof LT) {
            return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
          }
          ;
          if (v2 instanceof GT) {
            return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
          }
          ;
          if (v2 instanceof EQ) {
            return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 471, column 7 - line 474, column 35): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 8 - line 474, column 35): " + [v1.constructor.name]);
      };
      return go;
    };
  };
};
var functorMap = {
  map: function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        return new Node(v.value0, v.value1, v.value2, f(v.value3), go(v.value4), go(v.value5));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 147, column 10 - line 150, column 39): " + [v.constructor.name]);
    };
    return go;
  }
};
var foldableMap = {
  foldr: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(172)(m$prime.value4, f(m$prime.value3)($lazy_go(172)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 169, column 26 - line 172, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(169);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(178)(f($lazy_go(178)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 175, column 26 - line 178, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(175);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty9 = mempty(dictMonoid);
    var append110 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty9;
        }
        ;
        if (v instanceof Node) {
          return append110(go(v.value4))(append110(f(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 181, column 10 - line 184, column 28): " + [v.constructor.name]);
      };
      return go;
    };
  }
};
var foldableWithIndexMap = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(192)(m$prime.value4, f(m$prime.value2)(m$prime.value3)($lazy_go(192)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 189, column 26 - line 192, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(189);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(198)(f(m$prime.value2)($lazy_go(198)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 195, column 26 - line 198, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(195);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    var mempty9 = mempty(dictMonoid);
    var append110 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty9;
        }
        ;
        if (v instanceof Node) {
          return append110(go(v.value4))(append110(f(v.value2)(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 201, column 10 - line 204, column 30): " + [v.constructor.name]);
      };
      return go;
    };
  },
  Foldable0: function() {
    return foldableMap;
  }
};
var keys2 = /* @__PURE__ */ function() {
  return foldrWithIndex(foldableWithIndexMap)(function(k) {
    return function(v) {
      return function(acc) {
        return new Cons(k, acc);
      };
    };
  })(Nil.value);
}();
var empty4 = /* @__PURE__ */ function() {
  return Leaf.value;
}();
var fromFoldable5 = function(dictOrd) {
  var insert1 = insert2(dictOrd);
  return function(dictFoldable) {
    return foldl(dictFoldable)(function(m) {
      return function(v) {
        return insert1(v.value0)(v.value1)(m);
      };
    })(empty4);
  };
};
var difference2 = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(m1) {
    return function(m2) {
      return unsafeDifference(compare5, m1, m2);
    };
  };
};
var $$delete2 = function(dictOrd) {
  var compare5 = compare(dictOrd);
  return function(k) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        var v1 = compare5(k)(v.value2);
        if (v1 instanceof LT) {
          return unsafeBalancedNode(v.value2, v.value3, go(v.value4), v.value5);
        }
        ;
        if (v1 instanceof GT) {
          return unsafeBalancedNode(v.value2, v.value3, v.value4, go(v.value5));
        }
        ;
        if (v1 instanceof EQ) {
          return unsafeJoinNodes(v.value4, v.value5);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 498, column 7 - line 501, column 43): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 495, column 8 - line 501, column 43): " + [v.constructor.name]);
    };
    return go;
  };
};

// output/Data.List/index.js
var map14 = /* @__PURE__ */ map(functorMaybe);
var uncons4 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just({
      head: v.value0,
      tail: v.value1
    });
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [v.constructor.name]);
};
var toUnfoldable3 = function(dictUnfoldable) {
  return unfoldr(dictUnfoldable)(function(xs) {
    return map14(function(rec) {
      return new Tuple(rec.head, rec.tail);
    })(uncons4(xs));
  });
};
var span2 = function(v) {
  return function(v1) {
    if (v1 instanceof Cons && v(v1.value0)) {
      var v2 = span2(v)(v1.value1);
      return {
        init: new Cons(v1.value0, v2.init),
        rest: v2.rest
      };
    }
    ;
    return {
      init: Nil.value,
      rest: v1
    };
  };
};
var reverse2 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
}();
var $$null4 = function(v) {
  if (v instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var mapMaybe2 = function(f) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return reverse2(v);
        }
        ;
        if (v1 instanceof Cons) {
          var v2 = f(v1.value0);
          if (v2 instanceof Nothing) {
            $tco_var_v = v;
            $copy_v1 = v1.value1;
            return;
          }
          ;
          if (v2 instanceof Just) {
            $tco_var_v = new Cons(v2.value0, v);
            $copy_v1 = v1.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List (line 419, column 5 - line 421, column 32): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 417, column 3 - line 417, column 27): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var fromFoldable6 = function(dictFoldable) {
  return foldr(dictFoldable)(Cons.create)(Nil.value);
};

// output/Data.Set/index.js
var coerce4 = /* @__PURE__ */ coerce();
var toList2 = function(v) {
  return keys2(v);
};
var toUnfoldable4 = function(dictUnfoldable) {
  var $96 = toUnfoldable3(dictUnfoldable);
  return function($97) {
    return $96(toList2($97));
  };
};
var member2 = function(dictOrd) {
  return coerce4(member(dictOrd));
};
var isEmpty2 = /* @__PURE__ */ coerce4(isEmpty);
var insert3 = function(dictOrd) {
  var insert1 = insert2(dictOrd);
  return function(a) {
    return function(v) {
      return insert1(a)(unit)(v);
    };
  };
};
var empty5 = empty4;
var fromFoldable7 = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictOrd) {
    var insert1 = insert3(dictOrd);
    return foldl22(function(m) {
      return function(a) {
        return insert1(a)(m);
      };
    })(empty5);
  };
};
var difference3 = function(dictOrd) {
  return coerce4(difference2(dictOrd));
};

// output/Data.Profunctor/index.js
var dimap = function(dict) {
  return dict.dimap;
};

// output/Data.String.NonEmpty.Internal/index.js
var toString3 = function(v) {
  return v;
};
var fromString4 = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(v);
};

// output/Node.Encoding/index.js
var ASCII2 = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var UTF8 = /* @__PURE__ */ function() {
  function UTF82() {
  }
  ;
  UTF82.value = new UTF82();
  return UTF82;
}();
var UTF16LE = /* @__PURE__ */ function() {
  function UTF16LE2() {
  }
  ;
  UTF16LE2.value = new UTF16LE2();
  return UTF16LE2;
}();
var UCS2 = /* @__PURE__ */ function() {
  function UCS22() {
  }
  ;
  UCS22.value = new UCS22();
  return UCS22;
}();
var Base64 = /* @__PURE__ */ function() {
  function Base642() {
  }
  ;
  Base642.value = new Base642();
  return Base642;
}();
var Base64Url = /* @__PURE__ */ function() {
  function Base64Url2() {
  }
  ;
  Base64Url2.value = new Base64Url2();
  return Base64Url2;
}();
var Latin1 = /* @__PURE__ */ function() {
  function Latin12() {
  }
  ;
  Latin12.value = new Latin12();
  return Latin12;
}();
var Binary = /* @__PURE__ */ function() {
  function Binary2() {
  }
  ;
  Binary2.value = new Binary2();
  return Binary2;
}();
var Hex = /* @__PURE__ */ function() {
  function Hex2() {
  }
  ;
  Hex2.value = new Hex2();
  return Hex2;
}();
var showEncoding = {
  show: function(v) {
    if (v instanceof ASCII2) {
      return "ASCII";
    }
    ;
    if (v instanceof UTF8) {
      return "UTF8";
    }
    ;
    if (v instanceof UTF16LE) {
      return "UTF16LE";
    }
    ;
    if (v instanceof UCS2) {
      return "UCS2";
    }
    ;
    if (v instanceof Base64) {
      return "Base64";
    }
    ;
    if (v instanceof Base64Url) {
      return "Base64Url";
    }
    ;
    if (v instanceof Latin1) {
      return "Latin1";
    }
    ;
    if (v instanceof Binary) {
      return "Binary";
    }
    ;
    if (v instanceof Hex) {
      return "Hex";
    }
    ;
    throw new Error("Failed pattern match at Node.Encoding (line 22, column 1 - line 31, column 19): " + [v.constructor.name]);
  }
};
var encodingToNode = function(v) {
  if (v instanceof ASCII2) {
    return "ascii";
  }
  ;
  if (v instanceof UTF8) {
    return "utf8";
  }
  ;
  if (v instanceof UTF16LE) {
    return "utf16le";
  }
  ;
  if (v instanceof UCS2) {
    return "ucs2";
  }
  ;
  if (v instanceof Base64) {
    return "base64";
  }
  ;
  if (v instanceof Base64Url) {
    return "base64url";
  }
  ;
  if (v instanceof Latin1) {
    return "latin1";
  }
  ;
  if (v instanceof Binary) {
    return "binary";
  }
  ;
  if (v instanceof Hex) {
    return "hex";
  }
  ;
  throw new Error("Failed pattern match at Node.Encoding (line 35, column 1 - line 35, column 37): " + [v.constructor.name]);
};

// output/Node.Path/foreign.js
import path from "path";
var normalize = path.normalize;
function relative(from3) {
  return (to2) => path.relative(from3, to2);
}
function dirname(p) {
  return path.normalize(path.dirname(p));
}
var basename = path.basename;
var extname = path.extname;
var sep = path.sep;
var delimiter = path.delimiter;
var parse = path.parse;
var isAbsolute = path.isAbsolute;

// output/Whine.Prelude/index.js
var unionRanges = function(a) {
  return function(b) {
    var lt = function(x) {
      return function(y) {
        return x.line < y.line || x.line === y.line && x.column < y.column;
      };
    };
    var max4 = function(x) {
      return function(y) {
        var $6 = lt(x)(y);
        if ($6) {
          return y;
        }
        ;
        return x;
      };
    };
    var min5 = function(x) {
      return function(y) {
        var $7 = lt(x)(y);
        if ($7) {
          return x;
        }
        ;
        return y;
      };
    };
    return {
      start: min5(a.start)(b.start),
      end: max4(a.end)(b.end)
    };
  };
};
var unionManyRanges = /* @__PURE__ */ function() {
  var go = function(v) {
    return function(v1) {
      if (v instanceof Nothing) {
        return new Just(v1);
      }
      ;
      if (v instanceof Just) {
        return new Just(unionRanges(v.value0)(v1));
      }
      ;
      throw new Error("Failed pattern match at Whine.Prelude (line 47, column 5 - line 47, column 44): " + [v.constructor.name, v1.constructor.name]);
    };
  };
  return foldl2(go)(Nothing.value);
}();

// output/Whine.Core.CaseBranchIndentation/index.js
var bind3 = /* @__PURE__ */ bind(bindArray);
var pure3 = /* @__PURE__ */ pure(applicativeArray);
var rule = function(v) {
  var onExpr = function(dictMonadRules) {
    var MonadReport3 = dictMonadRules.MonadReport3();
    var Applicative0 = MonadReport3.Monad0().Applicative0();
    var unless4 = unless(Applicative0);
    var reportViolation2 = reportViolation(MonadReport3);
    var pure114 = pure(Applicative0);
    return function(dictRangeOf) {
      var rangeOf5 = rangeOf(rangeOfSeparated(rangeOfBinder(dictRangeOf)));
      var rangeOf12 = rangeOf(rangeOfGuarded(dictRangeOf));
      var rangeOf22 = rangeOf(rangeOfWhere(dictRangeOf));
      return function(v1) {
        if (v1 instanceof ExprCase) {
          var isOneLine = function(v22) {
            return v22.value0.start.line === v22.value1.end.line;
          };
          var branchesAndGuards = bind3(toArray(v1.value0.branches))(function(v22) {
            if (v22.value1 instanceof Unconditional) {
              return pure3(new Tuple(rangeOf5(v22.value0), rangeOf12(v22.value1)));
            }
            ;
            if (v22.value1 instanceof Guarded) {
              return bind3(toArray(v22.value1.value0))(function(v3) {
                return pure3(new Tuple(v3.bar.range, rangeOf22(v3.where)));
              });
            }
            ;
            throw new Error("Failed pattern match at Whine.Core.CaseBranchIndentation (line 50, column 13 - line 55, column 66): " + [v22.value1.constructor.name]);
          });
          var v2 = partition(isOneLine)(branchesAndGuards);
          var smaller = function() {
            var $41 = length(v2.yes) <= length(v2.no);
            if ($41) {
              return v2.yes;
            }
            ;
            return v2.no;
          }();
          var consistentIndent = $$null(v2.yes) || $$null(v2.no);
          return unless4(consistentIndent)(reportViolation2({
            source: unionManyRanges(concatMap(function(v3) {
              return [v3.value0, v3.value1];
            })(smaller)),
            message: "Inconsistent indentation in case branches: keep either all single-line or all multi-line"
          }));
        }
        ;
        return pure114(unit);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleImport: emptyRule.onModuleImport,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onType: emptyRule.onType,
    onExpr
  };
};

// output/Whine.Core.CommaFirst/index.js
var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorMaybe);
var bind4 = /* @__PURE__ */ bind(bindArray);
var discard2 = /* @__PURE__ */ discard(discardUnit)(bindArray);
var guard2 = /* @__PURE__ */ guard(alternativeArray);
var pure4 = /* @__PURE__ */ pure(applicativeArray);
var or2 = /* @__PURE__ */ or(foldableArray)(heytingAlgebraBoolean);
var append3 = /* @__PURE__ */ append(semigroupArray);
var commaFirstRule = function(dictMonadRules) {
  var MonadReport3 = dictMonadRules.MonadReport3();
  var Applicative0 = MonadReport3.Monad0().Applicative0();
  var pure114 = pure(Applicative0);
  var for_2 = for_(Applicative0)(foldableMaybe);
  var reportViolation2 = reportViolation(MonadReport3);
  return function(v) {
    return function(v1) {
      return function(v2) {
        if (v.value instanceof Nothing) {
          return pure114(unit);
        }
        ;
        if (v.value instanceof Just) {
          var multiLine = v.open.range.start.line !== v.close.range.end.line;
          var lastItem = fromMaybe(v.value.value0.head)(mapFlipped2(last(v.value.value0.tail))(snd));
          var firstItem = new Tuple(v.open, v.value.value0.head);
          var newLineStartingItems = cons(firstItem)(bind4(zip(cons(firstItem)(v.value.value0.tail))(v.value.value0.tail))(function(v3) {
            return discard2(guard2(v1(v3.value0.value1).end.line < v1(v3.value1.value1).start.line))(function() {
              return pure4(new Tuple(v3.value1.value0, v3.value1.value1));
            });
          }));
          var misalignedPrefixes = bind4(newLineStartingItems)(function(v3) {
            return discard2(guard2(or2([v3.value0.range.end.line !== v1(v3.value1).start.line, v3.value0.range.end.column !== (v1(v3.value1).start.column - 1 | 0), v3.value0.range.start.column !== v.open.range.start.column])))(function() {
              return pure4({
                start: v3.value0.range.start,
                end: v1(v3.value1).end
              });
            });
          });
          var closeBracket = discard2(guard2(or2([v.close.range.start.line !== (v1(lastItem).end.line + 1 | 0), v.close.range.start.column !== v.open.range.start.column])))(function() {
            return pure4({
              start: v1(lastItem).end,
              end: v.close.range.end
            });
          });
          var violations = function() {
            if (multiLine) {
              return append3(misalignedPrefixes)(closeBracket);
            }
            ;
            if (otherwise) {
              return [];
            }
            ;
            throw new Error("Failed pattern match at Whine.Core.CommaFirst (line 24, column 5 - line 26, column 23): ");
          }();
          return for_2(unionManyRanges(violations))(function(range3) {
            return reportViolation2({
              source: new Just(range3),
              message: v2
            });
          });
        }
        ;
        throw new Error("Failed pattern match at Whine.Core.CommaFirst (line 9, column 1 - line 9, column 107): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  };
};

// output/Whine.Core.CommaFirstArrays/index.js
var rule2 = function(v) {
  var onExpr = function(dictMonadRules) {
    var commaFirstRule2 = commaFirstRule(dictMonadRules);
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      var rangeOf5 = rangeOf(rangeOfExpr(dictRangeOf));
      return function(v1) {
        if (v1 instanceof ExprArray) {
          return commaFirstRule2(v1.value0)(rangeOf5)("Format array literals comma-first, align items vertically");
        }
        ;
        return pure34(unit);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleImport: emptyRule.onModuleImport,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onType: emptyRule.onType,
    onExpr
  };
};

// output/Whine.Core.CommaFirstRecords/index.js
var rangeOf4 = /* @__PURE__ */ rangeOf(rangeOfName);
var rule3 = function(v) {
  var rangeOfRecordLabeled = function(dictRangeOf) {
    var rangeOf12 = rangeOf(rangeOfExpr(dictRangeOf));
    return function(v1) {
      if (v1 instanceof RecordPun) {
        return rangeOf4(v1.value0);
      }
      ;
      if (v1 instanceof RecordField) {
        return unionRanges(rangeOf4(v1.value0))(rangeOf12(v1.value2));
      }
      ;
      throw new Error("Failed pattern match at Whine.Core.CommaFirstRecords (line 62, column 28 - line 64, column 89): " + [v1.constructor.name]);
    };
  };
  var onExpr = function(dictMonadRules) {
    var commaFirstRule2 = commaFirstRule(dictMonadRules);
    var pure34 = pure(dictMonadRules.MonadReport3().Monad0().Applicative0());
    return function(dictRangeOf) {
      var rangeOfRecordLabeled1 = rangeOfRecordLabeled(dictRangeOf);
      return function(v1) {
        if (v1 instanceof ExprRecord) {
          return commaFirstRule2(v1.value0)(rangeOfRecordLabeled1)("Format record literals comma-first, align fields vertically");
        }
        ;
        return pure34(unit);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleImport: emptyRule.onModuleImport,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onType: emptyRule.onType,
    onExpr
  };
};

// output/Partial.Unsafe/foreign.js
var _unsafePartial = function(f) {
  return f();
};

// output/Partial/foreign.js
var _crashWith = function(msg) {
  throw new Error(msg);
};

// output/Partial/index.js
var crashWith = function() {
  return _crashWith;
};

// output/Partial.Unsafe/index.js
var crashWith2 = /* @__PURE__ */ crashWith();
var unsafePartial = _unsafePartial;
var unsafeCrashWith = function(msg) {
  return unsafePartial(function() {
    return crashWith2(msg);
  });
};

// output/Data.List.NonEmpty/index.js
var singleton11 = /* @__PURE__ */ function() {
  var $200 = singleton3(plusList);
  return function($201) {
    return NonEmptyList($200($201));
  };
}();

// output/Foreign.Object/foreign.js
function toArrayWithKey(f) {
  return function(m) {
    var r = [];
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r.push(f(k)(m[k]));
      }
    }
    return r;
  };
}
var keys3 = Object.keys || toArrayWithKey(function(k) {
  return function() {
    return k;
  };
});

// output/Data.Codec.JSON.Common/index.js
var functorExceptT2 = /* @__PURE__ */ functorExceptT(functorIdentity);
var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));
var map23 = /* @__PURE__ */ map(functorExceptT2);
var fromFoldable11 = /* @__PURE__ */ fromFoldable5(ordString)(foldableArray);
var applicativeExceptT3 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var traverse2 = /* @__PURE__ */ traverse(traversableArray)(applicativeExceptT3);
var traverse12 = /* @__PURE__ */ traverse(traversableTuple)(applicativeExceptT3);
var fromFoldableWithIndex3 = /* @__PURE__ */ fromFoldableWithIndex(foldableWithIndexMap);
var map32 = /* @__PURE__ */ map(functorMap);
var strMap = function(codec4) {
  return codec$prime(composeKleisliFlipped2(function() {
    var $61 = map23(fromFoldable11);
    var $62 = traverse2(traverse12(decode(codec4)));
    return function($63) {
      return $61($62(entries($63)));
    };
  }())(decode(jobject)))(function() {
    var $64 = encode2(jobject);
    var $65 = map32(encode2(codec4));
    return function($66) {
      return $64(fromFoldableWithIndex3($65($66)));
    };
  }());
};
var nonEmptyString = /* @__PURE__ */ prismaticCodec("NonEmptyString")(fromString4)(toString3)(string);

// output/Control.Monad.State.Trans/index.js
var StateT = function(x) {
  return x;
};
var runStateT = function(v) {
  return v;
};
var monadTransStateT = {
  lift: function(dictMonad) {
    var bind30 = bind(dictMonad.Bind1());
    var pure34 = pure(dictMonad.Applicative0());
    return function(m) {
      return function(s) {
        return bind30(m)(function(x) {
          return pure34(new Tuple(x, s));
        });
      };
    };
  }
};
var lift3 = /* @__PURE__ */ lift(monadTransStateT);
var functorStateT = function(dictFunctor) {
  var map47 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return function(s) {
          return map47(function(v1) {
            return new Tuple(f(v1.value0), v1.value1);
          })(v(s));
        };
      };
    }
  };
};
var evalStateT = function(dictFunctor) {
  var map47 = map(dictFunctor);
  return function(v) {
    return function(s) {
      return map47(fst)(v(s));
    };
  };
};
var monadStateT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeStateT(dictMonad);
    },
    Bind1: function() {
      return bindStateT(dictMonad);
    }
  };
};
var bindStateT = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  return {
    bind: function(v) {
      return function(f) {
        return function(s) {
          return bind30(v(s))(function(v1) {
            var v3 = f(v1.value0);
            return v3(v1.value1);
          });
        };
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var applyStateT = function(dictMonad) {
  var functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadStateT(dictMonad)),
    Functor0: function() {
      return functorStateT1;
    }
  };
};
var applicativeStateT = function(dictMonad) {
  var pure34 = pure(dictMonad.Applicative0());
  return {
    pure: function(a) {
      return function(s) {
        return pure34(new Tuple(a, s));
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var monadStateStateT = function(dictMonad) {
  var pure34 = pure(dictMonad.Applicative0());
  var monadStateT1 = monadStateT(dictMonad);
  return {
    state: function(f) {
      return function($206) {
        return pure34(f($206));
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};
var monadThrowStateT = function(dictMonadThrow) {
  var Monad0 = dictMonadThrow.Monad0();
  var lift13 = lift3(Monad0);
  var throwError7 = throwError(dictMonadThrow);
  var monadStateT1 = monadStateT(Monad0);
  return {
    throwError: function(e) {
      return lift13(throwError7(e));
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};

// output/Data.Codec.JSON.Strict/index.js
var monadExceptT2 = /* @__PURE__ */ monadExceptT(monadIdentity);
var bindStateT2 = /* @__PURE__ */ bindStateT(monadExceptT2);
var bind5 = /* @__PURE__ */ bind(bindStateT2);
var lift4 = /* @__PURE__ */ lift(monadTransStateT)(monadExceptT2);
var withExceptT2 = /* @__PURE__ */ withExceptT(functorIdentity);
var map16 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var pure5 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeStateT(monadExceptT2));
var discard3 = /* @__PURE__ */ discard(discardUnit);
var discard1 = /* @__PURE__ */ discard3(bindStateT2);
var modify_2 = /* @__PURE__ */ modify_(/* @__PURE__ */ monadStateStateT(monadExceptT2));
var insert4 = /* @__PURE__ */ insert3(ordString);
var monadThrowExceptT2 = /* @__PURE__ */ monadThrowExceptT(monadIdentity);
var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowStateT(monadThrowExceptT2));
var fromFoldable13 = /* @__PURE__ */ fromFoldable3(foldableList);
var bindExceptT3 = /* @__PURE__ */ bindExceptT(monadIdentity);
var bind1 = /* @__PURE__ */ bind(bindExceptT3);
var difference4 = /* @__PURE__ */ difference3(ordString);
var fromFoldable14 = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString);
var discard22 = /* @__PURE__ */ discard3(bindExceptT3);
var applicativeExceptT4 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var when3 = /* @__PURE__ */ when(applicativeExceptT4);
var not3 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var throwError1 = /* @__PURE__ */ throwError(monadThrowExceptT2);
var toUnfoldable7 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var pure22 = /* @__PURE__ */ pure(applicativeExceptT4);
var recordPropOptional2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var key = reflectSymbol2($$Proxy.value);
        var liftError = withPath(AtKey.create(key));
        var enc = function(val) {
          var r = encode(codecR)(val);
          var v = unsafeGet(key)(val);
          if (v instanceof Nothing) {
            return r;
          }
          ;
          if (v instanceof Just) {
            return new Cons(new Tuple(key, encode(codecA)(v.value0)), r);
          }
          ;
          throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 168, column 5 - line 170, column 59): " + [v.constructor.name]);
        };
        var dec = function(obj) {
          return bind5(decode(codecR)(obj))(function(r) {
            return bind5(function() {
              var v = lookup2(key)(obj);
              if (v instanceof Just) {
                return lift4(withExceptT2(liftError)(map16(Just.create)(decode(codecA)(v.value0))));
              }
              ;
              if (v instanceof Nothing) {
                return pure5(Nothing.value);
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 159, column 19 - line 161, column 29): " + [v.constructor.name]);
            }())(function(v) {
              return discard1(modify_2(insert4(key)))(function() {
                return pure5(unsafeSet(key)(v)(r));
              });
            });
          });
        };
        return codec(dec)(enc);
      };
    };
  };
};
var recordProp2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var key = reflectSymbol2($$Proxy.value);
        var liftError = withPath(AtKey.create(key));
        var enc = function(val) {
          return new Cons(new Tuple(key, encode(codecA)(unsafeGet(key)(val))), encode(codecR)(val));
        };
        var dec = function(obj) {
          return bind5(decode(codecR)(obj))(function(r) {
            return bind5(function() {
              var v = lookup2(key)(obj);
              if (v instanceof Just) {
                return lift4(withExceptT2(liftError)(decode(codecA)(v.value0)));
              }
              ;
              if (v instanceof Nothing) {
                return throwError2(noValueFound(new AtKey(key, Tip.value)));
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 126, column 13 - line 128, column 70): " + [v.constructor.name]);
            }())(function(v) {
              return discard1(modify_2(insert4(key)))(function() {
                return pure5(unsafeSet(key)(v)(r));
              });
            });
          });
        };
        return codec(dec)(enc);
      };
    };
  };
};
var record2 = /* @__PURE__ */ function() {
  return new Codec($$const(pure5({})), pure(applicativeTuple(monoidList)));
}();
var objectStrict = function(codec4) {
  var enc = function(a) {
    return encode(jobject)(fromFoldable13(encode(codec4)(a)));
  };
  var dec = function(j) {
    return bind1(decode(jobject)(j))(function(obj) {
      return bind1(runStateT(decode(codec4)(obj))(empty5))(function(v) {
        var unclaimedProps = difference4(fromFoldable14(keys(obj)))(v.value1);
        return discard22(when3(not3(isEmpty2)(unclaimedProps))(throwError1(error(Tip.value)("Unknown field(s): " + joinWith(", ")(toUnfoldable7(unclaimedProps))))))(function() {
          return pure22(v.value0);
        });
      });
    });
  };
  return codec$prime(dec)(enc);
};

// output/Record.Unsafe.Union/foreign.js
function unsafeUnionFn(r1, r2) {
  var copy = {};
  for (var k1 in r2) {
    if ({}.hasOwnProperty.call(r2, k1)) {
      copy[k1] = r2[k1];
    }
  }
  for (var k2 in r1) {
    if ({}.hasOwnProperty.call(r1, k2)) {
      copy[k2] = r1[k2];
    }
  }
  return copy;
}

// output/Record/index.js
var merge = function() {
  return function() {
    return function(l) {
      return function(r) {
        return unsafeUnionFn(l, r);
      };
    };
  };
};
var get2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(l) {
      return function(r) {
        return unsafeGet(reflectSymbol2(l))(r);
      };
    };
  };
};

// output/Data.Codec.JSON.Record/index.js
var rowListCodecNilRowRow = {
  rowListCodec: function(v) {
    return record;
  }
};
var rowListCodec = function(dict) {
  return dict.rowListCodec;
};
var rowListCodecConsCodec = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get3 = get2(dictIsSymbol)();
        var recordProp3 = recordProp(dictIsSymbol)();
        return {
          rowListCodec: function(codecs) {
            var tail2 = rowListCodec1(codecs);
            var codec4 = get3($$Proxy.value)(codecs);
            return recordProp3(codec4)(tail2);
          }
        };
      };
    };
  };
};
var record3 = function() {
  return function(dictRowListCodec) {
    return rowListCodec(dictRowListCodec);
  };
};
var record1 = /* @__PURE__ */ record3();
var object2 = function() {
  return function(dictRowListCodec) {
    var record22 = record1(dictRowListCodec);
    return function(rec) {
      return object(record22(rec));
    };
  };
};

// output/Type.Equality/index.js
var refl = {
  proof: function(a) {
    return a;
  },
  Coercible0: function() {
    return void 0;
  }
};

// output/Control.Monad.Reader.Trans/index.js
var ReaderT = function(x) {
  return x;
};
var withReaderT = function(f) {
  return function(v) {
    return function($152) {
      return v(f($152));
    };
  };
};
var runReaderT = function(v) {
  return v;
};
var monadTransReaderT = {
  lift: function(dictMonad) {
    return function($153) {
      return ReaderT($$const($153));
    };
  }
};
var lift5 = /* @__PURE__ */ lift(monadTransReaderT);
var mapReaderT = function(f) {
  return function(v) {
    return function($154) {
      return f(v($154));
    };
  };
};
var functorReaderT = function(dictFunctor) {
  return {
    map: function() {
      var $155 = map(dictFunctor);
      return function($156) {
        return mapReaderT($155($156));
      };
    }()
  };
};
var applyReaderT = function(dictApply) {
  var apply15 = apply(dictApply);
  var functorReaderT1 = functorReaderT(dictApply.Functor0());
  return {
    apply: function(v) {
      return function(v1) {
        return function(r) {
          return apply15(v(r))(v1(r));
        };
      };
    },
    Functor0: function() {
      return functorReaderT1;
    }
  };
};
var bindReaderT = function(dictBind) {
  var bind30 = bind(dictBind);
  var applyReaderT1 = applyReaderT(dictBind.Apply0());
  return {
    bind: function(v) {
      return function(k) {
        return function(r) {
          return bind30(v(r))(function(a) {
            var v1 = k(a);
            return v1(r);
          });
        };
      };
    },
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var applicativeReaderT = function(dictApplicative) {
  var applyReaderT1 = applyReaderT(dictApplicative.Apply0());
  return {
    pure: function() {
      var $160 = pure(dictApplicative);
      return function($161) {
        return ReaderT($$const($160($161)));
      };
    }(),
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var monadReaderT = function(dictMonad) {
  var applicativeReaderT1 = applicativeReaderT(dictMonad.Applicative0());
  var bindReaderT1 = bindReaderT(dictMonad.Bind1());
  return {
    Applicative0: function() {
      return applicativeReaderT1;
    },
    Bind1: function() {
      return bindReaderT1;
    }
  };
};
var monadAskReaderT = function(dictMonad) {
  var monadReaderT12 = monadReaderT(dictMonad);
  return {
    ask: pure(dictMonad.Applicative0()),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadEffectReader = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    liftEffect: function() {
      var $163 = lift5(Monad0);
      var $164 = liftEffect(dictMonadEffect);
      return function($165) {
        return $163($164($165));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};

// output/Data.Date/foreign.js
var createDate = function(y, m, d) {
  var date2 = new Date(Date.UTC(y, m, d));
  if (y >= 0 && y < 100) {
    date2.setUTCFullYear(y);
  }
  return date2;
};
function canonicalDateImpl(ctor, y, m, d) {
  var date2 = createDate(y, m - 1, d);
  return ctor(date2.getUTCFullYear())(date2.getUTCMonth() + 1)(date2.getUTCDate());
}
function calcWeekday(y, m, d) {
  return createDate(y, m - 1, d).getUTCDay();
}

// output/Data.Date.Component/index.js
var $runtime_lazy5 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var Monday = /* @__PURE__ */ function() {
  function Monday2() {
  }
  ;
  Monday2.value = new Monday2();
  return Monday2;
}();
var Tuesday = /* @__PURE__ */ function() {
  function Tuesday2() {
  }
  ;
  Tuesday2.value = new Tuesday2();
  return Tuesday2;
}();
var Wednesday = /* @__PURE__ */ function() {
  function Wednesday2() {
  }
  ;
  Wednesday2.value = new Wednesday2();
  return Wednesday2;
}();
var Thursday = /* @__PURE__ */ function() {
  function Thursday2() {
  }
  ;
  Thursday2.value = new Thursday2();
  return Thursday2;
}();
var Friday = /* @__PURE__ */ function() {
  function Friday2() {
  }
  ;
  Friday2.value = new Friday2();
  return Friday2;
}();
var Saturday = /* @__PURE__ */ function() {
  function Saturday2() {
  }
  ;
  Saturday2.value = new Saturday2();
  return Saturday2;
}();
var Sunday = /* @__PURE__ */ function() {
  function Sunday2() {
  }
  ;
  Sunday2.value = new Sunday2();
  return Sunday2;
}();
var January = /* @__PURE__ */ function() {
  function January2() {
  }
  ;
  January2.value = new January2();
  return January2;
}();
var February = /* @__PURE__ */ function() {
  function February2() {
  }
  ;
  February2.value = new February2();
  return February2;
}();
var March = /* @__PURE__ */ function() {
  function March2() {
  }
  ;
  March2.value = new March2();
  return March2;
}();
var April = /* @__PURE__ */ function() {
  function April2() {
  }
  ;
  April2.value = new April2();
  return April2;
}();
var May = /* @__PURE__ */ function() {
  function May2() {
  }
  ;
  May2.value = new May2();
  return May2;
}();
var June = /* @__PURE__ */ function() {
  function June2() {
  }
  ;
  June2.value = new June2();
  return June2;
}();
var July = /* @__PURE__ */ function() {
  function July2() {
  }
  ;
  July2.value = new July2();
  return July2;
}();
var August = /* @__PURE__ */ function() {
  function August2() {
  }
  ;
  August2.value = new August2();
  return August2;
}();
var September = /* @__PURE__ */ function() {
  function September2() {
  }
  ;
  September2.value = new September2();
  return September2;
}();
var October = /* @__PURE__ */ function() {
  function October2() {
  }
  ;
  October2.value = new October2();
  return October2;
}();
var November = /* @__PURE__ */ function() {
  function November2() {
  }
  ;
  November2.value = new November2();
  return November2;
}();
var December = /* @__PURE__ */ function() {
  function December2() {
  }
  ;
  December2.value = new December2();
  return December2;
}();
var showWeekday = {
  show: function(v) {
    if (v instanceof Monday) {
      return "Monday";
    }
    ;
    if (v instanceof Tuesday) {
      return "Tuesday";
    }
    ;
    if (v instanceof Wednesday) {
      return "Wednesday";
    }
    ;
    if (v instanceof Thursday) {
      return "Thursday";
    }
    ;
    if (v instanceof Friday) {
      return "Friday";
    }
    ;
    if (v instanceof Saturday) {
      return "Saturday";
    }
    ;
    if (v instanceof Sunday) {
      return "Sunday";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 184, column 1 - line 191, column 25): " + [v.constructor.name]);
  }
};
var showMonth = {
  show: function(v) {
    if (v instanceof January) {
      return "January";
    }
    ;
    if (v instanceof February) {
      return "February";
    }
    ;
    if (v instanceof March) {
      return "March";
    }
    ;
    if (v instanceof April) {
      return "April";
    }
    ;
    if (v instanceof May) {
      return "May";
    }
    ;
    if (v instanceof June) {
      return "June";
    }
    ;
    if (v instanceof July) {
      return "July";
    }
    ;
    if (v instanceof August) {
      return "August";
    }
    ;
    if (v instanceof September) {
      return "September";
    }
    ;
    if (v instanceof October) {
      return "October";
    }
    ;
    if (v instanceof November) {
      return "November";
    }
    ;
    if (v instanceof December) {
      return "December";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 101, column 1 - line 113, column 29): " + [v.constructor.name]);
  }
};
var ordYear = ordInt;
var ordDay = ordInt;
var eqWeekday = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return true;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return true;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return true;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return true;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return true;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return true;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordWeekday = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return EQ.value;
      }
      ;
      if (x instanceof Monday) {
        return LT.value;
      }
      ;
      if (y instanceof Monday) {
        return GT.value;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Tuesday) {
        return LT.value;
      }
      ;
      if (y instanceof Tuesday) {
        return GT.value;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Wednesday) {
        return LT.value;
      }
      ;
      if (y instanceof Wednesday) {
        return GT.value;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return EQ.value;
      }
      ;
      if (x instanceof Thursday) {
        return LT.value;
      }
      ;
      if (y instanceof Thursday) {
        return GT.value;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return EQ.value;
      }
      ;
      if (x instanceof Friday) {
        return LT.value;
      }
      ;
      if (y instanceof Friday) {
        return GT.value;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return EQ.value;
      }
      ;
      if (x instanceof Saturday) {
        return LT.value;
      }
      ;
      if (y instanceof Saturday) {
        return GT.value;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqWeekday;
  }
};
var eqMonth = {
  eq: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return true;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return true;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return true;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return true;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return true;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return true;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return true;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return true;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return true;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return true;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return true;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordMonth = {
  compare: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return EQ.value;
      }
      ;
      if (x instanceof January) {
        return LT.value;
      }
      ;
      if (y instanceof January) {
        return GT.value;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return EQ.value;
      }
      ;
      if (x instanceof February) {
        return LT.value;
      }
      ;
      if (y instanceof February) {
        return GT.value;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return EQ.value;
      }
      ;
      if (x instanceof March) {
        return LT.value;
      }
      ;
      if (y instanceof March) {
        return GT.value;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return EQ.value;
      }
      ;
      if (x instanceof April) {
        return LT.value;
      }
      ;
      if (y instanceof April) {
        return GT.value;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return EQ.value;
      }
      ;
      if (x instanceof May) {
        return LT.value;
      }
      ;
      if (y instanceof May) {
        return GT.value;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return EQ.value;
      }
      ;
      if (x instanceof June) {
        return LT.value;
      }
      ;
      if (y instanceof June) {
        return GT.value;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return EQ.value;
      }
      ;
      if (x instanceof July) {
        return LT.value;
      }
      ;
      if (y instanceof July) {
        return GT.value;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return EQ.value;
      }
      ;
      if (x instanceof August) {
        return LT.value;
      }
      ;
      if (y instanceof August) {
        return GT.value;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return EQ.value;
      }
      ;
      if (x instanceof September) {
        return LT.value;
      }
      ;
      if (y instanceof September) {
        return GT.value;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return EQ.value;
      }
      ;
      if (x instanceof October) {
        return LT.value;
      }
      ;
      if (y instanceof October) {
        return GT.value;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return EQ.value;
      }
      ;
      if (x instanceof November) {
        return LT.value;
      }
      ;
      if (y instanceof November) {
        return GT.value;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqMonth;
  }
};
var boundedYear = /* @__PURE__ */ function() {
  return {
    bottom: -271820 | 0,
    top: 275759,
    Ord0: function() {
      return ordYear;
    }
  };
}();
var boundedWeekday = /* @__PURE__ */ function() {
  return {
    bottom: Monday.value,
    top: Sunday.value,
    Ord0: function() {
      return ordWeekday;
    }
  };
}();
var boundedMonth = /* @__PURE__ */ function() {
  return {
    bottom: January.value,
    top: December.value,
    Ord0: function() {
      return ordMonth;
    }
  };
}();
var boundedEnumYear = {
  cardinality: 547580,
  toEnum: function(n) {
    if (n >= (-271820 | 0) && n <= 275759) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 35, column 1 - line 40, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedYear;
  },
  Enum1: function() {
    return $lazy_enumYear(0);
  }
};
var $lazy_enumYear = /* @__PURE__ */ $runtime_lazy5("enumYear", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $55 = toEnum(boundedEnumYear);
      var $56 = fromEnum(boundedEnumYear);
      return function($57) {
        return $55(function(v) {
          return v + 1 | 0;
        }($56($57)));
      };
    }(),
    pred: function() {
      var $58 = toEnum(boundedEnumYear);
      var $59 = fromEnum(boundedEnumYear);
      return function($60) {
        return $58(function(v) {
          return v - 1 | 0;
        }($59($60)));
      };
    }(),
    Ord0: function() {
      return ordYear;
    }
  };
});
var boundedEnumWeekday = {
  cardinality: 7,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(Monday.value);
    }
    ;
    if (v === 2) {
      return new Just(Tuesday.value);
    }
    ;
    if (v === 3) {
      return new Just(Wednesday.value);
    }
    ;
    if (v === 4) {
      return new Just(Thursday.value);
    }
    ;
    if (v === 5) {
      return new Just(Friday.value);
    }
    ;
    if (v === 6) {
      return new Just(Saturday.value);
    }
    ;
    if (v === 7) {
      return new Just(Sunday.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Monday) {
      return 1;
    }
    ;
    if (v instanceof Tuesday) {
      return 2;
    }
    ;
    if (v instanceof Wednesday) {
      return 3;
    }
    ;
    if (v instanceof Thursday) {
      return 4;
    }
    ;
    if (v instanceof Friday) {
      return 5;
    }
    ;
    if (v instanceof Saturday) {
      return 6;
    }
    ;
    if (v instanceof Sunday) {
      return 7;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 175, column 14 - line 182, column 16): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedWeekday;
  },
  Enum1: function() {
    return $lazy_enumWeekday(0);
  }
};
var $lazy_enumWeekday = /* @__PURE__ */ $runtime_lazy5("enumWeekday", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $61 = toEnum(boundedEnumWeekday);
      var $62 = fromEnum(boundedEnumWeekday);
      return function($63) {
        return $61(function(v) {
          return v + 1 | 0;
        }($62($63)));
      };
    }(),
    pred: function() {
      var $64 = toEnum(boundedEnumWeekday);
      var $65 = fromEnum(boundedEnumWeekday);
      return function($66) {
        return $64(function(v) {
          return v - 1 | 0;
        }($65($66)));
      };
    }(),
    Ord0: function() {
      return ordWeekday;
    }
  };
});
var boundedEnumMonth = {
  cardinality: 12,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(January.value);
    }
    ;
    if (v === 2) {
      return new Just(February.value);
    }
    ;
    if (v === 3) {
      return new Just(March.value);
    }
    ;
    if (v === 4) {
      return new Just(April.value);
    }
    ;
    if (v === 5) {
      return new Just(May.value);
    }
    ;
    if (v === 6) {
      return new Just(June.value);
    }
    ;
    if (v === 7) {
      return new Just(July.value);
    }
    ;
    if (v === 8) {
      return new Just(August.value);
    }
    ;
    if (v === 9) {
      return new Just(September.value);
    }
    ;
    if (v === 10) {
      return new Just(October.value);
    }
    ;
    if (v === 11) {
      return new Just(November.value);
    }
    ;
    if (v === 12) {
      return new Just(December.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof January) {
      return 1;
    }
    ;
    if (v instanceof February) {
      return 2;
    }
    ;
    if (v instanceof March) {
      return 3;
    }
    ;
    if (v instanceof April) {
      return 4;
    }
    ;
    if (v instanceof May) {
      return 5;
    }
    ;
    if (v instanceof June) {
      return 6;
    }
    ;
    if (v instanceof July) {
      return 7;
    }
    ;
    if (v instanceof August) {
      return 8;
    }
    ;
    if (v instanceof September) {
      return 9;
    }
    ;
    if (v instanceof October) {
      return 10;
    }
    ;
    if (v instanceof November) {
      return 11;
    }
    ;
    if (v instanceof December) {
      return 12;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 87, column 14 - line 99, column 19): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedMonth;
  },
  Enum1: function() {
    return $lazy_enumMonth(0);
  }
};
var $lazy_enumMonth = /* @__PURE__ */ $runtime_lazy5("enumMonth", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $67 = toEnum(boundedEnumMonth);
      var $68 = fromEnum(boundedEnumMonth);
      return function($69) {
        return $67(function(v) {
          return v + 1 | 0;
        }($68($69)));
      };
    }(),
    pred: function() {
      var $70 = toEnum(boundedEnumMonth);
      var $71 = fromEnum(boundedEnumMonth);
      return function($72) {
        return $70(function(v) {
          return v - 1 | 0;
        }($71($72)));
      };
    }(),
    Ord0: function() {
      return ordMonth;
    }
  };
});
var boundedDay = {
  bottom: 1,
  top: 31,
  Ord0: function() {
    return ordDay;
  }
};
var boundedEnumDay = {
  cardinality: 31,
  toEnum: function(n) {
    if (n >= 1 && n <= 31) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 133, column 1 - line 138, column 23): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedDay;
  },
  Enum1: function() {
    return $lazy_enumDay(0);
  }
};
var $lazy_enumDay = /* @__PURE__ */ $runtime_lazy5("enumDay", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $73 = toEnum(boundedEnumDay);
      var $74 = fromEnum(boundedEnumDay);
      return function($75) {
        return $73(function(v) {
          return v + 1 | 0;
        }($74($75)));
      };
    }(),
    pred: function() {
      var $76 = toEnum(boundedEnumDay);
      var $77 = fromEnum(boundedEnumDay);
      return function($78) {
        return $76(function(v) {
          return v - 1 | 0;
        }($77($78)));
      };
    }(),
    Ord0: function() {
      return ordDay;
    }
  };
});

// output/Data.Date/index.js
var fromEnum3 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromJust6 = /* @__PURE__ */ fromJust();
var toEnum2 = /* @__PURE__ */ toEnum(boundedEnumWeekday);
var toEnum22 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var $$Date = /* @__PURE__ */ function() {
  function $$Date2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  $$Date2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new $$Date2(value0, value12, value22);
      };
    };
  };
  return $$Date2;
}();
var year = function(v) {
  return v.value0;
};
var weekday = function(v) {
  var n = calcWeekday(v.value0, fromEnum3(v.value1), v.value2);
  var $86 = n === 0;
  if ($86) {
    return fromJust6(toEnum2(7));
  }
  ;
  return fromJust6(toEnum2(n));
};
var month = function(v) {
  return v.value1;
};
var day = function(v) {
  return v.value2;
};
var canonicalDate = function(y) {
  return function(m) {
    return function(d) {
      var mkDate = function(y$prime) {
        return function(m$prime) {
          return function(d$prime) {
            return new $$Date(y$prime, fromJust6(toEnum22(m$prime)), d$prime);
          };
        };
      };
      return canonicalDateImpl(mkDate, y, fromEnum3(m), d);
    };
  };
};

// output/Data.Time.Component/index.js
var $runtime_lazy6 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var ordSecond = ordInt;
var ordMinute = ordInt;
var ordMillisecond = ordInt;
var ordHour = ordInt;
var boundedSecond = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordSecond;
  }
};
var boundedMinute = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordMinute;
  }
};
var boundedMillisecond = {
  bottom: 0,
  top: 999,
  Ord0: function() {
    return ordMillisecond;
  }
};
var boundedHour = {
  bottom: 0,
  top: 23,
  Ord0: function() {
    return ordHour;
  }
};
var boundedEnumSecond = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 90, column 1 - line 95, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedSecond;
  },
  Enum1: function() {
    return $lazy_enumSecond(0);
  }
};
var $lazy_enumSecond = /* @__PURE__ */ $runtime_lazy6("enumSecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $36 = toEnum(boundedEnumSecond);
      var $37 = fromEnum(boundedEnumSecond);
      return function($38) {
        return $36(function(v) {
          return v + 1 | 0;
        }($37($38)));
      };
    }(),
    pred: function() {
      var $39 = toEnum(boundedEnumSecond);
      var $40 = fromEnum(boundedEnumSecond);
      return function($41) {
        return $39(function(v) {
          return v - 1 | 0;
        }($40($41)));
      };
    }(),
    Ord0: function() {
      return ordSecond;
    }
  };
});
var boundedEnumMinute = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 61, column 1 - line 66, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMinute;
  },
  Enum1: function() {
    return $lazy_enumMinute(0);
  }
};
var $lazy_enumMinute = /* @__PURE__ */ $runtime_lazy6("enumMinute", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $42 = toEnum(boundedEnumMinute);
      var $43 = fromEnum(boundedEnumMinute);
      return function($44) {
        return $42(function(v) {
          return v + 1 | 0;
        }($43($44)));
      };
    }(),
    pred: function() {
      var $45 = toEnum(boundedEnumMinute);
      var $46 = fromEnum(boundedEnumMinute);
      return function($47) {
        return $45(function(v) {
          return v - 1 | 0;
        }($46($47)));
      };
    }(),
    Ord0: function() {
      return ordMinute;
    }
  };
});
var boundedEnumMillisecond = {
  cardinality: 1e3,
  toEnum: function(n) {
    if (n >= 0 && n <= 999) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 120, column 1 - line 125, column 31): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMillisecond;
  },
  Enum1: function() {
    return $lazy_enumMillisecond(0);
  }
};
var $lazy_enumMillisecond = /* @__PURE__ */ $runtime_lazy6("enumMillisecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $48 = toEnum(boundedEnumMillisecond);
      var $49 = fromEnum(boundedEnumMillisecond);
      return function($50) {
        return $48(function(v) {
          return v + 1 | 0;
        }($49($50)));
      };
    }(),
    pred: function() {
      var $51 = toEnum(boundedEnumMillisecond);
      var $52 = fromEnum(boundedEnumMillisecond);
      return function($53) {
        return $51(function(v) {
          return v - 1 | 0;
        }($52($53)));
      };
    }(),
    Ord0: function() {
      return ordMillisecond;
    }
  };
});
var boundedEnumHour = {
  cardinality: 24,
  toEnum: function(n) {
    if (n >= 0 && n <= 23) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 32, column 1 - line 37, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedHour;
  },
  Enum1: function() {
    return $lazy_enumHour(0);
  }
};
var $lazy_enumHour = /* @__PURE__ */ $runtime_lazy6("enumHour", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $54 = toEnum(boundedEnumHour);
      var $55 = fromEnum(boundedEnumHour);
      return function($56) {
        return $54(function(v) {
          return v + 1 | 0;
        }($55($56)));
      };
    }(),
    pred: function() {
      var $57 = toEnum(boundedEnumHour);
      var $58 = fromEnum(boundedEnumHour);
      return function($59) {
        return $57(function(v) {
          return v - 1 | 0;
        }($58($59)));
      };
    }(),
    Ord0: function() {
      return ordHour;
    }
  };
});

// output/Data.Time/index.js
var Time = /* @__PURE__ */ function() {
  function Time2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  Time2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new Time2(value0, value12, value22, value3);
        };
      };
    };
  };
  return Time2;
}();
var second = function(v) {
  return v.value2;
};
var minute = function(v) {
  return v.value1;
};
var millisecond = function(v) {
  return v.value3;
};
var hour = function(v) {
  return v.value0;
};

// output/Data.DateTime/index.js
var DateTime = /* @__PURE__ */ function() {
  function DateTime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DateTime2.create = function(value0) {
    return function(value12) {
      return new DateTime2(value0, value12);
    };
  };
  return DateTime2;
}();

// output/Data.DateTime.Instant/foreign.js
var createDateTime = function(y, m, d, h, mi, s, ms) {
  var dateTime = new Date(Date.UTC(y, m, d, h, mi, s, ms));
  if (y >= 0 && y < 100) {
    dateTime.setUTCFullYear(y);
  }
  return dateTime;
};
function fromDateTimeImpl(y, mo, d, h, mi, s, ms) {
  return createDateTime(y, mo - 1, d, h, mi, s, ms).getTime();
}
function toDateTimeImpl(ctor) {
  return function(instant2) {
    var dt = new Date(instant2);
    return ctor(dt.getUTCFullYear())(dt.getUTCMonth() + 1)(dt.getUTCDate())(dt.getUTCHours())(dt.getUTCMinutes())(dt.getUTCSeconds())(dt.getUTCMilliseconds());
  };
}

// output/Data.DateTime.Instant/index.js
var fromJust7 = /* @__PURE__ */ fromJust();
var toEnum3 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var fromEnum4 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var unInstant = function(v) {
  return v;
};
var toDateTime = /* @__PURE__ */ function() {
  var mkDateTime = function(y) {
    return function(mo) {
      return function(d) {
        return function(h) {
          return function(mi) {
            return function(s) {
              return function(ms) {
                return new DateTime(canonicalDate(y)(fromJust7(toEnum3(mo)))(d), new Time(h, mi, s, ms));
              };
            };
          };
        };
      };
    };
  };
  return toDateTimeImpl(mkDateTime);
}();
var fromDateTime = function(v) {
  return fromDateTimeImpl(year(v.value0), fromEnum4(month(v.value0)), day(v.value0), hour(v.value1), minute(v.value1), second(v.value1), millisecond(v.value1));
};

// output/Data.Lazy/foreign.js
var defer2 = function(thunk) {
  var v = null;
  return function() {
    if (thunk === void 0) return v;
    v = thunk();
    thunk = void 0;
    return v;
  };
};
var force = function(l) {
  return l();
};

// output/Data.Lazy/index.js
var functorLazy = {
  map: function(f) {
    return function(l) {
      return defer2(function(v) {
        return f(force(l));
      });
    };
  }
};
var applyLazy = {
  apply: function(f) {
    return function(x) {
      return defer2(function(v) {
        return force(f)(force(x));
      });
    };
  },
  Functor0: function() {
    return functorLazy;
  }
};
var bindLazy = {
  bind: function(l) {
    return function(f) {
      return defer2(function(v) {
        return force(f(force(l)));
      });
    };
  },
  Apply0: function() {
    return applyLazy;
  }
};

// output/Parsing/index.js
var unwrap5 = /* @__PURE__ */ unwrap();
var ParseState = /* @__PURE__ */ function() {
  function ParseState2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ParseState2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ParseState2(value0, value12, value22);
      };
    };
  };
  return ParseState2;
}();
var ParseError = /* @__PURE__ */ function() {
  function ParseError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseError2.create = function(value0) {
    return function(value12) {
      return new ParseError2(value0, value12);
    };
  };
  return ParseError2;
}();
var More = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Lift = /* @__PURE__ */ function() {
  function Lift2(value0) {
    this.value0 = value0;
  }
  ;
  Lift2.create = function(value0) {
    return new Lift2(value0);
  };
  return Lift2;
}();
var Stop = /* @__PURE__ */ function() {
  function Stop2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Stop2.create = function(value0) {
    return function(value12) {
      return new Stop2(value0, value12);
    };
  };
  return Stop2;
}();
var functorParserT = {
  map: function(f) {
    return function(v) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift13, $$throw2, function(state2, a) {
            return more(function(v2) {
              return done(state2, f(a));
            });
          });
        });
      };
    };
  }
};
var applyParserT = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v2) {
          return v(state1, more, lift13, $$throw2, function(state2, f) {
            return more(function(v3) {
              return v1(state2, more, lift13, $$throw2, function(state3, a) {
                return more(function(v4) {
                  return done(state3, f(a));
                });
              });
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var bindParserT = {
  bind: function(v) {
    return function(next2) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift13, $$throw2, function(state2, a) {
            return more(function(v2) {
              var v3 = next2(a);
              return v3(state2, more, lift13, $$throw2, done);
            });
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindParserT);
var applicativeParserT = {
  pure: function(a) {
    return function(state1, v, v1, v2, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var monadParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Bind1: function() {
    return bindParserT;
  }
};
var monadThrowParseErrorParse = {
  throwError: function(err) {
    return function(state1, v, v1, $$throw2, v2) {
      return $$throw2(state1, err);
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var throwError3 = /* @__PURE__ */ throwError(monadThrowParseErrorParse);
var altParserT = {
  alt: function(v) {
    return function(v1) {
      return function(v2, more, lift13, $$throw2, done) {
        return more(function(v3) {
          return v(new ParseState(v2.value0, v2.value1, false), more, lift13, function(v4, err) {
            return more(function(v5) {
              if (v4.value2) {
                return $$throw2(v4, err);
              }
              ;
              return v1(v2, more, lift13, $$throw2, done);
            });
          }, done);
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var stateParserT = function(k) {
  return function(state1, v, v1, v2, done) {
    var v3 = k(state1);
    return done(v3.value1, v3.value0);
  };
};
var runParserT$prime = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var map47 = map(Monad0.Bind1().Apply0().Functor0());
  var pure114 = pure(Monad0.Applicative0());
  var tailRecM4 = tailRecM(dictMonadRec);
  return function(state1) {
    return function(v) {
      var go = function($copy_step) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(step3) {
          var v1 = step3(unit);
          if (v1 instanceof More) {
            $copy_step = v1.value0;
            return;
          }
          ;
          if (v1 instanceof Lift) {
            $tco_done = true;
            return map47(Loop.create)(v1.value0);
          }
          ;
          if (v1 instanceof Stop) {
            $tco_done = true;
            return pure114(new Done(new Tuple(v1.value1, v1.value0)));
          }
          ;
          throw new Error("Failed pattern match at Parsing (line 152, column 13 - line 158, column 32): " + [v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_step);
        }
        ;
        return $tco_result;
      };
      return tailRecM4(go)(function(v1) {
        return v(state1, More.create, Lift.create, function(state2, err) {
          return new Stop(state2, new Left(err));
        }, function(state2, res) {
          return new Stop(state2, new Right(res));
        });
      });
    };
  };
};
var position = /* @__PURE__ */ stateParserT(function(v) {
  return new Tuple(v.value1, v);
});
var initialPos = {
  index: 0,
  line: 1,
  column: 1
};
var runParserT = function(dictMonadRec) {
  var map47 = map(dictMonadRec.Monad0().Bind1().Apply0().Functor0());
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(s) {
    return function(p) {
      var initialState = new ParseState(s, initialPos, false);
      return map47(fst)(runParserT$prime1(initialState)(p));
    };
  };
};
var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
var runParser = function(s) {
  var $281 = runParserT1(s);
  return function($282) {
    return unwrap5($281($282));
  };
};
var failWithPosition = function(message2) {
  return function(pos) {
    return throwError3(new ParseError(message2, pos));
  };
};
var fail2 = function(message2) {
  return bindFlipped2(failWithPosition(message2))(position);
};

// output/Parsing.Combinators/index.js
var alt2 = /* @__PURE__ */ alt(altParserT);
var withErrorMessage = function(p) {
  return function(msg) {
    return alt2(p)(fail2("Expected " + msg));
  };
};
var tryRethrow = function(v) {
  return function(v1, more, lift8, $$throw2, done) {
    return v(v1, more, lift8, function(v2, v3) {
      return $$throw2(new ParseState(v2.value0, v2.value1, v1.value2), new ParseError(v3.value0, v1.value1));
    }, done);
  };
};

// output/Data.String.Regex/foreign.js
var regexImpl = function(left) {
  return function(right) {
    return function(s1) {
      return function(s2) {
        try {
          return right(new RegExp(s1, s2));
        } catch (e) {
          return left(e.message);
        }
      };
    };
  };
};
var _match = function(just) {
  return function(nothing) {
    return function(r) {
      return function(s) {
        var m = s.match(r);
        if (m == null || m.length === 0) {
          return nothing;
        } else {
          for (var i = 0; i < m.length; i++) {
            m[i] = m[i] == null ? nothing : just(m[i]);
          }
          return just(m);
        }
      };
    };
  };
};
var split2 = function(r) {
  return function(s) {
    return s.split(r);
  };
};

// output/Data.String.Regex.Flags/index.js
var unicode = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: true
};
var semigroupRegexFlags = {
  append: function(v) {
    return function(v1) {
      return {
        global: v.global || v1.global,
        ignoreCase: v.ignoreCase || v1.ignoreCase,
        multiline: v.multiline || v1.multiline,
        dotAll: v.dotAll || v1.dotAll,
        sticky: v.sticky || v1.sticky,
        unicode: v.unicode || v1.unicode
      };
    };
  }
};
var noFlags = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var monoidRegexFlags = {
  mempty: noFlags,
  Semigroup0: function() {
    return semigroupRegexFlags;
  }
};

// output/Data.String.Regex/index.js
var renderFlags = function(v) {
  return function() {
    if (v.global) {
      return "g";
    }
    ;
    return "";
  }() + (function() {
    if (v.ignoreCase) {
      return "i";
    }
    ;
    return "";
  }() + (function() {
    if (v.multiline) {
      return "m";
    }
    ;
    return "";
  }() + (function() {
    if (v.dotAll) {
      return "s";
    }
    ;
    return "";
  }() + (function() {
    if (v.sticky) {
      return "y";
    }
    ;
    return "";
  }() + function() {
    if (v.unicode) {
      return "u";
    }
    ;
    return "";
  }()))));
};
var regex = function(s) {
  return function(f) {
    return regexImpl(Left.create)(Right.create)(s)(renderFlags(f));
  };
};
var match = /* @__PURE__ */ function() {
  return _match(Just.create)(Nothing.value);
}();

// output/Parsing.String/index.js
var fromEnum5 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
var fromJust8 = /* @__PURE__ */ fromJust();
var toEnum4 = /* @__PURE__ */ toEnum(boundedEnumChar);
var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEither);
var map17 = /* @__PURE__ */ map(functorMaybe);
var show12 = /* @__PURE__ */ show(showString);
var show2 = /* @__PURE__ */ show(showChar);
var updatePosSingle = function(v) {
  return function(cp) {
    return function(after) {
      var v1 = fromEnum5(cp);
      if (v1 === 10) {
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 13) {
        var v2 = codePointAt(0)(after);
        if (v2 instanceof Just && fromEnum5(v2.value0) === 10) {
          return {
            index: v.index + 1 | 0,
            line: v.line,
            column: v.column
          };
        }
        ;
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 9) {
        return {
          index: v.index + 1 | 0,
          line: v.line,
          column: (v.column + 8 | 0) - mod3(v.column - 1 | 0)(8) | 0
        };
      }
      ;
      return {
        index: v.index + 1 | 0,
        line: v.line,
        column: v.column + 1 | 0
      };
    };
  };
};
var updatePosString = function($copy_pos) {
  return function($copy_before) {
    return function($copy_after) {
      var $tco_var_pos = $copy_pos;
      var $tco_var_before = $copy_before;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(pos, before, after) {
        var v = uncons3(before);
        if (v instanceof Nothing) {
          $tco_done = true;
          return pos;
        }
        ;
        if (v instanceof Just) {
          var newPos = function() {
            if ($$null2(v.value0.tail)) {
              return updatePosSingle(pos)(v.value0.head)(after);
            }
            ;
            if (otherwise) {
              return updatePosSingle(pos)(v.value0.head)(v.value0.tail);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 165, column 7 - line 167, column 52): ");
          }();
          $tco_var_pos = newPos;
          $tco_var_before = v.value0.tail;
          $copy_after = after;
          return;
        }
        ;
        throw new Error("Failed pattern match at Parsing.String (line 161, column 36 - line 168, column 38): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_pos, $tco_var_before, $copy_after);
      }
      ;
      return $tco_result;
    };
  };
};
var satisfy = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = uncons3(v.value0);
            if (v3 instanceof Nothing) {
              return $$throw2(v, new ParseError("Unexpected EOF", v.value1));
            }
            ;
            if (v3 instanceof Just) {
              var cp = fromEnum5(v3.value0.head);
              var $85 = cp < 0 || cp > 65535;
              if ($85) {
                return $$throw2(v, new ParseError("Expected Char", v.value1));
              }
              ;
              var ch = fromJust8(toEnum4(cp));
              var $86 = f(ch);
              if ($86) {
                return done(new ParseState(v3.value0.tail, updatePosSingle(v.value1)(v3.value0.head)(v3.value0.tail), true), ch);
              }
              ;
              return $$throw2(v, new ParseError("Predicate unsatisfied", v.value1));
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 114, column 7 - line 129, column 75): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var consumeWith = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = f(v.value0);
            if (v3 instanceof Left) {
              return $$throw2(v, new ParseError(v3.value0, v.value1));
            }
            ;
            if (v3 instanceof Right) {
              return done(new ParseState(v3.value0.remainder, updatePosString(v.value1)(v3.value0.consumed)(v3.value0.remainder), !$$null2(v3.value0.consumed)), v3.value0.value);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 286, column 7 - line 290, column 121): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var regex2 = function(pattern) {
  return function(flags) {
    return mapFlipped3(regex("^(" + (pattern + ")"))(flags))(function(regexobj) {
      return consumeWith(function(input) {
        var v = map17(head2)(match(regexobj)(input));
        if (v instanceof Just && v.value0 instanceof Just) {
          var remainder2 = drop2(length4(v.value0.value0))(input);
          return new Right({
            value: v.value0.value0,
            consumed: v.value0.value0,
            remainder: remainder2
          });
        }
        ;
        return new Left("No Regex pattern match");
      });
    });
  };
};
var string2 = function(str2) {
  return consumeWith(function(input) {
    var v = stripPrefix2(str2)(input);
    if (v instanceof Just) {
      return new Right({
        value: str2,
        consumed: str2,
        remainder: v.value0
      });
    }
    ;
    return new Left("Expected " + show12(str2));
  });
};
var $$char2 = function(c) {
  return withErrorMessage(satisfy(function(v) {
    return v === c;
  }))(show2(c));
};

// output/Data.Char/index.js
var fromCharCode3 = /* @__PURE__ */ toEnum(boundedEnumChar);

// output/Parsing.String.Basic/index.js
var identity8 = /* @__PURE__ */ identity(categoryFn);
var mempty2 = /* @__PURE__ */ mempty(monoidRegexFlags);
var alt3 = /* @__PURE__ */ alt(altParserT);
var pure6 = /* @__PURE__ */ pure(applicativeParserT);
var bind6 = /* @__PURE__ */ bind(bindParserT);
var intDecimalRegex = /* @__PURE__ */ either(unsafeCrashWith)(identity8)(/* @__PURE__ */ regex2("[+-]?[0-9]+")(mempty2));
var intDecimal = /* @__PURE__ */ tryRethrow(/* @__PURE__ */ bind6(/* @__PURE__ */ alt3(intDecimalRegex)(/* @__PURE__ */ fail2("Expected Int")))(function(section) {
  var v = fromString3(section);
  if (v instanceof Nothing) {
    return fail2("Expected Int");
  }
  ;
  if (v instanceof Just) {
    return pure6(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Parsing.String.Basic (line 140, column 3 - line 142, column 21): " + [v.constructor.name]);
}));

// output/Data.Formatter.DateTime/index.js
var show3 = /* @__PURE__ */ show(showInt);
var foldMap2 = /* @__PURE__ */ foldMap(foldableList);
var foldMap12 = /* @__PURE__ */ foldMap2(monoidString);
var abs3 = /* @__PURE__ */ abs(ordInt)(ringInt);
var fromEnum6 = /* @__PURE__ */ fromEnum(boundedEnumYear);
var show13 = /* @__PURE__ */ show(showMonth);
var fromEnum1 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromEnum22 = /* @__PURE__ */ fromEnum(boundedEnumDay);
var unwrap6 = /* @__PURE__ */ unwrap();
var fromEnum32 = /* @__PURE__ */ fromEnum(boundedEnumWeekday);
var show22 = /* @__PURE__ */ show(showWeekday);
var fromEnum42 = /* @__PURE__ */ fromEnum(boundedEnumHour);
var mod4 = /* @__PURE__ */ mod(euclideanRingInt);
var fromEnum52 = /* @__PURE__ */ fromEnum(boundedEnumMinute);
var fromEnum62 = /* @__PURE__ */ fromEnum(boundedEnumSecond);
var fromEnum7 = /* @__PURE__ */ fromEnum(boundedEnumMillisecond);
var div1 = /* @__PURE__ */ div(euclideanRingInt);
var YearFull = /* @__PURE__ */ function() {
  function YearFull2() {
  }
  ;
  YearFull2.value = new YearFull2();
  return YearFull2;
}();
var YearTwoDigits = /* @__PURE__ */ function() {
  function YearTwoDigits2() {
  }
  ;
  YearTwoDigits2.value = new YearTwoDigits2();
  return YearTwoDigits2;
}();
var YearAbsolute = /* @__PURE__ */ function() {
  function YearAbsolute2() {
  }
  ;
  YearAbsolute2.value = new YearAbsolute2();
  return YearAbsolute2;
}();
var MonthFull = /* @__PURE__ */ function() {
  function MonthFull2() {
  }
  ;
  MonthFull2.value = new MonthFull2();
  return MonthFull2;
}();
var MonthShort = /* @__PURE__ */ function() {
  function MonthShort2() {
  }
  ;
  MonthShort2.value = new MonthShort2();
  return MonthShort2;
}();
var MonthTwoDigits = /* @__PURE__ */ function() {
  function MonthTwoDigits2() {
  }
  ;
  MonthTwoDigits2.value = new MonthTwoDigits2();
  return MonthTwoDigits2;
}();
var DayOfMonthTwoDigits = /* @__PURE__ */ function() {
  function DayOfMonthTwoDigits2() {
  }
  ;
  DayOfMonthTwoDigits2.value = new DayOfMonthTwoDigits2();
  return DayOfMonthTwoDigits2;
}();
var DayOfMonth = /* @__PURE__ */ function() {
  function DayOfMonth2() {
  }
  ;
  DayOfMonth2.value = new DayOfMonth2();
  return DayOfMonth2;
}();
var UnixTimestamp = /* @__PURE__ */ function() {
  function UnixTimestamp2() {
  }
  ;
  UnixTimestamp2.value = new UnixTimestamp2();
  return UnixTimestamp2;
}();
var DayOfWeek = /* @__PURE__ */ function() {
  function DayOfWeek2() {
  }
  ;
  DayOfWeek2.value = new DayOfWeek2();
  return DayOfWeek2;
}();
var DayOfWeekName = /* @__PURE__ */ function() {
  function DayOfWeekName2() {
  }
  ;
  DayOfWeekName2.value = new DayOfWeekName2();
  return DayOfWeekName2;
}();
var DayOfWeekNameShort = /* @__PURE__ */ function() {
  function DayOfWeekNameShort2() {
  }
  ;
  DayOfWeekNameShort2.value = new DayOfWeekNameShort2();
  return DayOfWeekNameShort2;
}();
var Hours24 = /* @__PURE__ */ function() {
  function Hours242() {
  }
  ;
  Hours242.value = new Hours242();
  return Hours242;
}();
var Hours12 = /* @__PURE__ */ function() {
  function Hours122() {
  }
  ;
  Hours122.value = new Hours122();
  return Hours122;
}();
var Meridiem = /* @__PURE__ */ function() {
  function Meridiem2() {
  }
  ;
  Meridiem2.value = new Meridiem2();
  return Meridiem2;
}();
var Minutes = /* @__PURE__ */ function() {
  function Minutes2() {
  }
  ;
  Minutes2.value = new Minutes2();
  return Minutes2;
}();
var MinutesTwoDigits = /* @__PURE__ */ function() {
  function MinutesTwoDigits2() {
  }
  ;
  MinutesTwoDigits2.value = new MinutesTwoDigits2();
  return MinutesTwoDigits2;
}();
var Seconds = /* @__PURE__ */ function() {
  function Seconds2() {
  }
  ;
  Seconds2.value = new Seconds2();
  return Seconds2;
}();
var SecondsTwoDigits = /* @__PURE__ */ function() {
  function SecondsTwoDigits2() {
  }
  ;
  SecondsTwoDigits2.value = new SecondsTwoDigits2();
  return SecondsTwoDigits2;
}();
var Milliseconds = /* @__PURE__ */ function() {
  function Milliseconds3() {
  }
  ;
  Milliseconds3.value = new Milliseconds3();
  return Milliseconds3;
}();
var MillisecondsShort = /* @__PURE__ */ function() {
  function MillisecondsShort2() {
  }
  ;
  MillisecondsShort2.value = new MillisecondsShort2();
  return MillisecondsShort2;
}();
var MillisecondsTwoDigits = /* @__PURE__ */ function() {
  function MillisecondsTwoDigits2() {
  }
  ;
  MillisecondsTwoDigits2.value = new MillisecondsTwoDigits2();
  return MillisecondsTwoDigits2;
}();
var Placeholder = /* @__PURE__ */ function() {
  function Placeholder2(value0) {
    this.value0 = value0;
  }
  ;
  Placeholder2.create = function(value0) {
    return new Placeholder2(value0);
  };
  return Placeholder2;
}();
var printShortMonth = function(v) {
  if (v instanceof January) {
    return "Jan";
  }
  ;
  if (v instanceof February) {
    return "Feb";
  }
  ;
  if (v instanceof March) {
    return "Mar";
  }
  ;
  if (v instanceof April) {
    return "Apr";
  }
  ;
  if (v instanceof May) {
    return "May";
  }
  ;
  if (v instanceof June) {
    return "Jun";
  }
  ;
  if (v instanceof July) {
    return "Jul";
  }
  ;
  if (v instanceof August) {
    return "Aug";
  }
  ;
  if (v instanceof September) {
    return "Sep";
  }
  ;
  if (v instanceof October) {
    return "Oct";
  }
  ;
  if (v instanceof November) {
    return "Nov";
  }
  ;
  if (v instanceof December) {
    return "Dec";
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 489, column 19 - line 501, column 22): " + [v.constructor.name]);
};
var padSingleDigit = function(i) {
  if (i < 0) {
    return "-" + padSingleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 194, column 1 - line 194, column 32): " + [i.constructor.name]);
};
var padQuadrupleDigit = function(i) {
  if (i < 0) {
    return "-" + padQuadrupleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "000" + show3(i);
  }
  ;
  if (i < 100) {
    return "00" + show3(i);
  }
  ;
  if (i < 1e3) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 207, column 1 - line 207, column 35): " + [i.constructor.name]);
};
var padDoubleDigit = function(i) {
  if (i < 0) {
    return "-" + padDoubleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "00" + show3(i);
  }
  ;
  if (i < 100) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 200, column 1 - line 200, column 32): " + [i.constructor.name]);
};
var formatYearTwoDigits = function(i) {
  var dateString = show3(abs3(i));
  var dateLength = length5(dateString);
  if (dateLength === 1) {
    return "0" + dateString;
  }
  ;
  if (dateLength === 2) {
    return dateString;
  }
  ;
  return drop3(dateLength - 2 | 0)(dateString);
};
var fix12 = function(h) {
  var $618 = h === 0;
  if ($618) {
    return 12;
  }
  ;
  return h;
};
var formatCommand = function(v) {
  return function(v1) {
    if (v1 instanceof YearFull) {
      return padQuadrupleDigit(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof YearTwoDigits) {
      return formatYearTwoDigits(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof YearAbsolute) {
      return show3(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof MonthFull) {
      return show13(month(v.value0));
    }
    ;
    if (v1 instanceof MonthShort) {
      return printShortMonth(month(v.value0));
    }
    ;
    if (v1 instanceof MonthTwoDigits) {
      return padSingleDigit(fromEnum1(month(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonthTwoDigits) {
      return padSingleDigit(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonth) {
      return show3(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof UnixTimestamp) {
      return show3(floor2(function(v2) {
        return v2 / 1e3;
      }(unwrap6(unInstant(fromDateTime(v))))));
    }
    ;
    if (v1 instanceof DayOfWeek) {
      return show3(fromEnum32(weekday(v.value0)));
    }
    ;
    if (v1 instanceof DayOfWeekName) {
      return show22(weekday(v.value0));
    }
    ;
    if (v1 instanceof DayOfWeekNameShort) {
      return take3(3)(show22(weekday(v.value0)));
    }
    ;
    if (v1 instanceof Hours24) {
      return padSingleDigit(fromEnum42(hour(v.value1)));
    }
    ;
    if (v1 instanceof Hours12) {
      return padSingleDigit(fix12(mod4(fromEnum42(hour(v.value1)))(12)));
    }
    ;
    if (v1 instanceof Meridiem) {
      var $621 = fromEnum42(hour(v.value1)) >= 12;
      if ($621) {
        return "PM";
      }
      ;
      return "AM";
    }
    ;
    if (v1 instanceof Minutes) {
      return show3(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof MinutesTwoDigits) {
      return padSingleDigit(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof Seconds) {
      return show3(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof SecondsTwoDigits) {
      return padSingleDigit(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof Milliseconds) {
      return padDoubleDigit(fromEnum7(millisecond(v.value1)));
    }
    ;
    if (v1 instanceof MillisecondsShort) {
      return show3(function(v2) {
        return div1(v2)(100);
      }(fromEnum7(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof MillisecondsTwoDigits) {
      return padSingleDigit(function(v2) {
        return div1(v2)(10);
      }(fromEnum7(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof Placeholder) {
      return v1.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 169, column 38 - line 192, column 21): " + [v1.constructor.name]);
  };
};
var format = function(f) {
  return function(d) {
    return foldMap12(formatCommand(d))(f);
  };
};

// output/Effect.Console/foreign.js
var log2 = function(s) {
  return function() {
    console.log(s);
  };
};
var warn = function(s) {
  return function() {
    console.warn(s);
  };
};
var error3 = function(s) {
  return function() {
    console.error(s);
  };
};
var info = function(s) {
  return function() {
    console.info(s);
  };
};
var debug = function(s) {
  return function() {
    console.debug(s);
  };
};

// output/Effect.Class.Console/index.js
var warn2 = function(dictMonadEffect) {
  var $57 = liftEffect(dictMonadEffect);
  return function($58) {
    return $57(warn($58));
  };
};
var log3 = function(dictMonadEffect) {
  var $67 = liftEffect(dictMonadEffect);
  return function($68) {
    return $67(log2($68));
  };
};
var info2 = function(dictMonadEffect) {
  var $71 = liftEffect(dictMonadEffect);
  return function($72) {
    return $71(info($72));
  };
};
var error4 = function(dictMonadEffect) {
  var $79 = liftEffect(dictMonadEffect);
  return function($80) {
    return $79(error3($80));
  };
};
var debug2 = function(dictMonadEffect) {
  var $83 = liftEffect(dictMonadEffect);
  return function($84) {
    return $83(debug($84));
  };
};

// output/Effect.Now/foreign.js
function now() {
  return Date.now();
}

// output/Effect.Now/index.js
var map18 = /* @__PURE__ */ map(functorEffect);
var nowDateTime = /* @__PURE__ */ map18(toDateTime)(now);

// output/Whine.Log/index.js
var fold4 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var LogDebug = /* @__PURE__ */ function() {
  function LogDebug2() {
  }
  ;
  LogDebug2.value = new LogDebug2();
  return LogDebug2;
}();
var LogInfo = /* @__PURE__ */ function() {
  function LogInfo2() {
  }
  ;
  LogInfo2.value = new LogInfo2();
  return LogInfo2;
}();
var LogWarning = /* @__PURE__ */ function() {
  function LogWarning2() {
  }
  ;
  LogWarning2.value = new LogWarning2();
  return LogWarning2;
}();
var LogError = /* @__PURE__ */ function() {
  function LogError2() {
  }
  ;
  LogError2.value = new LogError2();
  return LogError2;
}();
var loggableString = {
  toDoc: /* @__PURE__ */ identity(categoryFn)
};
var eqLogSeverity = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LogDebug && y instanceof LogDebug) {
        return true;
      }
      ;
      if (x instanceof LogInfo && y instanceof LogInfo) {
        return true;
      }
      ;
      if (x instanceof LogWarning && y instanceof LogWarning) {
        return true;
      }
      ;
      if (x instanceof LogError && y instanceof LogError) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordLogSeverity = {
  compare: function(x) {
    return function(y) {
      if (x instanceof LogDebug && y instanceof LogDebug) {
        return EQ.value;
      }
      ;
      if (x instanceof LogDebug) {
        return LT.value;
      }
      ;
      if (y instanceof LogDebug) {
        return GT.value;
      }
      ;
      if (x instanceof LogInfo && y instanceof LogInfo) {
        return EQ.value;
      }
      ;
      if (x instanceof LogInfo) {
        return LT.value;
      }
      ;
      if (y instanceof LogInfo) {
        return GT.value;
      }
      ;
      if (x instanceof LogWarning && y instanceof LogWarning) {
        return EQ.value;
      }
      ;
      if (x instanceof LogWarning) {
        return LT.value;
      }
      ;
      if (y instanceof LogWarning) {
        return GT.value;
      }
      ;
      if (x instanceof LogError && y instanceof LogError) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Whine.Log (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqLogSeverity;
  }
};
var greaterThanOrEq2 = /* @__PURE__ */ greaterThanOrEq(ordLogSeverity);
var toDoc = function(dict) {
  return dict.toDoc;
};
var log4 = function(dict) {
  return dict.log;
};
var logDebug = function(dictMonadLog) {
  var log1 = log4(dictMonadLog);
  return function(dictLoggable) {
    return log1(dictLoggable)(LogDebug.value);
  };
};
var formatDebugTime = /* @__PURE__ */ function() {
  return format(fromFoldable6(foldableArray)([Hours24.value, new Placeholder(":"), MinutesTwoDigits.value, new Placeholder(":"), SecondsTwoDigits.value, new Placeholder("."), Milliseconds.value]));
}();
var logDefault = function(dictMonadEffect) {
  var info4 = info2(dictMonadEffect);
  var warn3 = warn2(dictMonadEffect);
  var error5 = error4(dictMonadEffect);
  var Monad0 = dictMonadEffect.Monad0();
  var bind30 = bind(Monad0.Bind1());
  var liftEffect3 = liftEffect(dictMonadEffect);
  var debug3 = debug2(dictMonadEffect);
  var when5 = when(Monad0.Applicative0());
  return function(dictLoggable) {
    var toDoc1 = toDoc(dictLoggable);
    return function(v) {
      return function(message2) {
        var printFn = function() {
          if (v.severity instanceof LogInfo) {
            return info4;
          }
          ;
          if (v.severity instanceof LogWarning) {
            return warn3;
          }
          ;
          if (v.severity instanceof LogError) {
            return error5;
          }
          ;
          if (v.severity instanceof LogDebug) {
            return function(s) {
              return bind30(liftEffect3(nowDateTime))(function(now3) {
                return debug3(fold4(["[", formatDebugTime(now3), "]: ", s]));
              });
            };
          }
          ;
          throw new Error("Failed pattern match at Whine.Log (line 37, column 15 - line 46, column 66): " + [v.severity.constructor.name]);
        }();
        return when5(greaterThanOrEq2(v.severity)(v.level))(printFn(toDoc1(message2)));
      };
    };
  };
};

// output/Whine.Core.UndesirableFunctions/index.js
var eq4 = /* @__PURE__ */ eq(eqModuleName);
var any5 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var ordRecord2 = /* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(ordRecordNil)()({
  reflectSymbol: function() {
    return "function";
  }
})(ordString));
var lookup4 = /* @__PURE__ */ lookup3(ordRecord2);
var discard4 = /* @__PURE__ */ discard(discardUnit);
var showMaybe2 = /* @__PURE__ */ showMaybe(showString);
var show4 = /* @__PURE__ */ show(showMaybe2);
var map19 = /* @__PURE__ */ map(functorMaybe);
var unwrap7 = /* @__PURE__ */ unwrap();
var show14 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(/* @__PURE__ */ showTuple(showMaybe2)(showString)));
var map110 = /* @__PURE__ */ map(functorArray);
var lmap2 = /* @__PURE__ */ lmap(bifunctorTuple);
var toUnfoldable8 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var alt4 = /* @__PURE__ */ alt(altMaybe);
var ordMaybe2 = /* @__PURE__ */ ordMaybe(ordModuleName);
var lookup1 = /* @__PURE__ */ lookup3(ordMaybe2);
var not4 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var wrap3 = /* @__PURE__ */ wrap();
var unionWith2 = /* @__PURE__ */ unionWith(ordRecord2);
var union3 = /* @__PURE__ */ union(ordMaybe2);
var bind7 = /* @__PURE__ */ bind(bindArray);
var pure7 = /* @__PURE__ */ pure(applicativeArray);
var fromFoldable15 = /* @__PURE__ */ fromFoldable5(ordString)(foldableArray);
var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorMaybe);
var rule4 = function(badFunctions) {
  var qualifiedImport = function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        return Nothing.value;
      }
      ;
      if (v1 instanceof Just) {
        return findMap(function(v2) {
          if (v2.qualified instanceof Just && eq4(v2.qualified.value0.value1.name)(v1.value0)) {
            return new Just(v2.module.name);
          }
          ;
          return Nothing.value;
        })(v.header.imports);
      }
      ;
      throw new Error("Failed pattern match at Whine.Core.UndesirableFunctions (line 85, column 5 - line 85, column 77): " + [v.constructor.name, v1.constructor.name]);
    };
  };
  var loneOpenImport = function(v) {
    var candidates = mapMaybe(function(v1) {
      if (v1.qualified instanceof Nothing && v1.names instanceof Nothing) {
        return new Just(v1.module.name);
      }
      ;
      return Nothing.value;
    })(v.header.imports);
    if (candidates.length === 1) {
      return new Just(candidates[0]);
    }
    ;
    return Nothing.value;
  };
  var explicitImport = function(v) {
    return function(ident) {
      var sameIdentifier = function(v1) {
        if (v1 instanceof ImportValue) {
          return v1.value0.name === ident;
        }
        ;
        if (v1 instanceof ImportOp) {
          return v1.value0.name === ident;
        }
        ;
        return false;
      };
      return findMap(function(v1) {
        if (v1.names instanceof Just && (sameIdentifier(v1.names.value0.value1.value.head) || any5(function($158) {
          return sameIdentifier(snd($158));
        })(v1.names.value0.value1.value.tail))) {
          return new Just(v1.module.name);
        }
        ;
        return Nothing.value;
      })(v.header.imports);
    };
  };
  var onExpr = function(dictMonadRules) {
    var MonadReport3 = dictMonadRules.MonadReport3();
    var Monad0 = MonadReport3.Monad0();
    var Applicative0 = Monad0.Applicative0();
    var pure114 = pure(Applicative0);
    var currentModule2 = currentModule(dictMonadRules.MonadContext2());
    var discard15 = discard4(Monad0.Bind1());
    var logDebug3 = logDebug(dictMonadRules.MonadLog1())(loggableString);
    var reportViolation2 = reportViolation(MonadReport3);
    var traverse_3 = traverse_(Applicative0)(foldableMaybe);
    var for_2 = for_(Applicative0)(foldableMaybe);
    return function(dictRangeOf) {
      var rangeOf5 = rangeOf(rangeOfExpr(dictRangeOf));
      return function(v) {
        var v1 = function(v2) {
          return pure114(unit);
        };
        if (v instanceof ExprIdent) {
          var $134 = lookup4({
            "function": v.value0.name
          })(badFunctions);
          if ($134 instanceof Just) {
            return currentModule2(function(m) {
              return discard15(logDebug3("Checking " + (v.value0.name + (" from " + show4(map19(unwrap7)(v.value0.module))))))(function() {
                return discard15(logDebug3("Modules: " + show14(map110(lmap2(map19(unwrap7)))(toUnfoldable8($134.value0)))))(function() {
                  var report = function(message2) {
                    return reportViolation2({
                      source: new Just(rangeOf5(v)),
                      message: message2
                    });
                  };
                  var importedFrom = alt4(qualifiedImport(m)(v.value0.module))(alt4(explicitImport(m)(v.value0.name))(loneOpenImport(m)));
                  return discard15(logDebug3("Imported from " + show4(map19(unwrap7)(importedFrom))))(function() {
                    if (importedFrom instanceof Just) {
                      return discard15(logDebug3("Explicit message: " + show4(lookup1(new Just(importedFrom.value0))($134.value0))))(function() {
                        return discard15(logDebug3("Module-agnostic message: " + show4(lookup1(Nothing.value)($134.value0))))(function() {
                          var message2 = alt4(lookup1(new Just(importedFrom.value0))($134.value0))(lookup1(Nothing.value)($134.value0));
                          return traverse_3(report)(message2);
                        });
                      });
                    }
                    ;
                    if (importedFrom instanceof Nothing) {
                      return for_2(lookup1(Nothing.value)($134.value0))(function(message2) {
                        return report(message2);
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Whine.Core.UndesirableFunctions (line 67, column 15 - line 78, column 35): " + [importedFrom.constructor.name]);
                  });
                });
              });
            });
          }
          ;
          return v1(true);
        }
        ;
        return v1(true);
      };
    };
  };
  return {
    onModule: emptyRule.onModule,
    onModuleImport: emptyRule.onModuleImport,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onType: emptyRule.onType,
    onExpr
  };
};
var codec2 = /* @__PURE__ */ function() {
  var fromQualified = function(s) {
    var v = unsnoc(split(".")(s));
    if (v instanceof Just && not4($$null)(v.value0.init)) {
      return new Tuple(new Just(wrap3(joinWith(".")(v.value0.init))), v.value0.last);
    }
    ;
    return new Tuple(Nothing.value, s);
  };
  var foldMaps = function(mm2) {
    return foldl2(unionWith2(union3))(empty4)(bind7(toUnfoldable8(mm2.functions))(function(v) {
      var v1 = fromQualified(v.value0);
      return pure7(singleton9({
        "function": v1.value1
      })(singleton9(v1.value0)(v.value1)));
    }));
  };
  var explodeMaps = function(mm2) {
    return {
      functions: fromFoldable15(bind7(toUnfoldable8(mm2))(function(v) {
        return bind7(toUnfoldable8(v.value1))(function(v1) {
          var modulePrefix = fromMaybe("")(mapFlipped4(mapFlipped4(v1.value0)(unwrap7))(function(v2) {
            return v2 + ".";
          }));
          return pure7(new Tuple(modulePrefix + v["value0"]["function"], v1.value1));
        });
      }))
    };
  };
  return dimap(profunctorCodec(functorExceptT(functorIdentity)))(explodeMaps)(foldMaps)(object2()(rowListCodecConsCodec(rowListCodecNilRowRow)()()({
    reflectSymbol: function() {
      return "functions";
    }
  }))({
    functions: strMap(string)
  }));
}();

// output/Whine.Core.UndesirableModules/index.js
var lookup5 = /* @__PURE__ */ lookup3(ordModuleName);
var map20 = /* @__PURE__ */ map(functorArray);
var lmap3 = /* @__PURE__ */ lmap(bifunctorTuple);
var toUnfoldable9 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var rule5 = function(badModules) {
  return {
    onModule: emptyRule.onModule,
    onModuleExport: emptyRule.onModuleExport,
    onDecl: emptyRule.onDecl,
    onBinder: emptyRule.onBinder,
    onExpr: emptyRule.onExpr,
    onType: emptyRule.onType,
    onModuleImport: function(dictMonadRules) {
      var MonadReport3 = dictMonadRules.MonadReport3();
      var traverse_3 = traverse_(MonadReport3.Monad0().Applicative0())(foldableMaybe);
      var reportViolation2 = reportViolation(MonadReport3);
      return function(dictRangeOf) {
        return function(v1) {
          return traverse_3(function(message2) {
            return reportViolation2({
              source: new Just(v1.module.token.range),
              message: message2
            });
          })(lookup5(v1.module.name)(badModules));
        };
      };
    }
  };
};
var codec3 = /* @__PURE__ */ function() {
  var overMap = function(dictOrd) {
    var fromFoldable23 = fromFoldable5(dictOrd)(foldableArray);
    return function(f) {
      return function(a) {
        return fromFoldable23(map20(lmap3(f))(toUnfoldable9(a)));
      };
    };
  };
  return dimap(profunctorCodec(functorExceptT(functorIdentity)))(function() {
    var $36 = overMap(ordString)(unwrap());
    return function($37) {
      return /* @__PURE__ */ function(v) {
        return {
          modules: v
        };
      }($36($37));
    };
  }())(function() {
    var $38 = overMap(ordModuleName)(wrap());
    return function($39) {
      return $38(function(v) {
        return v.modules;
      }($39));
    };
  }())(object2()(rowListCodecConsCodec(rowListCodecNilRowRow)()()({
    reflectSymbol: function() {
      return "modules";
    }
  }))({
    modules: strMap(string)
  }));
}();

// output/Whine.Core.WhineRules/index.js
var rules2 = [/* @__PURE__ */ ruleFactory("UndesirableModules")(codec3)(rule5), /* @__PURE__ */ ruleFactory("UndesirableFunctions")(codec2)(rule4), /* @__PURE__ */ ruleFactory("CommaFirstArrays")(json)(rule2), /* @__PURE__ */ ruleFactory("CommaFirstRecords")(json)(rule3), /* @__PURE__ */ ruleFactory("CaseBranchIndentation")(json)(rule)];

// output/Effect.Aff/foreign.js
var Aff = function() {
  var EMPTY = {};
  var PURE = "Pure";
  var THROW = "Throw";
  var CATCH = "Catch";
  var SYNC = "Sync";
  var ASYNC3 = "Async";
  var BIND = "Bind";
  var BRACKET = "Bracket";
  var FORK = "Fork";
  var SEQ = "Sequential";
  var MAP = "Map";
  var APPLY = "Apply";
  var ALT = "Alt";
  var CONS = "Cons";
  var RESUME3 = "Resume";
  var RELEASE = "Release";
  var FINALIZER = "Finalizer";
  var FINALIZED = "Finalized";
  var FORKED = "Forked";
  var FIBER = "Fiber";
  var THUNK = "Thunk";
  function Aff2(tag, _1, _2, _3) {
    this.tag = tag;
    this._1 = _1;
    this._2 = _2;
    this._3 = _3;
  }
  function AffCtr(tag) {
    var fn = function(_1, _2, _3) {
      return new Aff2(tag, _1, _2, _3);
    };
    fn.tag = tag;
    return fn;
  }
  function nonCanceler2(error5) {
    return new Aff2(PURE, void 0);
  }
  function runEff(eff) {
    try {
      eff();
    } catch (error5) {
      setTimeout(function() {
        throw error5;
      }, 0);
    }
  }
  function runSync(left, right, eff) {
    try {
      return right(eff());
    } catch (error5) {
      return left(error5);
    }
  }
  function runAsync(left, eff, k) {
    try {
      return eff(k)();
    } catch (error5) {
      k(left(error5))();
      return nonCanceler2;
    }
  }
  var Scheduler = function() {
    var limit = 1024;
    var size6 = 0;
    var ix = 0;
    var queue = new Array(limit);
    var draining = false;
    function drain() {
      var thunk;
      draining = true;
      while (size6 !== 0) {
        size6--;
        thunk = queue[ix];
        queue[ix] = void 0;
        ix = (ix + 1) % limit;
        thunk();
      }
      draining = false;
    }
    return {
      isDraining: function() {
        return draining;
      },
      enqueue: function(cb) {
        var i, tmp;
        if (size6 === limit) {
          tmp = draining;
          drain();
          draining = tmp;
        }
        queue[(ix + size6) % limit] = cb;
        size6++;
        if (!draining) {
          drain();
        }
      }
    };
  }();
  function Supervisor(util) {
    var fibers = {};
    var fiberId = 0;
    var count = 0;
    return {
      register: function(fiber) {
        var fid = fiberId++;
        fiber.onComplete({
          rethrow: true,
          handler: function(result) {
            return function() {
              count--;
              delete fibers[fid];
            };
          }
        })();
        fibers[fid] = fiber;
        count++;
      },
      isEmpty: function() {
        return count === 0;
      },
      killAll: function(killError, cb) {
        return function() {
          if (count === 0) {
            return cb();
          }
          var killCount = 0;
          var kills = {};
          function kill(fid) {
            kills[fid] = fibers[fid].kill(killError, function(result) {
              return function() {
                delete kills[fid];
                killCount--;
                if (util.isLeft(result) && util.fromLeft(result)) {
                  setTimeout(function() {
                    throw util.fromLeft(result);
                  }, 0);
                }
                if (killCount === 0) {
                  cb();
                }
              };
            })();
          }
          for (var k in fibers) {
            if (fibers.hasOwnProperty(k)) {
              killCount++;
              kill(k);
            }
          }
          fibers = {};
          fiberId = 0;
          count = 0;
          return function(error5) {
            return new Aff2(SYNC, function() {
              for (var k2 in kills) {
                if (kills.hasOwnProperty(k2)) {
                  kills[k2]();
                }
              }
            });
          };
        };
      }
    };
  }
  var SUSPENDED = 0;
  var CONTINUE = 1;
  var STEP_BIND = 2;
  var STEP_RESULT = 3;
  var PENDING = 4;
  var RETURN = 5;
  var COMPLETED = 6;
  function Fiber(util, supervisor, aff) {
    var runTick = 0;
    var status = SUSPENDED;
    var step3 = aff;
    var fail5 = null;
    var interrupt = null;
    var bhead = null;
    var btail = null;
    var attempts = null;
    var bracketCount = 0;
    var joinId = 0;
    var joins = null;
    var rethrow = true;
    function run3(localRunTick) {
      var tmp, result, attempt;
      while (true) {
        tmp = null;
        result = null;
        attempt = null;
        switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step3 = bhead(step3);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail5 = util.left(e);
              step3 = null;
            }
            break;
          case STEP_RESULT:
            if (util.isLeft(step3)) {
              status = RETURN;
              fail5 = step3;
              step3 = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step3 = util.fromRight(step3);
            }
            break;
          case CONTINUE:
            switch (step3.tag) {
              case BIND:
                if (bhead) {
                  btail = new Aff2(CONS, bhead, btail);
                }
                bhead = step3._2;
                status = CONTINUE;
                step3 = step3._1;
                break;
              case PURE:
                if (bhead === null) {
                  status = RETURN;
                  step3 = util.right(step3._1);
                } else {
                  status = STEP_BIND;
                  step3 = step3._1;
                }
                break;
              case SYNC:
                status = STEP_RESULT;
                step3 = runSync(util.left, util.right, step3._1);
                break;
              case ASYNC3:
                status = PENDING;
                step3 = runAsync(util.left, step3._1, function(result2) {
                  return function() {
                    if (runTick !== localRunTick) {
                      return;
                    }
                    runTick++;
                    Scheduler.enqueue(function() {
                      if (runTick !== localRunTick + 1) {
                        return;
                      }
                      status = STEP_RESULT;
                      step3 = result2;
                      run3(runTick);
                    });
                  };
                });
                return;
              case THROW:
                status = RETURN;
                fail5 = util.left(step3._1);
                step3 = null;
                break;
              // Enqueue the Catch so that we can call the error handler later on
              // in case of an exception.
              case CATCH:
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME3, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step3 = step3._1;
                break;
              // Enqueue the Bracket so that we can call the appropriate handlers
              // after resource acquisition.
              case BRACKET:
                bracketCount++;
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME3, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step3 = step3._1;
                break;
              case FORK:
                status = STEP_RESULT;
                tmp = Fiber(util, supervisor, step3._2);
                if (supervisor) {
                  supervisor.register(tmp);
                }
                if (step3._1) {
                  tmp.run();
                }
                step3 = util.right(tmp);
                break;
              case SEQ:
                status = CONTINUE;
                step3 = sequential2(util, supervisor, step3._1);
                break;
            }
            break;
          case RETURN:
            bhead = null;
            btail = null;
            if (attempts === null) {
              status = COMPLETED;
              step3 = interrupt || fail5 || step3;
            } else {
              tmp = attempts._3;
              attempt = attempts._1;
              attempts = attempts._2;
              switch (attempt.tag) {
                // We cannot recover from an unmasked interrupt. Otherwise we should
                // continue stepping, or run the exception handler if an exception
                // was raised.
                case CATCH:
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    status = RETURN;
                  } else if (fail5) {
                    status = CONTINUE;
                    step3 = attempt._2(util.fromLeft(fail5));
                    fail5 = null;
                  }
                  break;
                // We cannot resume from an unmasked interrupt or exception.
                case RESUME3:
                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail5) {
                    status = RETURN;
                  } else {
                    bhead = attempt._1;
                    btail = attempt._2;
                    status = STEP_BIND;
                    step3 = util.fromRight(step3);
                  }
                  break;
                // If we have a bracket, we should enqueue the handlers,
                // and continue with the success branch only if the fiber has
                // not been interrupted. If the bracket acquisition failed, we
                // should not run either.
                case BRACKET:
                  bracketCount--;
                  if (fail5 === null) {
                    result = util.fromRight(step3);
                    attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                    if (interrupt === tmp || bracketCount > 0) {
                      status = CONTINUE;
                      step3 = attempt._3(result);
                    }
                  }
                  break;
                // Enqueue the appropriate handler. We increase the bracket count
                // because it should not be cancelled.
                case RELEASE:
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail5), attempts, interrupt);
                  status = CONTINUE;
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    step3 = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                  } else if (fail5) {
                    step3 = attempt._1.failed(util.fromLeft(fail5))(attempt._2);
                  } else {
                    step3 = attempt._1.completed(util.fromRight(step3))(attempt._2);
                  }
                  fail5 = null;
                  bracketCount++;
                  break;
                case FINALIZER:
                  bracketCount++;
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail5), attempts, interrupt);
                  status = CONTINUE;
                  step3 = attempt._1;
                  break;
                case FINALIZED:
                  bracketCount--;
                  status = RETURN;
                  step3 = attempt._1;
                  fail5 = attempt._2;
                  break;
              }
            }
            break;
          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step3));
              }
            }
            joins = null;
            if (interrupt && fail5) {
              setTimeout(function() {
                throw util.fromLeft(fail5);
              }, 0);
            } else if (util.isLeft(step3) && rethrow) {
              setTimeout(function() {
                if (rethrow) {
                  throw util.fromLeft(step3);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING:
            return;
        }
      }
    }
    function onComplete(join3) {
      return function() {
        if (status === COMPLETED) {
          rethrow = rethrow && join3.rethrow;
          join3.handler(step3)();
          return function() {
          };
        }
        var jid = joinId++;
        joins = joins || {};
        joins[jid] = join3;
        return function() {
          if (joins !== null) {
            delete joins[jid];
          }
        };
      };
    }
    function kill(error5, cb) {
      return function() {
        if (status === COMPLETED) {
          cb(util.right(void 0))();
          return function() {
          };
        }
        var canceler = onComplete({
          rethrow: false,
          handler: function() {
            return cb(util.right(void 0));
          }
        })();
        switch (status) {
          case SUSPENDED:
            interrupt = util.left(error5);
            status = COMPLETED;
            step3 = interrupt;
            run3(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff2(CONS, new Aff2(FINALIZER, step3(error5)), attempts, interrupt);
              }
              status = RETURN;
              step3 = null;
              fail5 = null;
              run3(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step3 = null;
              fail5 = null;
            }
        }
        return canceler;
      };
    }
    function join2(cb) {
      return function() {
        var canceler = onComplete({
          rethrow: false,
          handler: cb
        })();
        if (status === SUSPENDED) {
          run3(runTick);
        }
        return canceler;
      };
    }
    return {
      kill,
      join: join2,
      onComplete,
      isSuspended: function() {
        return status === SUSPENDED;
      },
      run: function() {
        if (status === SUSPENDED) {
          if (!Scheduler.isDraining()) {
            Scheduler.enqueue(function() {
              run3(runTick);
            });
          } else {
            run3(runTick);
          }
        }
      }
    };
  }
  function runPar(util, supervisor, par, cb) {
    var fiberId = 0;
    var fibers = {};
    var killId = 0;
    var kills = {};
    var early = new Error("[ParAff] Early exit");
    var interrupt = null;
    var root = EMPTY;
    function kill(error5, par2, cb2) {
      var step3 = par2;
      var head4 = null;
      var tail2 = null;
      var count = 0;
      var kills2 = {};
      var tmp, kid;
      loop: while (true) {
        tmp = null;
        switch (step3.tag) {
          case FORKED:
            if (step3._3 === EMPTY) {
              tmp = fibers[step3._1];
              kills2[count++] = tmp.kill(error5, function(result) {
                return function() {
                  count--;
                  if (count === 0) {
                    cb2(result)();
                  }
                };
              });
            }
            if (head4 === null) {
              break loop;
            }
            step3 = head4._2;
            if (tail2 === null) {
              head4 = null;
            } else {
              head4 = tail2._1;
              tail2 = tail2._2;
            }
            break;
          case MAP:
            step3 = step3._2;
            break;
          case APPLY:
          case ALT:
            if (head4) {
              tail2 = new Aff2(CONS, head4, tail2);
            }
            head4 = step3;
            step3 = step3._1;
            break;
        }
      }
      if (count === 0) {
        cb2(util.right(void 0))();
      } else {
        kid = 0;
        tmp = count;
        for (; kid < tmp; kid++) {
          kills2[kid] = kills2[kid]();
        }
      }
      return kills2;
    }
    function join2(result, head4, tail2) {
      var fail5, step3, lhs, rhs, tmp, kid;
      if (util.isLeft(result)) {
        fail5 = result;
        step3 = null;
      } else {
        step3 = result;
        fail5 = null;
      }
      loop: while (true) {
        lhs = null;
        rhs = null;
        tmp = null;
        kid = null;
        if (interrupt !== null) {
          return;
        }
        if (head4 === null) {
          cb(fail5 || step3)();
          return;
        }
        if (head4._3 !== EMPTY) {
          return;
        }
        switch (head4.tag) {
          case MAP:
            if (fail5 === null) {
              head4._3 = util.right(head4._1(util.fromRight(step3)));
              step3 = head4._3;
            } else {
              head4._3 = fail5;
            }
            break;
          case APPLY:
            lhs = head4._1._3;
            rhs = head4._2._3;
            if (fail5) {
              head4._3 = fail5;
              tmp = true;
              kid = killId++;
              kills[kid] = kill(early, fail5 === lhs ? head4._2 : head4._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail2 === null) {
                    join2(fail5, null, null);
                  } else {
                    join2(fail5, tail2._1, tail2._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            } else if (lhs === EMPTY || rhs === EMPTY) {
              return;
            } else {
              step3 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
              head4._3 = step3;
            }
            break;
          case ALT:
            lhs = head4._1._3;
            rhs = head4._2._3;
            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
              return;
            }
            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
              fail5 = step3 === lhs ? rhs : lhs;
              step3 = null;
              head4._3 = fail5;
            } else {
              head4._3 = step3;
              tmp = true;
              kid = killId++;
              kills[kid] = kill(early, step3 === lhs ? head4._2 : head4._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail2 === null) {
                    join2(step3, null, null);
                  } else {
                    join2(step3, tail2._1, tail2._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            }
            break;
        }
        if (tail2 === null) {
          head4 = null;
        } else {
          head4 = tail2._1;
          tail2 = tail2._2;
        }
      }
    }
    function resolve2(fiber) {
      return function(result) {
        return function() {
          delete fibers[fiber._1];
          fiber._3 = result;
          join2(result, fiber._2._1, fiber._2._2);
        };
      };
    }
    function run3() {
      var status = CONTINUE;
      var step3 = par;
      var head4 = null;
      var tail2 = null;
      var tmp, fid;
      loop: while (true) {
        tmp = null;
        fid = null;
        switch (status) {
          case CONTINUE:
            switch (step3.tag) {
              case MAP:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(MAP, step3._1, EMPTY, EMPTY);
                step3 = step3._2;
                break;
              case APPLY:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(APPLY, EMPTY, step3._2, EMPTY);
                step3 = step3._1;
                break;
              case ALT:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(ALT, EMPTY, step3._2, EMPTY);
                step3 = step3._1;
                break;
              default:
                fid = fiberId++;
                status = RETURN;
                tmp = step3;
                step3 = new Aff2(FORKED, fid, new Aff2(CONS, head4, tail2), EMPTY);
                tmp = Fiber(util, supervisor, tmp);
                tmp.onComplete({
                  rethrow: false,
                  handler: resolve2(step3)
                })();
                fibers[fid] = tmp;
                if (supervisor) {
                  supervisor.register(tmp);
                }
            }
            break;
          case RETURN:
            if (head4 === null) {
              break loop;
            }
            if (head4._1 === EMPTY) {
              head4._1 = step3;
              status = CONTINUE;
              step3 = head4._2;
              head4._2 = EMPTY;
            } else {
              head4._2 = step3;
              step3 = head4;
              if (tail2 === null) {
                head4 = null;
              } else {
                head4 = tail2._1;
                tail2 = tail2._2;
              }
            }
        }
      }
      root = step3;
      for (fid = 0; fid < fiberId; fid++) {
        fibers[fid].run();
      }
    }
    function cancel(error5, cb2) {
      interrupt = util.left(error5);
      var innerKills;
      for (var kid in kills) {
        if (kills.hasOwnProperty(kid)) {
          innerKills = kills[kid];
          for (kid in innerKills) {
            if (innerKills.hasOwnProperty(kid)) {
              innerKills[kid]();
            }
          }
        }
      }
      kills = null;
      var newKills = kill(error5, root, cb2);
      return function(killError) {
        return new Aff2(ASYNC3, function(killCb) {
          return function() {
            for (var kid2 in newKills) {
              if (newKills.hasOwnProperty(kid2)) {
                newKills[kid2]();
              }
            }
            return nonCanceler2;
          };
        });
      };
    }
    run3();
    return function(killError) {
      return new Aff2(ASYNC3, function(killCb) {
        return function() {
          return cancel(killError, killCb);
        };
      });
    };
  }
  function sequential2(util, supervisor, par) {
    return new Aff2(ASYNC3, function(cb) {
      return function() {
        return runPar(util, supervisor, par, cb);
      };
    });
  }
  Aff2.EMPTY = EMPTY;
  Aff2.Pure = AffCtr(PURE);
  Aff2.Throw = AffCtr(THROW);
  Aff2.Catch = AffCtr(CATCH);
  Aff2.Sync = AffCtr(SYNC);
  Aff2.Async = AffCtr(ASYNC3);
  Aff2.Bind = AffCtr(BIND);
  Aff2.Bracket = AffCtr(BRACKET);
  Aff2.Fork = AffCtr(FORK);
  Aff2.Seq = AffCtr(SEQ);
  Aff2.ParMap = AffCtr(MAP);
  Aff2.ParApply = AffCtr(APPLY);
  Aff2.ParAlt = AffCtr(ALT);
  Aff2.Fiber = Fiber;
  Aff2.Supervisor = Supervisor;
  Aff2.Scheduler = Scheduler;
  Aff2.nonCanceler = nonCanceler2;
  return Aff2;
}();
var _pure = Aff.Pure;
var _throwError = Aff.Throw;
function _map(f) {
  return function(aff) {
    if (aff.tag === Aff.Pure.tag) {
      return Aff.Pure(f(aff._1));
    } else {
      return Aff.Bind(aff, function(value3) {
        return Aff.Pure(f(value3));
      });
    }
  };
}
function _bind(aff) {
  return function(k) {
    return Aff.Bind(aff, k);
  };
}
var _liftEffect = Aff.Sync;
function _parAffMap(f) {
  return function(aff) {
    return Aff.ParMap(f, aff);
  };
}
function _parAffApply(aff1) {
  return function(aff2) {
    return Aff.ParApply(aff1, aff2);
  };
}
var makeAff = Aff.Async;
function _makeFiber(util, aff) {
  return function() {
    return Aff.Fiber(util, null, aff);
  };
}
var _sequential = Aff.Seq;

// output/Control.Parallel.Class/index.js
var sequential = function(dict) {
  return dict.sequential;
};
var parallel = function(dict) {
  return dict.parallel;
};

// output/Control.Parallel/index.js
var identity9 = /* @__PURE__ */ identity(categoryFn);
var parTraverse_ = function(dictParallel) {
  var sequential2 = sequential(dictParallel);
  var parallel3 = parallel(dictParallel);
  return function(dictApplicative) {
    var traverse_3 = traverse_(dictApplicative);
    return function(dictFoldable) {
      var traverse_1 = traverse_3(dictFoldable);
      return function(f) {
        var $51 = traverse_1(function($53) {
          return parallel3(f($53));
        });
        return function($52) {
          return sequential2($51($52));
        };
      };
    };
  };
};
var parSequence_ = function(dictParallel) {
  var parTraverse_1 = parTraverse_(dictParallel);
  return function(dictApplicative) {
    var parTraverse_2 = parTraverse_1(dictApplicative);
    return function(dictFoldable) {
      return parTraverse_2(dictFoldable)(identity9);
    };
  };
};

// output/Effect.Aff/index.js
var $runtime_lazy7 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var $$void5 = /* @__PURE__ */ $$void(functorEffect);
var functorParAff = {
  map: _parAffMap
};
var functorAff = {
  map: _map
};
var ffiUtil = /* @__PURE__ */ function() {
  var unsafeFromRight = function(v) {
    if (v instanceof Right) {
      return v.value0;
    }
    ;
    if (v instanceof Left) {
      return unsafeCrashWith("unsafeFromRight: Left");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
  };
  var unsafeFromLeft = function(v) {
    if (v instanceof Left) {
      return v.value0;
    }
    ;
    if (v instanceof Right) {
      return unsafeCrashWith("unsafeFromLeft: Right");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
  };
  var isLeft = function(v) {
    if (v instanceof Left) {
      return true;
    }
    ;
    if (v instanceof Right) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
  };
  return {
    isLeft,
    fromLeft: unsafeFromLeft,
    fromRight: unsafeFromRight,
    left: Left.create,
    right: Right.create
  };
}();
var makeFiber = function(aff) {
  return _makeFiber(ffiUtil, aff);
};
var launchAff = function(aff) {
  return function __do() {
    var fiber = makeFiber(aff)();
    fiber.run();
    return fiber;
  };
};
var launchAff_ = function($75) {
  return $$void5(launchAff($75));
};
var applyParAff = {
  apply: _parAffApply,
  Functor0: function() {
    return functorParAff;
  }
};
var monadAff = {
  Applicative0: function() {
    return applicativeAff;
  },
  Bind1: function() {
    return bindAff;
  }
};
var bindAff = {
  bind: _bind,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var applicativeAff = {
  pure: _pure,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy7("applyAff", "Effect.Aff", function() {
  return {
    apply: ap(monadAff),
    Functor0: function() {
      return functorAff;
    }
  };
});
var applyAff = /* @__PURE__ */ $lazy_applyAff(73);
var pure23 = /* @__PURE__ */ pure(applicativeAff);
var parallelAff = {
  parallel: unsafeCoerce2,
  sequential: _sequential,
  Apply0: function() {
    return applyAff;
  },
  Apply1: function() {
    return applyParAff;
  }
};
var parallel2 = /* @__PURE__ */ parallel(parallelAff);
var applicativeParAff = {
  pure: function($76) {
    return parallel2(pure23($76));
  },
  Apply0: function() {
    return applyParAff;
  }
};
var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableArray);
var semigroupCanceler = {
  append: function(v) {
    return function(v1) {
      return function(err) {
        return parSequence_2([v(err), v1(err)]);
      };
    };
  }
};
var monadEffectAff = {
  liftEffect: _liftEffect,
  Monad0: function() {
    return monadAff;
  }
};
var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure23(unit));
var monoidCanceler = {
  mempty: nonCanceler,
  Semigroup0: function() {
    return semigroupCanceler;
  }
};

// output/Node.FS.Stats/foreign.js
var isDirectoryImpl = (s) => s.isDirectory();

// output/Foreign/foreign.js
function tagOf(value3) {
  return Object.prototype.toString.call(value3).slice(8, -1);
}
var isArray = Array.isArray || function(value3) {
  return Object.prototype.toString.call(value3) === "[object Array]";
};

// output/Foreign/index.js
var TypeMismatch = /* @__PURE__ */ function() {
  function TypeMismatch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeMismatch2.create = function(value0) {
    return function(value12) {
      return new TypeMismatch2(value0, value12);
    };
  };
  return TypeMismatch2;
}();
var unsafeToForeign = unsafeCoerce2;
var unsafeFromForeign = unsafeCoerce2;
var fail3 = function(dictMonad) {
  var $153 = throwError(monadThrowExceptT(dictMonad));
  return function($154) {
    return $153(singleton11($154));
  };
};
var unsafeReadTagged = function(dictMonad) {
  var pure114 = pure(applicativeExceptT(dictMonad));
  var fail1 = fail3(dictMonad);
  return function(tag) {
    return function(value3) {
      if (tagOf(value3) === tag) {
        return pure114(unsafeFromForeign(value3));
      }
      ;
      if (otherwise) {
        return fail1(new TypeMismatch(tag, tagOf(value3)));
      }
      ;
      throw new Error("Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): " + [tag.constructor.name, value3.constructor.name]);
    };
  };
};
var readString = function(dictMonad) {
  return unsafeReadTagged(dictMonad)("String");
};

// output/Node.FS.Stats/index.js
var isDirectory = function(s) {
  return isDirectoryImpl(s);
};

// output/Node.FS.Sync/foreign.js
import {
  accessSync,
  copyFileSync,
  mkdtempSync,
  renameSync,
  truncateSync,
  chownSync,
  chmodSync,
  statSync,
  lstatSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  realpathSync,
  unlinkSync,
  rmdirSync,
  rmSync,
  mkdirSync,
  readdirSync,
  utimesSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  existsSync,
  openSync,
  readSync,
  writeSync,
  fsyncSync,
  closeSync
} from "node:fs";

// output/Effect.Uncurried/foreign.js
var mkEffectFn1 = function mkEffectFn12(fn) {
  return function(x) {
    return fn(x)();
  };
};
var runEffectFn1 = function runEffectFn12(fn) {
  return function(a) {
    return function() {
      return fn(a);
    };
  };
};
var runEffectFn3 = function runEffectFn32(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function() {
          return fn(a, b, c);
        };
      };
    };
  };
};

// output/Node.FS.Constants/foreign.js
import { constants } from "node:fs";
var f_OK = constants.F_OK;
var r_OK = constants.R_OK;
var w_OK = constants.W_OK;
var x_OK = constants.X_OK;
var copyFile_EXCL = constants.COPYFILE_EXCL;
var copyFile_FICLONE = constants.COPYFILE_FICLONE;
var copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;

// output/Node.FS.Sync/index.js
var show5 = /* @__PURE__ */ show(showEncoding);
var stat = function(file) {
  return function() {
    return statSync(file);
  };
};
var readTextFile = function(encoding) {
  return function(file) {
    return function() {
      return readFileSync(file, {
        encoding: show5(encoding)
      });
    };
  };
};

// output/Node.Process/foreign.js
import process2 from "process";
var abortImpl = process2.abort ? () => process2.abort() : null;
var argv = () => process2.argv.slice();
var channelRefImpl = process2.channel && process2.channel.ref ? () => process2.channel.ref() : null;
var channelUnrefImpl = process2.channel && process2.channel.unref ? () => process2.channel.unref() : null;
var debugPort = process2.debugPort;
var disconnectImpl = process2.disconnect ? () => process2.disconnect() : null;
var exitImpl = (code) => process2.exit(code);
var pid = process2.pid;
var platformStr = process2.platform;
var ppid = process2.ppid;
var stdin = process2.stdin;
var stdout = process2.stdout;
var stderr = process2.stderr;
var stdinIsTTY = process2.stdinIsTTY;
var stdoutIsTTY = process2.stdoutIsTTY;
var stderrIsTTY = process2.stderrIsTTY;
var version = process2.version;

// output/Node.Process/index.js
var exit$prime = function(code) {
  return function() {
    return exitImpl(code);
  };
};

// output/Data.String.Regex.Unsafe/index.js
var identity10 = /* @__PURE__ */ identity(categoryFn);
var unsafeRegex = function(s) {
  return function(f) {
    return either(unsafeCrashWith)(identity10)(regex(s)(f));
  };
};

// output/PureScript.CST.Errors/index.js
var UnexpectedEof = /* @__PURE__ */ function() {
  function UnexpectedEof2() {
  }
  ;
  UnexpectedEof2.value = new UnexpectedEof2();
  return UnexpectedEof2;
}();
var ExpectedEof = /* @__PURE__ */ function() {
  function ExpectedEof2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectedEof2.create = function(value0) {
    return new ExpectedEof2(value0);
  };
  return ExpectedEof2;
}();
var UnexpectedToken = /* @__PURE__ */ function() {
  function UnexpectedToken2(value0) {
    this.value0 = value0;
  }
  ;
  UnexpectedToken2.create = function(value0) {
    return new UnexpectedToken2(value0);
  };
  return UnexpectedToken2;
}();
var LexExpected = /* @__PURE__ */ function() {
  function LexExpected2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexExpected2.create = function(value0) {
    return function(value12) {
      return new LexExpected2(value0, value12);
    };
  };
  return LexExpected2;
}();
var LexInvalidCharEscape = /* @__PURE__ */ function() {
  function LexInvalidCharEscape2(value0) {
    this.value0 = value0;
  }
  ;
  LexInvalidCharEscape2.create = function(value0) {
    return new LexInvalidCharEscape2(value0);
  };
  return LexInvalidCharEscape2;
}();
var LexCharEscapeOutOfRange = /* @__PURE__ */ function() {
  function LexCharEscapeOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexCharEscapeOutOfRange2.create = function(value0) {
    return new LexCharEscapeOutOfRange2(value0);
  };
  return LexCharEscapeOutOfRange2;
}();
var LexIntOutOfRange = /* @__PURE__ */ function() {
  function LexIntOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexIntOutOfRange2.create = function(value0) {
    return new LexIntOutOfRange2(value0);
  };
  return LexIntOutOfRange2;
}();
var LexNumberOutOfRange = /* @__PURE__ */ function() {
  function LexNumberOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexNumberOutOfRange2.create = function(value0) {
    return new LexNumberOutOfRange2(value0);
  };
  return LexNumberOutOfRange2;
}();

// output/PureScript.CST.Layout/index.js
var find3 = /* @__PURE__ */ find(foldableList);
var LytRoot = /* @__PURE__ */ function() {
  function LytRoot2() {
  }
  ;
  LytRoot2.value = new LytRoot2();
  return LytRoot2;
}();
var LytTopDecl = /* @__PURE__ */ function() {
  function LytTopDecl2() {
  }
  ;
  LytTopDecl2.value = new LytTopDecl2();
  return LytTopDecl2;
}();
var LytTopDeclHead = /* @__PURE__ */ function() {
  function LytTopDeclHead2() {
  }
  ;
  LytTopDeclHead2.value = new LytTopDeclHead2();
  return LytTopDeclHead2;
}();
var LytDeclGuard = /* @__PURE__ */ function() {
  function LytDeclGuard2() {
  }
  ;
  LytDeclGuard2.value = new LytDeclGuard2();
  return LytDeclGuard2;
}();
var LytCase = /* @__PURE__ */ function() {
  function LytCase2() {
  }
  ;
  LytCase2.value = new LytCase2();
  return LytCase2;
}();
var LytCaseBinders = /* @__PURE__ */ function() {
  function LytCaseBinders2() {
  }
  ;
  LytCaseBinders2.value = new LytCaseBinders2();
  return LytCaseBinders2;
}();
var LytCaseGuard = /* @__PURE__ */ function() {
  function LytCaseGuard2() {
  }
  ;
  LytCaseGuard2.value = new LytCaseGuard2();
  return LytCaseGuard2;
}();
var LytLambdaBinders = /* @__PURE__ */ function() {
  function LytLambdaBinders2() {
  }
  ;
  LytLambdaBinders2.value = new LytLambdaBinders2();
  return LytLambdaBinders2;
}();
var LytParen = /* @__PURE__ */ function() {
  function LytParen2() {
  }
  ;
  LytParen2.value = new LytParen2();
  return LytParen2;
}();
var LytBrace = /* @__PURE__ */ function() {
  function LytBrace2() {
  }
  ;
  LytBrace2.value = new LytBrace2();
  return LytBrace2;
}();
var LytSquare = /* @__PURE__ */ function() {
  function LytSquare2() {
  }
  ;
  LytSquare2.value = new LytSquare2();
  return LytSquare2;
}();
var LytIf = /* @__PURE__ */ function() {
  function LytIf2() {
  }
  ;
  LytIf2.value = new LytIf2();
  return LytIf2;
}();
var LytThen = /* @__PURE__ */ function() {
  function LytThen2() {
  }
  ;
  LytThen2.value = new LytThen2();
  return LytThen2;
}();
var LytProperty = /* @__PURE__ */ function() {
  function LytProperty2() {
  }
  ;
  LytProperty2.value = new LytProperty2();
  return LytProperty2;
}();
var LytForall = /* @__PURE__ */ function() {
  function LytForall2() {
  }
  ;
  LytForall2.value = new LytForall2();
  return LytForall2;
}();
var LytTick = /* @__PURE__ */ function() {
  function LytTick2() {
  }
  ;
  LytTick2.value = new LytTick2();
  return LytTick2;
}();
var LytLet = /* @__PURE__ */ function() {
  function LytLet2() {
  }
  ;
  LytLet2.value = new LytLet2();
  return LytLet2;
}();
var LytLetStmt = /* @__PURE__ */ function() {
  function LytLetStmt2() {
  }
  ;
  LytLetStmt2.value = new LytLetStmt2();
  return LytLetStmt2;
}();
var LytWhere = /* @__PURE__ */ function() {
  function LytWhere2() {
  }
  ;
  LytWhere2.value = new LytWhere2();
  return LytWhere2;
}();
var LytOf = /* @__PURE__ */ function() {
  function LytOf2() {
  }
  ;
  LytOf2.value = new LytOf2();
  return LytOf2;
}();
var LytDo = /* @__PURE__ */ function() {
  function LytDo2() {
  }
  ;
  LytDo2.value = new LytDo2();
  return LytDo2;
}();
var LytAdo = /* @__PURE__ */ function() {
  function LytAdo2() {
  }
  ;
  LytAdo2.value = new LytAdo2();
  return LytAdo2;
}();
var lytToken = function(pos) {
  return function(value3) {
    return {
      range: {
        start: pos,
        end: pos
      },
      leadingComments: [],
      trailingComments: [],
      value: value3
    };
  };
};
var isTopDecl = function(tokPos) {
  return function(v) {
    if (v instanceof Cons && (v.value0.value1 instanceof LytWhere && (v.value1 instanceof Cons && (v.value1.value0.value1 instanceof LytRoot && (v.value1.value1 instanceof Nil && tokPos.column === v.value0.value0.column))))) {
      return true;
    }
    ;
    return false;
  };
};
var isIndented = function(v) {
  if (v instanceof LytLet) {
    return true;
  }
  ;
  if (v instanceof LytLetStmt) {
    return true;
  }
  ;
  if (v instanceof LytWhere) {
    return true;
  }
  ;
  if (v instanceof LytOf) {
    return true;
  }
  ;
  if (v instanceof LytDo) {
    return true;
  }
  ;
  if (v instanceof LytAdo) {
    return true;
  }
  ;
  return false;
};
var eqLayoutDelim = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LytRoot && y instanceof LytRoot) {
        return true;
      }
      ;
      if (x instanceof LytTopDecl && y instanceof LytTopDecl) {
        return true;
      }
      ;
      if (x instanceof LytTopDeclHead && y instanceof LytTopDeclHead) {
        return true;
      }
      ;
      if (x instanceof LytDeclGuard && y instanceof LytDeclGuard) {
        return true;
      }
      ;
      if (x instanceof LytCase && y instanceof LytCase) {
        return true;
      }
      ;
      if (x instanceof LytCaseBinders && y instanceof LytCaseBinders) {
        return true;
      }
      ;
      if (x instanceof LytCaseGuard && y instanceof LytCaseGuard) {
        return true;
      }
      ;
      if (x instanceof LytLambdaBinders && y instanceof LytLambdaBinders) {
        return true;
      }
      ;
      if (x instanceof LytParen && y instanceof LytParen) {
        return true;
      }
      ;
      if (x instanceof LytBrace && y instanceof LytBrace) {
        return true;
      }
      ;
      if (x instanceof LytSquare && y instanceof LytSquare) {
        return true;
      }
      ;
      if (x instanceof LytIf && y instanceof LytIf) {
        return true;
      }
      ;
      if (x instanceof LytThen && y instanceof LytThen) {
        return true;
      }
      ;
      if (x instanceof LytProperty && y instanceof LytProperty) {
        return true;
      }
      ;
      if (x instanceof LytForall && y instanceof LytForall) {
        return true;
      }
      ;
      if (x instanceof LytTick && y instanceof LytTick) {
        return true;
      }
      ;
      if (x instanceof LytLet && y instanceof LytLet) {
        return true;
      }
      ;
      if (x instanceof LytLetStmt && y instanceof LytLetStmt) {
        return true;
      }
      ;
      if (x instanceof LytWhere && y instanceof LytWhere) {
        return true;
      }
      ;
      if (x instanceof LytOf && y instanceof LytOf) {
        return true;
      }
      ;
      if (x instanceof LytDo && y instanceof LytDo) {
        return true;
      }
      ;
      if (x instanceof LytAdo && y instanceof LytAdo) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq14 = /* @__PURE__ */ eq(eqLayoutDelim);
var insertLayout = function(v) {
  return function(nextPos) {
    return function(stack) {
      var sepP = function(lytPos) {
        return v.range.start.column === lytPos.column && v.range.start.line !== lytPos.line;
      };
      var pushStack = function(lytPos) {
        return function(lyt) {
          return function(v1) {
            return new Tuple(new Cons(new Tuple(lytPos, lyt), v1.value0), v1.value1);
          };
        };
      };
      var popStack = function(v1) {
        return function(v2) {
          if (v2.value0 instanceof Cons && v1(v2.value0.value0.value1)) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return v2;
        };
      };
      var offsideP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column < lytPos.column;
        };
      };
      var offsideEndP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column <= lytPos.column;
        };
      };
      var insertToken = function(token2) {
        return function(v1) {
          return new Tuple(v1.value0, snoc(v1.value1)(new Tuple(token2, v1.value0)));
        };
      };
      var insertStart = function(lyt) {
        return function(v1) {
          var v2 = find3(function($307) {
            return isIndented(snd($307));
          })(v1.value0);
          if (v2 instanceof Just && nextPos.column <= v2.value0.value0.column) {
            return v1;
          }
          ;
          return insertToken(lytToken(nextPos)(new TokLayoutStart(nextPos.column)))(pushStack(nextPos)(lyt)(v1));
        };
      };
      var insertEnd = function(indent2) {
        return insertToken(lytToken(v.range.start)(new TokLayoutEnd(indent2)));
      };
      var indentedP = $$const(isIndented);
      var indentSepP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && sepP(lytPos);
        };
      };
      var insertSep = function(v1) {
        var sepTok = lytToken(v.range.start)(new TokLayoutSep(v.range.start.column));
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDecl && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDeclHead && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && indentSepP(v1.value0.value0.value0)(v1.value0.value0.value1)) {
          if (v1.value0.value0.value1 instanceof LytOf) {
            return pushStack(v.range.start)(LytCaseBinders.value)(insertToken(sepTok)(v1));
          }
          ;
          return insertToken(sepTok)(v1);
        }
        ;
        return v1;
      };
      var collapse = function(p) {
        var go = function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1, v2) {
              if (v1 instanceof Cons && p(v1.value0.value0)(v1.value0.value1)) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = function() {
                  var $120 = isIndented(v1.value0.value1);
                  if ($120) {
                    return snoc(v2)(new Tuple(lytToken(v.range.start)(new TokLayoutEnd(v1.value0.value0.column)), v1.value1));
                  }
                  ;
                  return v2;
                }();
                return;
              }
              ;
              $tco_done = true;
              return new Tuple(v1, v2);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
        return uncurry(go);
      };
      var insertDefault = function(state2) {
        return insertToken(v)(insertSep(collapse(offsideP)(state2)));
      };
      var insertKwProperty = function(k) {
        return function(state2) {
          var v1 = insertDefault(state2);
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return new Tuple(v1.value0.value1, v1.value1);
          }
          ;
          return k(v1);
        };
      };
      var insert6 = function(v1) {
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "data")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDecl.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq14(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "class")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDeclHead.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq14(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "where")) {
          var whereP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytTopDeclHead) {
            return insertStart(LytWhere.value)(insertToken(v)(new Tuple(v1.value0.value1, v1.value1)));
          }
          ;
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return insertToken(v)(new Tuple(v1.value0.value1, v1.value1));
          }
          ;
          return insertStart(LytWhere.value)(insertToken(v)(collapse(whereP)(v1)));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "in")) {
          var inP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytLet) {
                return false;
              }
              ;
              if (v32 instanceof LytAdo) {
                return false;
              }
              ;
              return isIndented(v32);
            };
          };
          var v2 = collapse(inP)(v1);
          if (v2.value0 instanceof Cons && (v2.value0.value0.value1 instanceof LytLetStmt && (v2.value0.value1 instanceof Cons && v2.value0.value1.value0.value1 instanceof LytAdo))) {
            return insertToken(v)(insertEnd(v2.value0.value1.value0.value0.column)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1.value1, v2.value1))));
          }
          ;
          if (v2.value0 instanceof Cons && isIndented(v2.value0.value0.value1)) {
            return insertToken(v)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq14(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "let")) {
          var next2 = function(v22) {
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytDo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytAdo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            return insertStart(LytLet.value)(v22);
          };
          return insertKwProperty(next2)(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "do") {
          return insertKwProperty(insertStart(LytDo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "ado") {
          return insertKwProperty(insertStart(LytAdo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "case")) {
          return insertKwProperty(pushStack(v.range.start)(LytCase.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "of")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytCase) {
            return pushStack(nextPos)(LytCaseBinders.value)(insertStart(LytOf.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1))));
          }
          ;
          return popStack(function(v32) {
            return eq14(v32)(LytProperty.value);
          })(insertDefault(v2));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "if")) {
          return insertKwProperty(pushStack(v.range.start)(LytIf.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "then")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytIf) {
            return pushStack(v.range.start)(LytThen.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq14(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "else")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytThen) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          var v3 = collapse(offsideP)(v1);
          if (isTopDecl(v.range.start)(v3.value0)) {
            return insertToken(v)(v3);
          }
          ;
          return popStack(function(v4) {
            return eq14(v4)(LytProperty.value);
          })(insertToken(v)(insertSep(v3)));
        }
        ;
        if (v.value instanceof TokForall) {
          return insertKwProperty(pushStack(v.range.start)(LytForall.value))(v1);
        }
        ;
        if (v.value instanceof TokBackslash) {
          return pushStack(v.range.start)(LytLambdaBinders.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightArrow) {
          var guardP = function(v22) {
            if (v22 instanceof LytCaseBinders) {
              return true;
            }
            ;
            if (v22 instanceof LytCaseGuard) {
              return true;
            }
            ;
            if (v22 instanceof LytLambdaBinders) {
              return true;
            }
            ;
            return false;
          };
          var arrowP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              if (v32 instanceof LytOf) {
                return false;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          return insertToken(v)(popStack(guardP)(collapse(arrowP)(v1)));
        }
        ;
        if (v.value instanceof TokEquals) {
          var equalsP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytWhere) {
                return true;
              }
              ;
              if (v32 instanceof LytLet) {
                return true;
              }
              ;
              if (v32 instanceof LytLetStmt) {
                return true;
              }
              ;
              return false;
            };
          };
          var v2 = collapse(equalsP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytDeclGuard) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokPipe) {
          var v2 = collapse(offsideEndP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytOf) {
            return insertToken(v)(pushStack(v.range.start)(LytCaseGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLet) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLetStmt) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytWhere) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokTick) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytTick) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return pushStack(v.range.start)(LytTick.value)(insertToken(v)(insertSep(collapse(offsideEndP)(v1))));
        }
        ;
        if (v.value instanceof TokComma) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytBrace) {
            return pushStack(v.range.start)(LytProperty.value)(insertToken(v)(v2));
          }
          ;
          return insertToken(v)(v2);
        }
        ;
        if (v.value instanceof TokDot) {
          var v2 = insertDefault(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytForall) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return pushStack(v.range.start)(LytProperty.value)(v2);
        }
        ;
        if (v.value instanceof TokLeftParen) {
          return pushStack(v.range.start)(LytParen.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLeftBrace) {
          return pushStack(v.range.start)(LytProperty.value)(pushStack(v.range.start)(LytBrace.value)(insertDefault(v1)));
        }
        ;
        if (v.value instanceof TokLeftSquare) {
          return pushStack(v.range.start)(LytSquare.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightParen) {
          return insertToken(v)(popStack(function(v22) {
            return eq14(v22)(LytParen.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokRightBrace) {
          return insertToken(v)(popStack(function(v22) {
            return eq14(v22)(LytBrace.value);
          })(popStack(function(v22) {
            return eq14(v22)(LytProperty.value);
          })(collapse(indentedP)(v1))));
        }
        ;
        if (v.value instanceof TokRightSquare) {
          return insertToken(v)(popStack(function(v22) {
            return eq14(v22)(LytSquare.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokString) {
          return popStack(function(v22) {
            return eq14(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
          return popStack(function(v22) {
            return eq14(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokOperator) {
          return insertToken(v)(insertSep(collapse(offsideEndP)(v1)));
        }
        ;
        return insertDefault(v1);
      };
      return insert6(new Tuple(stack, []));
    };
  };
};
var currentIndent = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Cons) {
        if (isIndented(v.value0.value1)) {
          $tco_done = true;
          return new Just(v.value0.value0);
        }
        ;
        if (otherwise) {
          $copy_v = v.value1;
          return;
        }
        ;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return go;
}();

// output/PureScript.CST.TokenStream/index.js
var TokenEOF = /* @__PURE__ */ function() {
  function TokenEOF2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokenEOF2.create = function(value0) {
    return function(value12) {
      return new TokenEOF2(value0, value12);
    };
  };
  return TokenEOF2;
}();
var TokenError = /* @__PURE__ */ function() {
  function TokenError2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  TokenError2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new TokenError2(value0, value12, value22, value3);
        };
      };
    };
  };
  return TokenError2;
}();
var TokenCons = /* @__PURE__ */ function() {
  function TokenCons2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  TokenCons2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new TokenCons2(value0, value12, value22, value3);
        };
      };
    };
  };
  return TokenCons2;
}();
var step2 = /* @__PURE__ */ function() {
  var $32 = unwrap();
  return function($33) {
    return force($32($33));
  };
}();
var unwindLayout = function(pos) {
  return function(eof3) {
    var go = function(stk) {
      return defer2(function(v) {
        if (stk instanceof Nil) {
          return step2(eof3);
        }
        ;
        if (stk instanceof Cons) {
          if (stk.value0.value1 instanceof LytRoot) {
            return step2(eof3);
          }
          ;
          if (isIndented(stk.value0.value1)) {
            return new TokenCons(lytToken(pos)(new TokLayoutEnd(stk.value0.value0.column)), pos, go(stk.value1), stk.value1);
          }
          ;
          if (otherwise) {
            return step2(go(stk.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 59, column 7 - line 66, column 27): " + [stk.value0.value1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 56, column 43 - line 66, column 27): " + [stk.constructor.name]);
      });
    };
    return go;
  };
};
var layoutStack = function(stream2) {
  var v = step2(stream2);
  if (v instanceof TokenEOF) {
    return Nil.value;
  }
  ;
  if (v instanceof TokenError) {
    return v.value3;
  }
  ;
  if (v instanceof TokenCons) {
    return v.value3;
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 48, column 22 - line 51, column 29): " + [v.constructor.name]);
};
var consTokens = function(dictFoldable) {
  var go = function(v) {
    return function(v1) {
      return new Tuple(v.value0.range.start, defer2(function(v2) {
        return new TokenCons(v.value0, v1.value0, v1.value1, v.value1);
      }));
    };
  };
  return flip(foldr(dictFoldable)(go));
};

// output/PureScript.CST.Lexer/index.js
var add2 = /* @__PURE__ */ add(semiringInt);
var div3 = /* @__PURE__ */ div(euclideanRingInt);
var foldMap3 = /* @__PURE__ */ foldMap(foldableArray)(monoidArray);
var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindMaybe);
var foldMap13 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidString);
var fold5 = /* @__PURE__ */ fold(foldableMaybe)(monoidString);
var fold13 = /* @__PURE__ */ fold(foldableArray)(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "raw";
  }
})(monoidString)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "string";
  }
})(monoidString)()(monoidRecordNil))));
var foldl3 = /* @__PURE__ */ foldl(foldableArray);
var consTokens2 = /* @__PURE__ */ consTokens(foldableArray);
var LexFail = /* @__PURE__ */ function() {
  function LexFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexFail2.create = function(value0) {
    return function(value12) {
      return new LexFail2(value0, value12);
    };
  };
  return LexFail2;
}();
var LexSucc = /* @__PURE__ */ function() {
  function LexSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexSucc2.create = function(value0) {
    return function(value12) {
      return new LexSucc2(value0, value12);
    };
  };
  return LexSucc2;
}();
var Lex = function(x) {
  return x;
};
var isCharCodePoint = {
  fromChar: codePointFromChar,
  fromCharCode: /* @__PURE__ */ toEnum(boundedEnumCodePoint)
};
var isCharChar = {
  fromChar: /* @__PURE__ */ identity(categoryFn),
  fromCharCode: fromCharCode3
};
var $$try4 = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      return new LexFail(v1.value0, str2);
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(v1.value0, v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 104, column 3 - line 106, column 31): " + [v1.constructor.name]);
  };
};
var toModuleName = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(dropRight(1)(v));
};
var qualLength = /* @__PURE__ */ maybe(0)(/* @__PURE__ */ function() {
  var $319 = add2(1);
  var $320 = unwrap();
  return function($321) {
    return $319(length5($320($321)));
  };
}());
var optional = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      if (length4(str2) === length4(v1.value1)) {
        return new LexSucc(Nothing.value, str2);
      }
      ;
      if (otherwise) {
        return new LexFail(v1.value0, v1.value1);
      }
      ;
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(new Just(v1.value0), v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 153, column 3 - line 160, column 25): " + [v1.constructor.name]);
  };
};
var mkUnexpected = function(str2) {
  var start = take3(6)(str2);
  var len = length5(start);
  var $148 = len === 0;
  if ($148) {
    return "end of file";
  }
  ;
  var $149 = len < 6;
  if ($149) {
    return start;
  }
  ;
  return start + "...";
};
var regex3 = function(mkErr) {
  return function(regexStr) {
    var matchRegex = unsafeRegex("^(?:" + (regexStr + ")"))(unicode);
    return function(str2) {
      var v = match(matchRegex)(str2);
      var v1 = function(v2) {
        return new LexFail(function(v3) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
      if (v instanceof Just) {
        var $151 = head2(v.value0);
        if ($151 instanceof Just) {
          return new LexSucc($151.value0, drop2(length4($151.value0))(str2));
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    };
  };
};
var shebangComment = /* @__PURE__ */ function() {
  return regex3(LexExpected.create("shebang"))("#![^\\r\\n]*");
}();
var satisfy2 = function(mkErr) {
  return function(p) {
    return function(str2) {
      var v = charAt2(0)(str2);
      if (v instanceof Just && p(v.value0)) {
        return new LexSucc(v.value0, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v1) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var string3 = function(mkErr) {
  return function(match3) {
    return function(str2) {
      var $156 = take2(length4(match3))(str2) === match3;
      if ($156) {
        return new LexSucc(match3, drop2(length4(match3))(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var many = function(v) {
  return function(str2) {
    return function __do() {
      var valuesRef = newSTArray();
      var strRef = str2;
      var contRef = true;
      var resRef = new LexSucc([], str2);
      (function() {
        while (contRef) {
          (function __do2() {
            var str$prime = strRef;
            var v1 = v(str$prime);
            if (v1 instanceof LexFail) {
              if (length4(str$prime) === length4(v1.value1)) {
                var values2 = unsafeFreeze(valuesRef)();
                resRef = new LexSucc(values2, v1.value1);
                contRef = false;
                return unit;
              }
              ;
              if (otherwise) {
                resRef = new LexFail(v1.value0, v1.value1);
                contRef = false;
                return unit;
              }
              ;
            }
            ;
            if (v1 instanceof LexSucc) {
              push(v1.value0)(valuesRef)();
              strRef = v1.value1;
              return unit;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 178, column 5 - line 192, column 18): " + [v1.constructor.name]);
          })();
        }
        ;
        return {};
      })();
      return resRef;
    }();
  };
};
var functorLex = {
  map: function(f) {
    return function(v) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          return new LexSucc(f(v1.value0), v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 66, column 5 - line 68, column 37): " + [v1.constructor.name]);
      };
    };
  }
};
var map21 = /* @__PURE__ */ map(functorLex);
var spaceComment = /* @__PURE__ */ function() {
  return map21(length4)(regex3(LexExpected.create("spaces"))(" +"));
}();
var fromCharCode4 = function(dict) {
  return dict.fromCharCode;
};
var fromChar = function(dict) {
  return dict.fromChar;
};
var fail4 = function($322) {
  return Lex(LexFail.create($$const($322)));
};
var char$prime = function(mkErr) {
  return function(res) {
    return function(match3) {
      return function(str2) {
        var $172 = singleton6(match3) === take2(1)(str2);
        if ($172) {
          return new LexSucc(res, drop2(1)(str2));
        }
        ;
        return new LexFail(function(v) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
    };
  };
};
var $$char3 = function(mkErr) {
  return function(match3) {
    return function(str2) {
      var $173 = singleton6(match3) === take2(1)(str2);
      if ($173) {
        return new LexSucc(match3, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var bumpText = function(v) {
  return function(colOffset) {
    return function(str2) {
      var go = function($copy_n) {
        return function($copy_ix) {
          var $tco_var_n = $copy_n;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(n, ix) {
            var v1 = indexOf$prime("\n")(ix)(str2);
            if (v1 instanceof Just) {
              $tco_var_n = n + 1 | 0;
              $copy_ix = v1.value0 + 1 | 0;
              return;
            }
            ;
            if (v1 instanceof Nothing) {
              if (n === 0) {
                $tco_done = true;
                return {
                  line: v.line,
                  column: (v.column + length5(str2) | 0) + (colOffset * 2 | 0) | 0
                };
              }
              ;
              if (otherwise) {
                $tco_done = true;
                return {
                  line: v.line + n | 0,
                  column: length5(drop2(ix)(str2)) + colOffset | 0
                };
              }
              ;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 348, column 13 - line 357, column 12): " + [v1.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_n, $copy_ix);
          }
          ;
          return $tco_result;
        };
      };
      return go(0)(0);
    };
  };
};
var bumpToken = function(v) {
  return function(v1) {
    if (v1 instanceof TokLeftParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 6 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokEquals) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokPipe) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokTick) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDot) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokComma) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokUnderscore) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokBackslash) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokAt) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLowerName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokUpperName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokOperator) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolName) {
      return {
        line: v.line,
        column: ((v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 3 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof ASCII) {
      return {
        line: v.line,
        column: v.column + 4 | 0
      };
    }
    ;
    if (v1 instanceof TokHole) {
      return {
        line: v.line,
        column: (v.column + length5(v1.value0) | 0) + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokChar) {
      return {
        line: v.line,
        column: (v.column + length5(v1.value0) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokInt) {
      return {
        line: v.line,
        column: v.column + length5(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokNumber) {
      return {
        line: v.line,
        column: v.column + length5(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokString) {
      return bumpText(v)(1)(v1.value0);
    }
    ;
    if (v1 instanceof TokRawString) {
      return bumpText(v)(3)(v1.value0);
    }
    ;
    if (v1 instanceof TokLayoutStart) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutSep) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutEnd) {
      return v;
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 265, column 34 - line 343, column 8): " + [v1.constructor.name]);
  };
};
var bumpComment = function(v) {
  return function(v1) {
    if (v1 instanceof Comment) {
      return bumpText(v)(0)(v1.value0);
    }
    ;
    if (v1 instanceof Space) {
      return {
        line: v.line,
        column: v.column + v1.value0 | 0
      };
    }
    ;
    if (v1 instanceof Line) {
      return {
        line: v.line + v1.value1 | 0,
        column: 0
      };
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 360, column 36 - line 366, column 34): " + [v1.constructor.name]);
  };
};
var applyLex = {
  apply: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          return new LexFail(v2.value0, v2.value1);
        }
        ;
        if (v2 instanceof LexSucc) {
          var v3 = v1(v2.value1);
          if (v3 instanceof LexFail) {
            return new LexFail(v3.value0, v3.value1);
          }
          ;
          if (v3 instanceof LexSucc) {
            return new LexSucc(v2.value0(v3.value0), v3.value1);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 75, column 9 - line 78, column 32): " + [v3.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 72, column 5 - line 78, column 32): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var apply4 = /* @__PURE__ */ apply(applyLex);
var applyFirst2 = /* @__PURE__ */ applyFirst(applyLex);
var applySecond2 = /* @__PURE__ */ applySecond(applyLex);
var bindLex = {
  bind: function(v) {
    return function(k) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          var v2 = k(v1.value0);
          return v2(v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 85, column 5 - line 89, column 16): " + [v1.constructor.name]);
      };
    };
  },
  Apply0: function() {
    return applyLex;
  }
};
var bind12 = /* @__PURE__ */ bind(bindLex);
var applicativeLex = {
  pure: function($323) {
    return Lex(LexSucc.create($323));
  },
  Apply0: function() {
    return applyLex;
  }
};
var pure1 = /* @__PURE__ */ pure(applicativeLex);
var altLex = {
  alt: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          if (length4(str2) === length4(v2.value1)) {
            return v1(str2);
          }
          ;
          if (otherwise) {
            return new LexFail(v2.value0, v2.value1);
          }
          ;
        }
        ;
        if (v2 instanceof LexSucc) {
          return new LexSucc(v2.value0, v2.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 93, column 5 - line 100, column 20): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var alt5 = /* @__PURE__ */ alt(altLex);
var comment = /* @__PURE__ */ function() {
  return alt5(regex3(LexExpected.create("block comment"))("\\{-(-(?!\\})|[^-]+)*(-\\}|$)"))(regex3(LexExpected.create("line comment"))("--[^\\r\\n]*"));
}();
var lineComment = /* @__PURE__ */ function() {
  return alt5(map21(function() {
    var $324 = Line.create(LF.value);
    return function($325) {
      return $324(length5($325));
    };
  }())(regex3(LexExpected.create("newline"))("\n+")))(map21(function() {
    var $326 = Line.create(CRLF.value);
    return function($327) {
      return $326(function(v) {
        return div3(v)(2);
      }(length5($327)));
    };
  }())(regex3(LexExpected.create("newline"))("(?:\r\n)+")));
}();
var leadingComments = /* @__PURE__ */ function() {
  return many(alt5(map21(Comment.create)(comment))(alt5(map21(Space.create)(spaceComment))(lineComment)));
}();
var oneLineComment = /* @__PURE__ */ bind12(lineComment)(function(line2) {
  if (line2 instanceof Line && line2.value1 === 1) {
    return pure1(line2);
  }
  ;
  return fail4(new LexExpected("one newline", "multiple newlines"));
});
var leadingShebangs = /* @__PURE__ */ function() {
  return apply4(map21(function(v) {
    return function(v1) {
      return cons(new Comment(v))(foldMap3(function(v2) {
        return [v2.value0, new Comment(v2.value1)];
      })(v1));
    };
  })(shebangComment))(many($$try4(apply4(map21(Tuple.create)(oneLineComment))(shebangComment))));
}();
var leadingModuleComments = /* @__PURE__ */ apply4(/* @__PURE__ */ map21(/* @__PURE__ */ append(semigroupArray))(/* @__PURE__ */ alt5(leadingShebangs)(/* @__PURE__ */ pure1([]))))(leadingComments);
var token = /* @__PURE__ */ function() {
  var tokenTick = char$prime(LexExpected.create("backtick"))(TokTick.value)("`");
  var tokenRightSquare = char$prime(LexExpected.create("right square"))(TokRightSquare.value)("]");
  var tokenRightParen = char$prime(LexExpected.create("right paren"))(TokRightParen.value)(")");
  var tokenRightBrace = char$prime(LexExpected.create("right brace"))(TokRightBrace.value)("}");
  var tokenLeftSquare = char$prime(LexExpected.create("left square"))(TokLeftSquare.value)("[");
  var tokenLeftParen = char$prime(LexExpected.create("left paren"))(TokLeftParen.value)("(");
  var tokenLeftBrace = char$prime(LexExpected.create("left brace"))(TokLeftBrace.value)("{");
  var tokenComma = char$prime(LexExpected.create("comma"))(TokComma.value)(",");
  var stripUnderscores = replaceAll("_")("");
  var stringSpaceEscapeRegex = regex3(LexExpected.create("whitespace escape"))("\\\\[ \\r\\n]+\\\\");
  var stringCharsRegex = regex3(LexExpected.create("string characters"))('[^"\\\\]+');
  var rawStringCharsRegex = regex3(LexExpected.create("raw string characters"))('""""{0,2}([^"]+"{1,2})*[^"]*"""');
  var parseSymbolIdent = regex3(LexExpected.create("symbol"))("(?:[:!#$%&*+./<=>?@\\\\^|~-]|(?!\\p{P})\\p{S})+");
  var parseSymbol2 = map21(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "->") {
          return new TokSymbolArrow(ASCII.value);
        }
        ;
        if (v === "\u2192") {
          return new TokSymbolArrow(Unicode.value);
        }
        ;
        return new TokSymbolName(Nothing.value, v);
      }
      ;
      return new TokSymbolName(v1, v);
    };
  })($$try4(applyFirst2(applySecond2(tokenLeftParen)(parseSymbolIdent))(tokenRightParen)));
  var parseStringSpaceEscape = map21(function(v) {
    return {
      raw: v,
      string: ""
    };
  })(stringSpaceEscapeRegex);
  var parseStringChars = map21(function(v) {
    return {
      raw: v,
      string: v
    };
  })(stringCharsRegex);
  var parseRawString = map21(function(v) {
    return new TokRawString(dropRight(3)(drop2(3)(v)));
  })(rawStringCharsRegex);
  var parseProper2 = regex3(LexExpected.create("proper name"))("\\p{Lu}[\\p{L}0-9_']*");
  var parseUpper = map21(flip(TokUpperName.create))(parseProper2);
  var parseOperator2 = map21(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "<-") {
          return new TokLeftArrow(ASCII.value);
        }
        ;
        if (v === "\u2190") {
          return new TokLeftArrow(Unicode.value);
        }
        ;
        if (v === "->") {
          return new TokRightArrow(ASCII.value);
        }
        ;
        if (v === "\u2192") {
          return new TokRightArrow(Unicode.value);
        }
        ;
        if (v === "=>") {
          return new TokRightFatArrow(ASCII.value);
        }
        ;
        if (v === "\u21D2") {
          return new TokRightFatArrow(Unicode.value);
        }
        ;
        if (v === "::") {
          return new TokDoubleColon(ASCII.value);
        }
        ;
        if (v === "\u2237") {
          return new TokDoubleColon(Unicode.value);
        }
        ;
        if (v === "\u2200") {
          return new TokForall(Unicode.value);
        }
        ;
        if (v === "=") {
          return TokEquals.value;
        }
        ;
        if (v === ".") {
          return TokDot.value;
        }
        ;
        if (v === "\\") {
          return TokBackslash.value;
        }
        ;
        if (v === "|") {
          return TokPipe.value;
        }
        ;
        if (v === "@") {
          return TokAt.value;
        }
        ;
        if (v === "`") {
          return TokTick.value;
        }
        ;
        return new TokOperator(Nothing.value, v);
      }
      ;
      return new TokOperator(v1, v);
    };
  })(parseSymbolIdent);
  var parseModuleNamePrefix = regex3(LexExpected.create("module name"))("(?:(?:\\p{Lu}[\\p{L}0-9_']*)\\.)*");
  var parseIdent2 = regex3(LexExpected.create("ident"))("[\\p{Ll}_][\\p{L}0-9_']*");
  var parseLower = map21(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "forall") {
          return new TokForall(ASCII.value);
        }
        ;
        if (v === "_") {
          return TokUnderscore.value;
        }
        ;
        return new TokLowerName(Nothing.value, v);
      }
      ;
      return new TokLowerName(v1, v);
    };
  })(parseIdent2);
  var parseName = alt5(parseLower)(alt5(parseUpper)(alt5(parseOperator2)(parseSymbol2)));
  var parseModuleName2 = apply4(map21(function(v) {
    return function(v1) {
      return v1(toModuleName(v));
    };
  })(parseModuleNamePrefix))(parseName);
  var parseExponentSign = alt5(string3(LexExpected.create("negative"))("-"))(string3(LexExpected.create("positive"))("+"));
  var intPartRegex = regex3(LexExpected.create("int part"))("(0|[1-9][0-9_]*)");
  var parseExponentPart = apply4(map21(function(v) {
    return function(v1) {
      return {
        sign: v,
        exponent: v1
      };
    };
  })(optional(parseExponentSign)))(intPartRegex);
  var hexIntRegex = regex3(LexExpected.create("hex int"))("[a-fA-F0-9]+");
  var hexIntPrefix = string3(LexExpected.create("hex int prefix"))("0x");
  var parseHexInt = bind12(applySecond2(hexIntPrefix)(hexIntRegex))(function(raw) {
    var v = fromStringAs(hexadecimal)(raw);
    if (v instanceof Just) {
      return pure1(new TokInt("0x" + raw, new SmallInt(v.value0)));
    }
    ;
    if (v instanceof Nothing) {
      return pure1(new TokInt("0x" + raw, new BigHex(raw)));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 631, column 5 - line 635, column 49): " + [v.constructor.name]);
  });
  var hexEscapeRegex = regex3(LexExpected.create("hex"))("[a-fA-F0-9]{1,6}");
  var parseHexEscape = function(dictIsChar) {
    var fromCharCode1 = fromCharCode4(dictIsChar);
    return bind12(hexEscapeRegex)(function(esc) {
      var v = bindFlipped3(fromCharCode1)(fromStringAs(hexadecimal)(esc));
      if (v instanceof Just) {
        return pure1({
          raw: "\\x" + esc,
          "char": v.value0
        });
      }
      ;
      if (v instanceof Nothing) {
        return fail4(new LexCharEscapeOutOfRange(esc));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Lexer (line 579, column 5 - line 583, column 43): " + [v.constructor.name]);
    });
  };
  var fractionPartRegex = regex3(LexExpected.create("fraction part"))("[0-9_]+");
  var charSingleQuote = $$char3(LexExpected.create("single quote"))("'");
  var charQuote = $$char3(LexExpected.create("quote"))('"');
  var charQuestionMark = $$char3(LexExpected.create("question mark"))("?");
  var parseHole2 = map21(function(v) {
    return new TokHole(v);
  })($$try4(applySecond2(charQuestionMark)(alt5(parseIdent2)(parseProper2))));
  var charExponent = $$char3(LexExpected.create("exponent"))("e");
  var parseNumberExponentPart = optional(applySecond2(charExponent)(parseExponentPart));
  var charDot = $$char3(LexExpected.create("dot"))(".");
  var parseNumberFractionPart = optional($$try4(applySecond2(charDot)(fractionPartRegex)));
  var parseNumber2 = bind12(intPartRegex)(function(intPart) {
    return bind12(parseNumberFractionPart)(function(fractionPart) {
      return bind12(parseNumberExponentPart)(function(exponentPart) {
        var $282 = isNothing(fractionPart) && isNothing(exponentPart);
        if ($282) {
          var intVal = stripUnderscores(intPart);
          var v = fromString3(intVal);
          if (v instanceof Just) {
            return pure1(new TokInt(intPart, new SmallInt(v.value0)));
          }
          ;
          if (v instanceof Nothing) {
            return pure1(new TokInt(intPart, new BigInt2(intVal)));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 643, column 7 - line 647, column 48): " + [v.constructor.name]);
        }
        ;
        var raw = intPart + (foldMap13(function(fr) {
          return "." + fr;
        })(fractionPart) + foldMap13(function(ex) {
          return "e" + (fold5(ex.sign) + ex.exponent);
        })(exponentPart));
        var v = fromString2(stripUnderscores(raw));
        if (v instanceof Just) {
          return pure1(new TokNumber(raw, v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return fail4(new LexNumberOutOfRange(raw));
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 654, column 7 - line 658, column 41): " + [v.constructor.name]);
      });
    });
  });
  var parseNumericLiteral = alt5(parseHexInt)(parseNumber2);
  var charBackslash = $$char3(LexExpected.create("backslash"))("\\");
  var charAny = satisfy2(LexExpected.create("char"))($$const(true));
  var parseEscape = function(dictIsChar) {
    var fromChar1 = fromChar(dictIsChar);
    var parseHexEscape1 = parseHexEscape(dictIsChar);
    return bind12(charAny)(function(ch) {
      if (ch === "t") {
        return pure1({
          raw: "\\t",
          "char": fromChar1("	")
        });
      }
      ;
      if (ch === "r") {
        return pure1({
          raw: "\\r",
          "char": fromChar1("\r")
        });
      }
      ;
      if (ch === "n") {
        return pure1({
          raw: "\\n",
          "char": fromChar1("\n")
        });
      }
      ;
      if (ch === '"') {
        return pure1({
          raw: '\\"',
          "char": fromChar1('"')
        });
      }
      ;
      if (ch === "'") {
        return pure1({
          raw: "\\'",
          "char": fromChar1("'")
        });
      }
      ;
      if (ch === "\\") {
        return pure1({
          raw: "\\\\",
          "char": fromChar1("\\")
        });
      }
      ;
      if (ch === "x") {
        return parseHexEscape1;
      }
      ;
      return fail4(new LexInvalidCharEscape(singleton6(ch)));
    });
  };
  var parseEscape1 = parseEscape(isCharChar);
  var parseChar2 = bind12(charAny)(function(ch) {
    if (ch === "\\") {
      return parseEscape1;
    }
    ;
    if (ch === "'") {
      return fail4(new LexExpected("character", "empty character literal"));
    }
    ;
    return pure1({
      raw: singleton6(ch),
      "char": ch
    });
  });
  var parseCharLiteral = map21(function(v) {
    return new TokChar(v.raw, v["char"]);
  })(applyFirst2(applySecond2(charSingleQuote)(parseChar2))(charSingleQuote));
  var parseStringEscape = map21(function(v) {
    return {
      raw: v.raw,
      string: singleton7(v["char"])
    };
  })(applySecond2(charBackslash)(parseEscape(isCharCodePoint)));
  var parseStringPart = alt5(parseStringChars)(alt5(parseStringSpaceEscape)(parseStringEscape));
  var parseString2 = map21(function(v) {
    var v1 = fold13(v);
    return new TokString(v1.raw, v1.string);
  })(applyFirst2(applySecond2(charQuote)(many(parseStringPart)))(charQuote));
  var parseStringLiteral = alt5(parseRawString)(parseString2);
  return alt5(parseHole2)(alt5(parseModuleName2)(alt5(parseCharLiteral)(alt5(parseStringLiteral)(alt5(parseNumericLiteral)(alt5(tokenLeftParen)(alt5(tokenRightParen)(alt5(tokenLeftBrace)(alt5(tokenRightBrace)(alt5(tokenLeftSquare)(alt5(tokenRightSquare)(alt5(tokenTick)(tokenComma))))))))))));
}();
var trailingComments = /* @__PURE__ */ function() {
  return many(alt5(map21(Comment.create)(comment))(map21(Space.create)(spaceComment)));
}();
var lexWithState$prime = function(lexLeadingComments) {
  var token$prime = apply4(apply4(map21(function(v) {
    return function(v1) {
      return function(v2) {
        return {
          token: v,
          trailing: v1,
          nextLeading: v2
        };
      };
    };
  })(token))(trailingComments))(leadingComments);
  var go = function(stack) {
    return function(startPos) {
      return function(leading) {
        return function(str2) {
          return defer2(function(v) {
            var $303 = str2 === "";
            if ($303) {
              return step2(unwindLayout(startPos)(defer2(function(v12) {
                return new TokenEOF(startPos, leading);
              }))(stack));
            }
            ;
            var v1 = token$prime(str2);
            if (v1 instanceof LexFail) {
              var errPos = bumpText(startPos)(0)(take2(length4(str2) - length4(v1.value1) | 0)(str2));
              return new TokenError(errPos, v1.value0(unit), Nothing.value, stack);
            }
            ;
            if (v1 instanceof LexSucc) {
              var endPos = bumpToken(startPos)(v1.value0.token);
              var nextStart = foldl3(bumpComment)(foldl3(bumpComment)(endPos)(v1.value0.trailing))(v1.value0.nextLeading);
              var posToken = {
                range: {
                  start: startPos,
                  end: endPos
                },
                leadingComments: leading,
                trailingComments: v1.value0.trailing,
                value: v1.value0.token
              };
              var v2 = insertLayout(posToken)(nextStart)(stack);
              return step2(snd(consTokens2(v2.value1)(new Tuple(nextStart, go(v2.value0)(nextStart)(v1.value0.nextLeading)(v1.value1)))));
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 228, column 7 - line 247, column 63): " + [v1.constructor.name]);
          });
        };
      };
    };
  };
  var init3 = function(initStack) {
    return function(initPos) {
      return function(str2) {
        return defer2(function(v) {
          var v1 = lexLeadingComments(str2);
          if (v1 instanceof LexFail) {
            return unsafeCrashWith("Leading comments can't fail.");
          }
          ;
          if (v1 instanceof LexSucc) {
            var nextPos = foldl3(bumpComment)(initPos)(v1.value0);
            return step2(go(initStack)(nextPos)(v1.value0)(v1.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 215, column 5 - line 220, column 51): " + [v1.constructor.name]);
        });
      };
    };
  };
  return init3;
};
var lexModule = /* @__PURE__ */ function() {
  return lexWithState$prime(leadingModuleComments)(new Cons(new Tuple({
    line: 0,
    column: 0
  }, LytRoot.value), Nil.value))({
    line: 0,
    column: 0
  });
}();

// output/PureScript.CST.Parser.Monad/index.js
var $runtime_lazy8 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var toUnfoldable10 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var More2 = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Done2 = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var ParseFail = /* @__PURE__ */ function() {
  function ParseFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseFail2.create = function(value0) {
    return function(value12) {
      return new ParseFail2(value0, value12);
    };
  };
  return ParseFail2;
}();
var ParseSucc = /* @__PURE__ */ function() {
  function ParseSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucc2.create = function(value0) {
    return function(value12) {
      return new ParseSucc2(value0, value12);
    };
  };
  return ParseSucc2;
}();
var lazyParser = {
  defer: function(k) {
    var parser = defer2(k);
    return function(state2, more, resume, done) {
      var v = force(parser);
      return v(state2, more, resume, done);
    };
  }
};
var functorParser = {
  map: function(f) {
    return function(v) {
      return function(state1, more, resume, done) {
        return v(state1, more, resume, function(state2, a) {
          return done(state2, f(a));
        });
      };
    };
  }
};
var map24 = /* @__PURE__ */ map(functorParser);
var applyParser = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, resume, done) {
        return v(state1, more, resume, function(state2, f) {
          return more(function(v2) {
            return v1(state2, more, resume, function(state3, a) {
              return done(state3, f(a));
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var bindParser = {
  bind: function(v) {
    return function(k) {
      return function(state1, more, resume, done) {
        return v(state1, more, resume, function(state2, a) {
          return more(function(v1) {
            var v2 = k(a);
            return v2(state2, more, resume, done);
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var applicativeParser = {
  pure: function(a) {
    return function(state1, v, v1, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var pure8 = /* @__PURE__ */ pure(applicativeParser);
var altParser = {
  alt: function(v) {
    return function(v1) {
      return function(state1, more, resume, done) {
        var state2 = function() {
          if (state1.consumed) {
            return {
              errors: state1.errors,
              stream: state1.stream,
              consumed: false
            };
          }
          ;
          return state1;
        }();
        return v(state2, more, function(state3, error5) {
          if (state3.consumed) {
            return resume(state3, error5);
          }
          ;
          return v1(state1, more, resume, done);
        }, done);
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var alt6 = /* @__PURE__ */ alt(altParser);
var $$try5 = function(v) {
  return function(state1, more, resume, done) {
    return v(state1, more, function(state2, error5) {
      return resume({
        errors: state2.errors,
        stream: state2.stream,
        consumed: state1.consumed
      }, error5);
    }, done);
  };
};
var take6 = function(k) {
  return function(state2, v, resume, done) {
    var v1 = step2(state2.stream);
    if (v1 instanceof TokenError) {
      return resume(state2, {
        error: v1.value1,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenEOF) {
      return resume(state2, {
        error: UnexpectedEof.value,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenCons) {
      var v2 = k(v1.value0);
      if (v2 instanceof Left) {
        return resume(state2, {
          error: v2.value0,
          position: v1.value0.range.start
        });
      }
      ;
      if (v2 instanceof Right) {
        return done({
          errors: state2.errors,
          consumed: true,
          stream: v1.value2
        }, v2.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 172, column 11 - line 182, column 18): " + [v2.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 166, column 7 - line 182, column 18): " + [v1.constructor.name]);
  };
};
var runParser$prime = function(state1) {
  return function(v) {
    var run3 = function($copy_v1) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v1) {
        if (v1 instanceof More2) {
          $copy_v1 = v1.value0(unit);
          return;
        }
        ;
        if (v1 instanceof Done2) {
          $tco_done = true;
          return v1.value0;
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 241, column 9 - line 243, column 16): " + [v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v1);
      }
      ;
      return $tco_result;
    };
    return run3(v(state1, More2.create, function(state2, error5) {
      return new Done2(new ParseFail(error5, state2));
    }, function(state2, value3) {
      return new Done2(new ParseSucc(value3, state2));
    }));
  };
};
var recover = function(k) {
  return function(v) {
    return function(state1, more, resume, done) {
      return v({
        errors: state1.errors,
        stream: state1.stream,
        consumed: false
      }, more, function(state2, error5) {
        var v1 = k(error5)(state1.stream);
        if (v1 instanceof Nothing) {
          return resume({
            errors: state2.errors,
            stream: state2.stream,
            consumed: state1.consumed
          }, error5);
        }
        ;
        if (v1 instanceof Just) {
          return done({
            consumed: true,
            errors: snoc(state2.errors)(error5),
            stream: v1.value0.value1
          }, v1.value0.value0);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 149, column 13 - line 158, column 20): " + [v1.constructor.name]);
      }, done);
    };
  };
};
var optional2 = function(p) {
  return alt6(map24(Just.create)(p))(pure8(Nothing.value));
};
var many2 = function(v) {
  return function(state1, more, resume, done) {
    var $lazy_go = $runtime_lazy8("go", "PureScript.CST.Parser.Monad", function() {
      return function(acc, state2) {
        var state2$prime = function() {
          if (state2.consumed) {
            return {
              errors: state2.errors,
              stream: state2.stream,
              consumed: false
            };
          }
          ;
          return state2;
        }();
        return v(state2$prime, more, function(state3, error5) {
          if (state3.consumed) {
            return resume(state3, error5);
          }
          ;
          return done(state2, reverse(toUnfoldable10(acc)));
        }, function(state3, value3) {
          return $lazy_go(225)(new Cons(value3, acc), state3);
        });
      };
    });
    var go = $lazy_go(212);
    return go(Nil.value, state1);
  };
};
var lookAhead = function(v) {
  return function(state1, more, resume, done) {
    return v(state1, more, function(v1, error5) {
      return resume(state1, error5);
    }, function(v1, value3) {
      return done(state1, value3);
    });
  };
};
var initialParserState = function(stream2) {
  return {
    consumed: false,
    errors: [],
    stream: stream2
  };
};
var fromParserResult = function(v) {
  if (v instanceof ParseFail) {
    return new Left(v.value0);
  }
  ;
  if (v instanceof ParseSucc) {
    return new Right(new Tuple(v.value0, v.value1.errors));
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 253, column 20 - line 257, column 29): " + [v.constructor.name]);
};
var runParser2 = function(stream2) {
  var $109 = runParser$prime(initialParserState(stream2));
  return function($110) {
    return fromParserResult($109($110));
  };
};
var eof2 = function(state2, v, resume, done) {
  var v1 = step2(state2.stream);
  if (v1 instanceof TokenError) {
    return resume(state2, {
      error: v1.value1,
      position: v1.value0
    });
  }
  ;
  if (v1 instanceof TokenEOF) {
    return done({
      stream: state2.stream,
      errors: state2.errors,
      consumed: true
    }, new Tuple(v1.value0, v1.value1));
  }
  ;
  if (v1 instanceof TokenCons) {
    return resume(state2, {
      error: new ExpectedEof(v1.value0.value),
      position: v1.value0.range.start
    });
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 188, column 7 - line 197, column 14): " + [v1.constructor.name]);
};

// output/PureScript.CST.Parser/index.js
var $runtime_lazy9 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var bind8 = /* @__PURE__ */ bind(bindParser);
var pure9 = /* @__PURE__ */ pure(applicativeParser);
var apply5 = /* @__PURE__ */ apply(applyParser);
var map25 = /* @__PURE__ */ map(functorParser);
var member3 = /* @__PURE__ */ member2(ordString);
var alt7 = /* @__PURE__ */ alt(altParser);
var applyFirst3 = /* @__PURE__ */ applyFirst(applyParser);
var applySecond3 = /* @__PURE__ */ applySecond(applyParser);
var defer3 = /* @__PURE__ */ defer(lazyParser);
var voidRight2 = /* @__PURE__ */ voidRight(functorParser);
var wrapped = function(openTok) {
  return function(closeTok) {
    return function(valueParser) {
      return bind8(openTok)(function(open) {
        return bind8(valueParser)(function(value3) {
          return bind8(closeTok)(function(close) {
            return pure9({
              open,
              value: value3,
              close
            });
          });
        });
      });
    };
  };
};
var separated = function(sepParser) {
  return function(valueParser) {
    return apply5(map25(function(v) {
      return function(v1) {
        return {
          head: v,
          tail: v1
        };
      };
    })(valueParser))(many2(apply5(map25(Tuple.create)(sepParser))(valueParser)));
  };
};
var reservedKeywords = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString)(["ado", "case", "class", "data", "derive", "do", "else", "false", "foreign", "if", "import", "in", "infix", "infixl", "infixr", "instance", "let", "module", "newtype", "of", "then", "true", "type", "where"]);
var recoverTokensWhile = function(p) {
  return function(initStream) {
    var indent2 = maybe(0)(function(v) {
      return v.column;
    })(currentIndent(layoutStack(initStream)));
    var go = function($copy_acc) {
      return function($copy_stream) {
        var $tco_var_acc = $copy_acc;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(acc, stream2) {
          var v = step2(stream2);
          if (v instanceof TokenError) {
            $tco_done = true;
            return new Tuple(acc, stream2);
          }
          ;
          if (v instanceof TokenEOF) {
            $tco_done = true;
            return new Tuple(acc, stream2);
          }
          ;
          if (v instanceof TokenCons) {
            var $135 = p(v.value0)(indent2);
            if ($135) {
              $tco_var_acc = snoc(acc)(v.value0);
              $copy_stream = v.value2;
              return;
            }
            ;
            $tco_done = true;
            return new Tuple(acc, stream2);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 1194, column 19 - line 1203, column 25): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_acc, $copy_stream);
        }
        ;
        return $tco_result;
      };
    };
    return go([])(initStream);
  };
};
var recoverIndent = function(mkNode) {
  return recover(function(v) {
    return function(stream2) {
      var v1 = recoverTokensWhile(function(tok) {
        return function(indent2) {
          if (tok.value instanceof TokLayoutEnd) {
            return tok.value.value0 > indent2;
          }
          ;
          if (tok.value instanceof TokLayoutSep) {
            return tok.value.value0 > indent2;
          }
          ;
          return true;
        };
      })(stream2);
      var $145 = $$null(v1.value0);
      if ($145) {
        return Nothing.value;
      }
      ;
      return new Just(new Tuple(mkNode({
        position: v.position,
        error: v.error,
        tokens: v1.value0
      }), v1.value1));
    };
  });
};
var recoverLetBinding = /* @__PURE__ */ function() {
  return recoverIndent(LetBindingError.create);
}();
var recoverDoStatement = /* @__PURE__ */ function() {
  return recoverIndent(DoError.create);
}();
var recoverDecl = /* @__PURE__ */ function() {
  return recoverIndent(DeclError.create);
}();
var parseSmallInt = /* @__PURE__ */ take6(function(v) {
  if (v.value instanceof TokInt && v.value.value1 instanceof SmallInt) {
    return new Right(new Tuple(v, v.value.value1.value0));
  }
  ;
  if (v.value instanceof TokInt) {
    return new Left(new LexIntOutOfRange(v.value.value0));
  }
  ;
  return new Left(new UnexpectedToken(v.value));
});
var many1 = function(parser) {
  return apply5(map25(cons$prime)(parser))(many2(parser));
};
var expectMap = function(k) {
  return take6(function(tok) {
    var v = k(tok);
    if (v instanceof Just) {
      return new Right(v.value0);
    }
    ;
    if (v instanceof Nothing) {
      return new Left(new UnexpectedToken(tok.value));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser (line 46, column 3 - line 50, column 39): " + [v.constructor.name]);
  });
};
var parseBoolean = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "true")) {
    return new Just(new Tuple(v, true));
  }
  ;
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "false")) {
    return new Just(new Tuple(v, false));
  }
  ;
  return Nothing.value;
});
var parseChar = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokChar) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseHole = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokHole) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  return Nothing.value;
});
var parseIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && !member3(v.value.value1)(reservedKeywords))) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var $$parseInt = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokInt) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseLabel = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokRawString) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  if (v.value instanceof TokString) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseModuleName = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Just) {
    return new Just({
      token: v,
      name: v.value.value0.value0 + ("." + v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseNumber = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokNumber) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && !member3(v.value.value1)(reservedKeywords)) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdentOrProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Left(v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Right(v.value.value1)
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseString = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokString) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  if (v.value instanceof TokRawString) {
    return new Just(new Tuple(v, v.value.value0));
  }
  ;
  return Nothing.value;
});
var parseSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var expect = function(pred2) {
  return expectMap(function(tok) {
    var $244 = pred2(tok.value);
    if ($244) {
      return new Just(tok);
    }
    ;
    return Nothing.value;
  });
};
var tokAt = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokAt) {
    return true;
  }
  ;
  return false;
});
var tokBackslash = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokBackslash) {
    return true;
  }
  ;
  return false;
});
var tokComma = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokComma) {
    return true;
  }
  ;
  return false;
});
var tokDot = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDot) {
    return true;
  }
  ;
  return false;
});
var parseRecordAccessor = function(expr) {
  return bind8(tokDot)(function(dot) {
    return bind8(separated(tokDot)(parseLabel))(function(path3) {
      return pure9(new ExprRecordAccessor({
        expr,
        dot,
        path: path3
      }));
    });
  });
};
var tokDoubleColon = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDoubleColon) {
    return true;
  }
  ;
  return false;
});
var parseInstanceName = /* @__PURE__ */ function() {
  return apply5(map25(Tuple.create)(parseIdent))(tokDoubleColon);
}();
var tokEquals = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokEquals) {
    return true;
  }
  ;
  return false;
});
var tokForall = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokForall) {
    return true;
  }
  ;
  return false;
});
var tokKeyOperator = function(sym) {
  return expect(function(v) {
    if (v instanceof TokOperator && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var parseBinderNegative = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return alt7(map25(uncurry(BinderInt.create(new Just(negative))))($$parseInt))(map25(uncurry(BinderNumber.create(new Just(negative))))(parseNumber));
});
var parseRecordLabeled = function(valueParser) {
  var parseRecordField = apply5(map25(uncurry(RecordField.create))($$try5(apply5(map25(Tuple.create)(parseLabel))(tokKeyOperator(":")))))(valueParser);
  return alt7(parseRecordField)(map25(RecordPun.create)(parseIdent));
};
var parseTypeNegative = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return map25(uncurry(TypeInt.create(new Just(negative))))($$parseInt);
});
var tokKeySymbol = function(sym) {
  return expect(function(v) {
    if (v instanceof TokSymbolName && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var tokKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName && v.value0 instanceof Nothing) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var parseFixityKeyword = /* @__PURE__ */ function() {
  return alt7(map25(flip(Tuple.create)(Infix.value))(tokKeyword("infix")))(alt7(map25(flip(Tuple.create)(Infixl.value))(tokKeyword("infixl")))(map25(flip(Tuple.create)(Infixr.value))(tokKeyword("infixr"))));
}();
var parseFixityOp = /* @__PURE__ */ function() {
  return alt7(apply5(apply5(apply5(map25(FixityType.create)(tokKeyword("type")))(parseQualifiedProper))(tokKeyword("as")))(parseOperator))(apply5(apply5(map25(FixityValue.create)(parseQualifiedIdentOrProper))(tokKeyword("as")))(parseOperator));
}();
var parseDeclFixity = /* @__PURE__ */ bind8(parseFixityKeyword)(function(keyword) {
  return bind8(parseSmallInt)(function(prec) {
    return bind8(parseFixityOp)(function(operator) {
      return pure9(new DeclFixity({
        keyword,
        prec,
        operator
      }));
    });
  });
});
var parseForeignKind = /* @__PURE__ */ function() {
  return $$try5(apply5(map25(ForeignKind.create)(tokKeyword("kind")))(parseProper));
}();
var parseRole = /* @__PURE__ */ function() {
  return alt7(map25(flip(Tuple.create)(Representational.value))(tokKeyword("representational")))(alt7(map25(flip(Tuple.create)(Nominal.value))(tokKeyword("nominal")))(map25(flip(Tuple.create)(Phantom.value))(tokKeyword("phantom"))));
}();
var parseDeclRole = function(keyword1) {
  return bind8(tokKeyword("role"))(function(keyword2) {
    return bind8(parseProper)(function(name3) {
      return bind8(many1(parseRole))(function(roles) {
        return pure9(new DeclRole(keyword1, keyword2, name3, roles));
      });
    });
  });
};
var tokLayoutEnd = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutEnd) {
    return true;
  }
  ;
  return false;
});
var tokLayoutSep = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutSep) {
    return true;
  }
  ;
  return false;
});
var parseInstanceChainSeparator = /* @__PURE__ */ applyFirst3(/* @__PURE__ */ tokKeyword("else"))(/* @__PURE__ */ optional2(tokLayoutSep));
var tokLayoutStart = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutStart) {
    return true;
  }
  ;
  return false;
});
var layoutNonEmpty = function(valueParser) {
  return apply5(map25(function(v) {
    return function(v1) {
      return cons$prime(v)(v1);
    };
  })(applySecond3(tokLayoutStart)(valueParser)))(applyFirst3(many2(applySecond3(tokLayoutSep)(valueParser)))(tokLayoutEnd));
};
var tokLeftArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftArrow) {
    return true;
  }
  ;
  return false;
});
var tokLeftBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftBrace) {
    return true;
  }
  ;
  return false;
});
var tokLeftFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokOperator && v.value0 instanceof Nothing) {
    return v.value1 === "<=" || v.value1 === "\u21D0";
  }
  ;
  return false;
});
var tokLeftParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftParen) {
    return true;
  }
  ;
  return false;
});
var tokLeftSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftSquare) {
    return true;
  }
  ;
  return false;
});
var tokPipe = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokPipe) {
    return true;
  }
  ;
  return false;
});
var tokQualifiedKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var tokRightArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightArrow) {
    return true;
  }
  ;
  return false;
});
var parseFundep = /* @__PURE__ */ function() {
  return alt7(apply5(map25(FundepDetermined.create)(tokRightArrow))(many1(parseIdent)))(apply5(apply5(map25(FundepDetermines.create)(many1(parseIdent)))(tokRightArrow))(many1(parseIdent)));
}();
var tokRightBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightBrace) {
    return true;
  }
  ;
  return false;
});
var tokRightFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightFatArrow) {
    return true;
  }
  ;
  return false;
});
var tokRightParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightParen) {
    return true;
  }
  ;
  return false;
});
var parens = /* @__PURE__ */ wrapped(tokLeftParen)(tokRightParen);
var parseEmptyRow = function(open) {
  return bind8(tokRightParen)(function(close) {
    return pure9(new TypeRow({
      open,
      value: {
        labels: Nothing.value,
        tail: Nothing.value
      },
      close
    }));
  });
};
var tokRightSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightSquare) {
    return true;
  }
  ;
  return false;
});
var tokSymbolArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokSymbolArrow) {
    return true;
  }
  ;
  return false;
});
var tokTick = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokTick) {
    return true;
  }
  ;
  return false;
});
var tokUnderscore = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokUnderscore) {
    return true;
  }
  ;
  return false;
});
var delimited = function(openTok) {
  return function(closeTok) {
    return function(sepTok) {
      return function(valueParser) {
        var parseNonEmpty = function(open) {
          return apply5(map25(function(v) {
            return function(v1) {
              return {
                open,
                value: new Just(v),
                close: v1
              };
            };
          })(separated(sepTok)(valueParser)))(closeTok);
        };
        var parseEmpty = function(open) {
          return map25(function(v) {
            return {
              open,
              value: Nothing.value,
              close: v
            };
          })(closeTok);
        };
        return bind8(openTok)(function(open) {
          return alt7(parseEmpty(open))(parseNonEmpty(open));
        });
      };
    };
  };
};
var parseDataMembers = /* @__PURE__ */ function() {
  return alt7(map25(DataAll.create)(tokKeySymbol("..")))(map25(DataEnumerated.create)(delimited(tokLeftParen)(tokRightParen)(tokComma)(parseProper)));
}();
var parseExport = /* @__PURE__ */ function() {
  return alt7(apply5(map25(ExportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt7(apply5(map25(ExportClass.create)(tokKeyword("class")))(parseProper))(alt7(apply5(map25(ExportModule.create)(tokKeyword("module")))(parseModuleName))(alt7(map25(ExportOp.create)(parseSymbol))(alt7(map25(ExportValue.create)(parseIdent))(apply5(map25(ExportType.create)(parseProper))(optional2(parseDataMembers)))))));
}();
var parseImport = /* @__PURE__ */ function() {
  return alt7(map25(ImportOp.create)(parseSymbol))(alt7(apply5(map25(ImportType.create)(parseProper))(optional2(parseDataMembers)))(alt7(apply5(map25(ImportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt7(apply5(map25(ImportClass.create)(tokKeyword("class")))(parseProper))(map25(ImportValue.create)(parseIdent)))));
}();
var parseImportDecl = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("import"))(function(keyword) {
  return bind8(parseModuleName)(function(module_) {
    return bind8(optional2(apply5(map25(Tuple.create)(optional2(tokKeyword("hiding"))))(parens(separated(tokComma)(parseImport)))))(function(names) {
      return bind8(optional2(apply5(map25(Tuple.create)(tokKeyword("as")))(parseModuleName)))(function(qualified) {
        return pure9({
          keyword,
          module: module_,
          names,
          qualified
        });
      });
    });
  });
});
var parseModuleImportDecls = /* @__PURE__ */ many2(/* @__PURE__ */ applyFirst3(parseImportDecl)(/* @__PURE__ */ alt7(tokLayoutSep)(/* @__PURE__ */ lookAhead(tokLayoutEnd))));
var parseModuleHeader = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("module"))(function(keyword) {
  return bind8(parseModuleName)(function(name3) {
    return bind8(optional2(parens(separated(tokComma)(parseExport))))(function(exports) {
      return bind8(tokKeyword("where"))(function(where_) {
        return bind8(applySecond3(tokLayoutStart)(parseModuleImportDecls))(function(imports) {
          return pure9({
            keyword,
            name: name3,
            exports,
            where: where_,
            imports
          });
        });
      });
    });
  });
});
var braces = /* @__PURE__ */ wrapped(tokLeftBrace)(tokRightBrace);
var parseTypeVarKinded = function(parseBindingName) {
  return map25(TypeVarKinded.create)(parens(bind8(parseBindingName)(function(label) {
    return bind8(tokDoubleColon)(function(separator) {
      return bind8($lazy_parseType(550))(function(value3) {
        return pure9({
          label,
          separator,
          value: value3
        });
      });
    });
  })));
};
var parseTypeVarBinding = function(parseBindingName) {
  return alt7(parseTypeVarKinded(parseBindingName))(map25(TypeVarName.create)(parseBindingName));
};
var parseTypeParen = function(open) {
  return bind8($lazy_parseType(507))(function(value3) {
    return bind8(tokRightParen)(function(close) {
      return pure9(new TypeParens({
        open,
        value: value3,
        close
      }));
    });
  });
};
var parseRowTailParen = function(open) {
  return bind8(apply5(map25(Tuple.create)(tokPipe))($lazy_parseType(477)))(function(tail2) {
    return bind8(tokRightParen)(function(close) {
      return pure9(new TypeRow({
        open,
        value: {
          labels: Nothing.value,
          tail: new Just(tail2)
        },
        close
      }));
    });
  });
};
var parseRowParen = function(open) {
  return bind8($$try5(apply5(map25(Tuple.create)(parseLabel))(tokDoubleColon)))(function(v) {
    return bind8($lazy_parseType(459))(function(value3) {
      return bind8(many2(apply5(map25(Tuple.create)(tokComma))($lazy_parseRowLabel(460))))(function(rest) {
        return bind8(optional2(apply5(map25(Tuple.create)(tokPipe))($lazy_parseType(461))))(function(tail2) {
          return bind8(tokRightParen)(function(close) {
            return pure9(new TypeRow({
              open,
              value: {
                labels: new Just({
                  head: {
                    label: v.value0,
                    separator: v.value1,
                    value: value3
                  },
                  tail: rest
                }),
                tail: tail2
              },
              close
            }));
          });
        });
      });
    });
  });
};
var parseKindedVar = function(open) {
  return bind8($$try5(apply5(map25(Tuple.create)(parens(map25(TypeVar.create)(parseIdent))))(tokDoubleColon)))(function(v) {
    return bind8($lazy_parseType(497))(function(kind) {
      return bind8(tokRightParen)(function(close) {
        return pure9(new TypeParens({
          open,
          value: new TypeKinded(new TypeParens(v.value0), v.value1, kind),
          close
        }));
      });
    });
  });
};
var $lazy_parseForall = /* @__PURE__ */ $runtime_lazy9("parseForall", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return apply5(apply5(apply5(map25(TypeForall.create)(tokForall))(many1($lazy_parseTypeVarBindingWithVisibility(528))))(tokDot))($lazy_parseType1(530));
  });
});
var $lazy_parseRow = /* @__PURE__ */ $runtime_lazy9("parseRow", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8(optional2(separated(tokComma)($lazy_parseRowLabel(513))))(function(labels) {
      return bind8(optional2(apply5(map25(Tuple.create)(tokPipe))($lazy_parseType(514))))(function(tail2) {
        return pure9({
          labels,
          tail: tail2
        });
      });
    });
  });
});
var $lazy_parseRowLabel = /* @__PURE__ */ $runtime_lazy9("parseRowLabel", "PureScript.CST.Parser", function() {
  return bind8(parseLabel)(function(label) {
    return bind8(tokDoubleColon)(function(separator) {
      return bind8($lazy_parseType(521))(function(value3) {
        return pure9({
          label,
          separator,
          value: value3
        });
      });
    });
  });
});
var $lazy_parseType = /* @__PURE__ */ $runtime_lazy9("parseType", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseType1(393))(function(ty) {
      return alt7(apply5(map25(TypeKinded.create(ty))(tokDoubleColon))($lazy_parseType(394)))(pure9(ty));
    });
  });
});
var $lazy_parseType1 = /* @__PURE__ */ $runtime_lazy9("parseType1", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7($lazy_parseForall(399))($lazy_parseType2(400));
  });
});
var $lazy_parseType2 = /* @__PURE__ */ $runtime_lazy9("parseType2", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseType3(404))(function(ty) {
      return alt7(apply5(map25(TypeArrow.create(ty))(tokRightArrow))($lazy_parseType1(405)))(alt7(apply5(map25(TypeConstrained.create(ty))(tokRightFatArrow))($lazy_parseType1(406)))(pure9(ty)));
    });
  });
});
var $lazy_parseType3 = /* @__PURE__ */ $runtime_lazy9("parseType3", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseType4(411))(function(ty) {
      return bind8(many2(apply5(map25(Tuple.create)(parseQualifiedOperator))($lazy_parseType4(412))))(function(ops) {
        return pure9(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeOp(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 413, column 8 - line 415, column 28): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseType4 = /* @__PURE__ */ $runtime_lazy9("parseType4", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(parseTypeNegative)($lazy_parseType5(419));
  });
});
var $lazy_parseType5 = /* @__PURE__ */ $runtime_lazy9("parseType5", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseTypeAtom(423))(function(ty) {
      return bind8(many2($lazy_parseTypeAtom(424)))(function(args) {
        return pure9(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeApp(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 425, column 8 - line 427, column 29): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseTypeAtom = /* @__PURE__ */ $runtime_lazy9("parseTypeAtom", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(map25(TypeVar.create)(parseIdent))(alt7(map25(TypeConstructor.create)(parseQualifiedProper))(alt7(map25(uncurry(TypeString.create))(parseString))(alt7(map25(uncurry(TypeInt.create(Nothing.value)))($$parseInt))(alt7($lazy_parseTypeParens(435))(alt7(map25(TypeRecord.create)(braces($lazy_parseRow(436))))(alt7(map25(TypeOpName.create)(parseQualifiedSymbol))(alt7(map25(TypeHole.create)(parseHole))(alt7(map25(TypeWildcard.create)(tokUnderscore))(map25(TypeArrowName.create)(tokSymbolArrow))))))))));
  });
});
var $lazy_parseTypeParens = /* @__PURE__ */ $runtime_lazy9("parseTypeParens", "PureScript.CST.Parser", function() {
  return bind8(tokLeftParen)(function(open) {
    return alt7(parseRowParen(open))(alt7(parseRowTailParen(open))(alt7(parseKindedVar(open))(alt7(parseTypeParen(open))(parseEmptyRow(open)))));
  });
});
var $lazy_parseTypeVarBindingWithVisibility = /* @__PURE__ */ $runtime_lazy9("parseTypeVarBindingWithVisibility", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return parseTypeVarBinding(apply5(map25(function(v1) {
      return function(v2) {
        return {
          prefix: v1,
          value: v2
        };
      };
    })(optional2(tokAt)))(parseIdent));
  });
});
var parseType = /* @__PURE__ */ $lazy_parseType(391);
var parseType3 = /* @__PURE__ */ $lazy_parseType3(409);
var parseType5 = /* @__PURE__ */ $lazy_parseType5(421);
var parseTypeAtom = /* @__PURE__ */ $lazy_parseTypeAtom(429);
var parseDataCtor = /* @__PURE__ */ apply5(/* @__PURE__ */ map25(function(v) {
  return function(v1) {
    return {
      name: v,
      fields: v1
    };
  };
})(parseProper))(/* @__PURE__ */ many2(parseTypeAtom));
var $lazy_parseBinder = /* @__PURE__ */ $runtime_lazy9("parseBinder", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseBinder1(825))(function(binder) {
      return alt7(apply5(map25(BinderTyped.create(binder))(tokDoubleColon))(parseType))(pure9(binder));
    });
  });
});
var $lazy_parseBinder1 = /* @__PURE__ */ $runtime_lazy9("parseBinder1", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseBinder2(831))(function(binder) {
      return bind8(many2(apply5(map25(Tuple.create)(parseQualifiedOperator))($lazy_parseBinder2(832))))(function(ops) {
        return pure9(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return binder;
          }
          ;
          if (v1 instanceof Just) {
            return new BinderOp(binder, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 833, column 8 - line 835, column 34): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseBinder2 = /* @__PURE__ */ $runtime_lazy9("parseBinder2", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(parseBinderNegative)(alt7($lazy_parseBinderConstructor(840))($lazy_parseBinderAtom(841)));
  });
});
var $lazy_parseBinderAtom = /* @__PURE__ */ $runtime_lazy9("parseBinderAtom", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7($lazy_parseIdentBinder(857))(alt7(map25(flip(BinderConstructor.create)([]))(parseQualifiedProper))(alt7(map25(BinderWildcard.create)(tokUnderscore))(alt7(map25(uncurry(BinderString.create))(parseString))(alt7(map25(uncurry(BinderChar.create))(parseChar))(alt7(map25(uncurry(BinderBoolean.create))(parseBoolean))(alt7(map25(uncurry(BinderInt.create(Nothing.value)))($$parseInt))(alt7(map25(uncurry(BinderNumber.create(Nothing.value)))(parseNumber))(alt7(map25(BinderArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseBinder(865))))(alt7(map25(BinderRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseBinder(866)))))(map25(BinderParens.create)(parens($lazy_parseBinder(867)))))))))))));
  });
});
var $lazy_parseBinderConstructor = /* @__PURE__ */ $runtime_lazy9("parseBinderConstructor", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8(parseQualifiedProper)(function(name3) {
      return bind8(many2($lazy_parseBinderAtom(852)))(function(apps) {
        return pure9(new BinderConstructor(name3, apps));
      });
    });
  });
});
var $lazy_parseIdentBinder = /* @__PURE__ */ $runtime_lazy9("parseIdentBinder", "PureScript.CST.Parser", function() {
  return bind8(parseIdent)(function(ident) {
    return alt7(apply5(map25(BinderNamed.create(ident))(tokAt))($lazy_parseBinderAtom(872)))(pure9(new BinderVar(ident)));
  });
});
var parseBinder = /* @__PURE__ */ $lazy_parseBinder(823);
var parseBinder1 = /* @__PURE__ */ $lazy_parseBinder1(829);
var parseBinderAtom = /* @__PURE__ */ $lazy_parseBinderAtom(855);
var parseClassConstraints = function(parseOneConstraint) {
  return alt7(map25(Many.create)(parens(separated(tokComma)(parseType))))(map25(One.create)(parseOneConstraint));
};
var parseDeclDerive = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("derive"))(function(derive_) {
  return bind8(optional2(tokKeyword("newtype")))(function(newtype_) {
    return bind8(tokKeyword("instance"))(function(keyword) {
      return bind8(optional2(parseInstanceName))(function(name3) {
        return bind8(optional2($$try5(apply5(map25(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
          return bind8(parseQualifiedProper)(function(className) {
            return bind8(many2(parseTypeAtom))(function(types2) {
              return pure9(new DeclDerive(derive_, newtype_, {
                keyword,
                name: name3,
                constraints,
                className,
                types: types2
              }));
            });
          });
        });
      });
    });
  });
});
var parseClassMember = /* @__PURE__ */ bind8(parseIdent)(function(label) {
  return bind8(tokDoubleColon)(function(separator) {
    return bind8(parseType)(function(value3) {
      return pure9({
        label,
        separator,
        value: value3
      });
    });
  });
});
var parseDeclClassSignature = function(keyword) {
  return bind8($$try5(apply5(map25(Tuple.create)(parseProper))(tokDoubleColon)))(function(v) {
    return bind8(parseType)(function(value3) {
      return pure9(new DeclKindSignature(keyword, {
        label: v.value0,
        separator: v.value1,
        value: value3
      }));
    });
  });
};
var parseDeclKindSignature = function(keyword) {
  return function(label) {
    return bind8(tokDoubleColon)(function(separator) {
      return bind8(parseType)(function(value3) {
        return pure9(new DeclKindSignature(keyword, {
          label,
          separator,
          value: value3
        }));
      });
    });
  };
};
var parseDeclSignature = function(label) {
  return bind8(tokDoubleColon)(function(separator) {
    return bind8(parseType)(function(value3) {
      return pure9(new DeclSignature({
        label,
        separator,
        value: value3
      }));
    });
  });
};
var parseForeignData = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind8(parseProper)(function(label) {
    return bind8(tokDoubleColon)(function(separator) {
      return bind8(parseType)(function(value3) {
        return pure9(new ForeignData(keyword, {
          label,
          separator,
          value: value3
        }));
      });
    });
  });
});
var parseForeignValue = /* @__PURE__ */ bind8(parseIdent)(function(label) {
  return bind8(tokDoubleColon)(function(separator) {
    return bind8(parseType)(function(value3) {
      return pure9(new ForeignValue({
        label,
        separator,
        value: value3
      }));
    });
  });
});
var parseDeclForeign = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("foreign"))(function(keyword1) {
  return bind8(tokKeyword("import"))(function(keyword2) {
    return bind8(alt7(parseForeignData)(alt7(parseForeignKind)(parseForeignValue)))(function(foreign_) {
      return pure9(new DeclForeign(keyword1, keyword2, foreign_));
    });
  });
});
var parseInstanceBindingSignature = function(label) {
  return bind8(tokDoubleColon)(function(separator) {
    return bind8(parseType)(function(value3) {
      return pure9(new InstanceBindingSignature({
        label,
        separator,
        value: value3
      }));
    });
  });
};
var parseLetBindingSignature = function(label) {
  return bind8(tokDoubleColon)(function(separator) {
    return bind8(parseType)(function(value3) {
      return pure9(new LetBindingSignature({
        label,
        separator,
        value: value3
      }));
    });
  });
};
var parseRecordUpdates = function(expr) {
  return bind8($$try5(applyFirst3(tokLeftBrace)(lookAhead(applySecond3(parseLabel)(alt7(tokEquals)(tokLeftBrace))))))(function(open) {
    return bind8(separated(tokComma)($lazy_parseRecordUpdate(709)))(function(value3) {
      return bind8(tokRightBrace)(function(close) {
        return pure9(new ExprRecordUpdate(expr, {
          open,
          value: value3,
          close
        }));
      });
    });
  });
};
var parseRecordUpdateLeaf = function(label) {
  return apply5(map25(RecordUpdateLeaf.create(label))(tokEquals))($lazy_parseExpr(723));
};
var parseRecordUpdateBranch = function(label) {
  return map25(RecordUpdateBranch.create(label))(braces(separated(tokComma)($lazy_parseRecordUpdate(728))));
};
var parseLetBindingName = function(name3) {
  return bind8(many2(parseBinderAtom))(function(binders) {
    return bind8(parseGuarded(tokEquals))(function(guarded) {
      return pure9(new LetBindingName({
        name: name3,
        binders,
        guarded
      }));
    });
  });
};
var parseGuarded = function(sepParser) {
  var parsePatternGuard = apply5(map25(function(v) {
    return function(v1) {
      return {
        binder: v,
        expr: v1
      };
    };
  })(optional2($$try5(apply5(map25(Tuple.create)(parseBinder))(tokLeftArrow)))))($lazy_parseExpr(814));
  var parseGuardedExpr = apply5(apply5(apply5(map25(function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return {
            bar: v,
            patterns: v1,
            separator: v2,
            where: v3
          };
        };
      };
    };
  })(tokPipe))(separated(tokComma)(parsePatternGuard)))(sepParser))($lazy_parseWhere(808));
  return alt7(apply5(map25(Unconditional.create)(sepParser))($lazy_parseWhere(800)))(map25(Guarded.create)(many1(parseGuardedExpr)));
};
var parseBadSingleCaseWhere = function(binder) {
  return bind8(tokRightArrow)(function(arrow) {
    return bind8(applySecond3(tokLayoutEnd)($lazy_parseWhere(665)))(function(body) {
      return pure9(singleton4(new Tuple({
        head: binder,
        tail: []
      }, new Unconditional(arrow, body))));
    });
  });
};
var parseBadSingleCaseGuarded = function(binder) {
  return bind8(applySecond3(tokLayoutEnd)(parseGuarded(tokRightArrow)))(function(body) {
    return pure9(singleton4(new Tuple({
      head: binder,
      tail: []
    }, body)));
  });
};
var $lazy_parseAdo = /* @__PURE__ */ $runtime_lazy9("parseAdo", "PureScript.CST.Parser", function() {
  return bind8(tokQualifiedKeyword("ado"))(function(keyword) {
    return bind8(function() {
      var valueParser = recoverDoStatement($lazy_parseDoStatement(690));
      var nonEmptyCase = apply5(map25(cons)(valueParser))(many2(applySecond3(tokLayoutSep)(valueParser)));
      return bind8(tokLayoutStart)(function() {
        return alt7(voidRight2([])(tokLayoutEnd))(applyFirst3(nonEmptyCase)(tokLayoutEnd));
      });
    }())(function(statements) {
      return bind8(tokKeyword("in"))(function(in_) {
        return bind8($lazy_parseExpr(697))(function(result) {
          return pure9(new ExprAdo({
            keyword,
            statements,
            "in": in_,
            result
          }));
        });
      });
    });
  });
});
var $lazy_parseBadSingleCaseBranch = /* @__PURE__ */ $runtime_lazy9("parseBadSingleCaseBranch", "PureScript.CST.Parser", function() {
  return bind8(applySecond3(tokLayoutStart)(parseBinder1))(function(binder) {
    return alt7(parseBadSingleCaseWhere(binder))(parseBadSingleCaseGuarded(binder));
  });
});
var $lazy_parseCase = /* @__PURE__ */ $runtime_lazy9("parseCase", "PureScript.CST.Parser", function() {
  return bind8(tokKeyword("case"))(function(keyword) {
    return bind8(separated(tokComma)($lazy_parseExpr(647)))(function(head4) {
      return bind8(tokKeyword("of"))(function(of_) {
        return bind8(alt7($$try5($lazy_parseBadSingleCaseBranch(649)))($lazy_parseCaseBranches(649)))(function(branches) {
          return pure9(new ExprCase({
            keyword,
            head: head4,
            of: of_,
            branches
          }));
        });
      });
    });
  });
});
var $lazy_parseCaseBranches = /* @__PURE__ */ $runtime_lazy9("parseCaseBranches", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return layoutNonEmpty(apply5(map25(Tuple.create)(separated(tokComma)(parseBinder1)))(parseGuarded(tokRightArrow)));
  });
});
var $lazy_parseDo = /* @__PURE__ */ $runtime_lazy9("parseDo", "PureScript.CST.Parser", function() {
  return bind8(tokQualifiedKeyword("do"))(function(keyword) {
    return bind8(layoutNonEmpty(recoverDoStatement($lazy_parseDoStatement(676))))(function(statements) {
      return pure9(new ExprDo({
        keyword,
        statements
      }));
    });
  });
});
var $lazy_parseDoStatement = /* @__PURE__ */ $runtime_lazy9("parseDoStatement", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(apply5(map25(DoLet.create)(tokKeyword("let")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(771)))))(alt7(apply5(map25(uncurry(DoBind.create))($$try5(apply5(map25(Tuple.create)(parseBinder))(tokLeftArrow))))($lazy_parseExpr(772)))(map25(DoDiscard.create)($lazy_parseExpr(773))));
  });
});
var $lazy_parseExpr = /* @__PURE__ */ $runtime_lazy9("parseExpr", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr1(555))(function(expr) {
      return alt7(apply5(map25(ExprTyped.create(expr))(tokDoubleColon))(parseType))(pure9(expr));
    });
  });
});
var $lazy_parseExpr1 = /* @__PURE__ */ $runtime_lazy9("parseExpr1", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr2(561))(function(expr) {
      return bind8(many2(apply5(map25(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr2(562))))(function(ops) {
        return pure9(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 563, column 8 - line 565, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr2 = /* @__PURE__ */ $runtime_lazy9("parseExpr2", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr3(569))(function(expr) {
      return bind8(many2(apply5(map25(Tuple.create)($lazy_parseTickExpr(570)))($lazy_parseExpr3(570))))(function(ops) {
        return pure9(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprInfix(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 571, column 8 - line 573, column 33): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr3 = /* @__PURE__ */ $runtime_lazy9("parseExpr3", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(apply5(map25(ExprNegate.create)(tokKeyOperator("-")))($lazy_parseExpr3(592)))($lazy_parseExpr4(593));
  });
});
var $lazy_parseExpr4 = /* @__PURE__ */ $runtime_lazy9("parseExpr4", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr5(597))(function(expr) {
      return bind8(many2($lazy_parseExprAppSpine(598)))(function(args) {
        return pure9(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprApp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 599, column 8 - line 601, column 31): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr5 = /* @__PURE__ */ $runtime_lazy9("parseExpr5", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7($lazy_parseIf(605))(alt7($lazy_parseLetIn(606))(alt7($lazy_parseLambda(607))(alt7($lazy_parseCase(608))(alt7($lazy_parseDo(609))(alt7($lazy_parseAdo(610))($lazy_parseExpr6(611)))))));
  });
});
var $lazy_parseExpr6 = /* @__PURE__ */ $runtime_lazy9("parseExpr6", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr7(702))(function(expr) {
      return alt7(parseRecordUpdates(expr))(pure9(expr));
    });
  });
});
var $lazy_parseExpr7 = /* @__PURE__ */ $runtime_lazy9("parseExpr7", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExprAtom(732))(function(expr) {
      return alt7(parseRecordAccessor(expr))(pure9(expr));
    });
  });
});
var $lazy_parseExprAppSpine = /* @__PURE__ */ $runtime_lazy9("parseExprAppSpine", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(apply5(map25(AppType.create)(tokAt))(parseTypeAtom))(map25(AppTerm.create)($lazy_parseExpr5(616)));
  });
});
var $lazy_parseExprAtom = /* @__PURE__ */ $runtime_lazy9("parseExprAtom", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7(map25(ExprIdent.create)(parseQualifiedIdent))(alt7(map25(ExprConstructor.create)(parseQualifiedProper))(alt7(map25(ExprOpName.create)(parseQualifiedSymbol))(alt7(map25(ExprSection.create)(tokUnderscore))(alt7(map25(ExprHole.create)(parseHole))(alt7(map25(uncurry(ExprString.create))(parseString))(alt7(map25(uncurry(ExprChar.create))(parseChar))(alt7(map25(uncurry(ExprBoolean.create))(parseBoolean))(alt7(map25(uncurry(ExprInt.create))($$parseInt))(alt7(map25(uncurry(ExprNumber.create))(parseNumber))(alt7(map25(ExprArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseExpr(754))))(alt7(map25(ExprRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseExpr(755)))))(map25(ExprParens.create)(parens($lazy_parseExpr(756)))))))))))))));
  });
});
var $lazy_parseIdentBinding = /* @__PURE__ */ $runtime_lazy9("parseIdentBinding", "PureScript.CST.Parser", function() {
  return bind8(parseIdent)(function(ident) {
    return alt7(parseLetBindingSignature(ident))(parseLetBindingName(ident));
  });
});
var $lazy_parseIf = /* @__PURE__ */ $runtime_lazy9("parseIf", "PureScript.CST.Parser", function() {
  return bind8(tokKeyword("if"))(function(keyword) {
    return bind8($lazy_parseExpr(621))(function(cond) {
      return bind8(tokKeyword("then"))(function(then_) {
        return bind8($lazy_parseExpr(623))(function(true_) {
          return bind8(tokKeyword("else"))(function(else_) {
            return bind8($lazy_parseExpr(625))(function(false_) {
              return pure9(new ExprIf({
                keyword,
                cond,
                then: then_,
                "true": true_,
                "else": else_,
                "false": false_
              }));
            });
          });
        });
      });
    });
  });
});
var $lazy_parseLambda = /* @__PURE__ */ $runtime_lazy9("parseLambda", "PureScript.CST.Parser", function() {
  return bind8(tokBackslash)(function(symbol) {
    return bind8(many1(parseBinderAtom))(function(binders) {
      return bind8(tokRightArrow)(function(arrow) {
        return bind8($lazy_parseExpr(641))(function(body) {
          return pure9(new ExprLambda({
            symbol,
            binders,
            arrow,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseLetBinding = /* @__PURE__ */ $runtime_lazy9("parseLetBinding", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return alt7($$try5($lazy_parseIdentBinding(777)))(apply5(apply5(map25(LetBindingPattern.create)(parseBinder1))(tokEquals))($lazy_parseWhere(778)));
  });
});
var $lazy_parseLetIn = /* @__PURE__ */ $runtime_lazy9("parseLetIn", "PureScript.CST.Parser", function() {
  return bind8(tokKeyword("let"))(function(keyword) {
    return bind8(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(631))))(function(bindings) {
      return bind8(tokKeyword("in"))(function(in_) {
        return bind8($lazy_parseExpr(633))(function(body) {
          return pure9(new ExprLet({
            keyword,
            bindings,
            "in": in_,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseRecordUpdate = /* @__PURE__ */ $runtime_lazy9("parseRecordUpdate", "PureScript.CST.Parser", function() {
  return bind8(parseLabel)(function(label) {
    return alt7(parseRecordUpdateLeaf(label))(parseRecordUpdateBranch(label));
  });
});
var $lazy_parseTickExpr = /* @__PURE__ */ $runtime_lazy9("parseTickExpr", "PureScript.CST.Parser", function() {
  return bind8(tokTick)(function(open) {
    return bind8($lazy_parseTickExpr1(578))(function(value3) {
      return bind8(tokTick)(function(close) {
        return pure9({
          open,
          value: value3,
          close
        });
      });
    });
  });
});
var $lazy_parseTickExpr1 = /* @__PURE__ */ $runtime_lazy9("parseTickExpr1", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr3(584))(function(expr) {
      return bind8(many2(apply5(map25(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr3(585))))(function(ops) {
        return pure9(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 586, column 8 - line 588, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseWhere = /* @__PURE__ */ $runtime_lazy9("parseWhere", "PureScript.CST.Parser", function() {
  return defer3(function(v) {
    return bind8($lazy_parseExpr(819))(function(expr) {
      return bind8(optional2(apply5(map25(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(820))))))(function(bindings) {
        return pure9({
          expr,
          bindings
        });
      });
    });
  });
});
var parseDeclValue1 = function(name3) {
  return bind8(many2(parseBinderAtom))(function(binders) {
    return bind8(parseGuarded(tokEquals))(function(guarded) {
      return pure9(new DeclValue({
        name: name3,
        binders,
        guarded
      }));
    });
  });
};
var parseDeclValue = /* @__PURE__ */ bind8(parseIdent)(function(ident) {
  return alt7(parseDeclSignature(ident))(parseDeclValue1(ident));
});
var parseInstanceBindingName = function(name3) {
  return bind8(many2(parseBinderAtom))(function(binders) {
    return bind8(parseGuarded(tokEquals))(function(guarded) {
      return pure9(new InstanceBindingName({
        name: name3,
        binders,
        guarded
      }));
    });
  });
};
var parseInstanceBinding = /* @__PURE__ */ bind8(parseIdent)(function(ident) {
  return alt7(parseInstanceBindingSignature(ident))(parseInstanceBindingName(ident));
});
var parseInstance = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("instance"))(function(keyword) {
  return bind8(optional2(parseInstanceName))(function(name3) {
    return bind8(optional2($$try5(apply5(map25(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
      return bind8(parseQualifiedProper)(function(className) {
        return bind8(many2(parseTypeAtom))(function(types2) {
          return bind8(optional2(apply5(map25(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseInstanceBinding))))(function(body) {
            return pure9({
              head: {
                keyword,
                name: name3,
                constraints,
                className,
                types: types2
              },
              body
            });
          });
        });
      });
    });
  });
});
var parseDeclInstanceChain = /* @__PURE__ */ function() {
  return map25(DeclInstanceChain.create)(separated(parseInstanceChainSeparator)(parseInstance));
}();
var parseTypeVarBindingPlain = /* @__PURE__ */ parseTypeVarBinding(parseIdent);
var parseDeclClass1 = function(keyword) {
  return bind8(optional2($$try5(apply5(map25(Tuple.create)(parseClassConstraints(parseType5)))(tokLeftFatArrow))))(function($$super) {
    return bind8(parseProper)(function(name3) {
      return bind8(many2(parseTypeVarBindingPlain))(function(vars) {
        return bind8(optional2(apply5(map25(Tuple.create)(tokPipe))(separated(tokComma)(parseFundep))))(function(fundeps) {
          return bind8(optional2(apply5(map25(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseClassMember))))(function(members) {
            return pure9(new DeclClass({
              keyword,
              "super": $$super,
              name: name3,
              vars,
              fundeps
            }, members));
          });
        });
      });
    });
  });
};
var parseDeclClass = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("class"))(function(keyword) {
  return alt7(parseDeclClassSignature(keyword))(parseDeclClass1(keyword));
});
var parseDeclData1 = function(keyword) {
  return function(name3) {
    return bind8(many2(parseTypeVarBindingPlain))(function(vars) {
      return bind8(optional2(apply5(map25(Tuple.create)(tokEquals))(separated(tokPipe)(parseDataCtor))))(function(ctors) {
        return pure9(new DeclData({
          keyword,
          name: name3,
          vars
        }, ctors));
      });
    });
  };
};
var parseDeclData = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind8(parseProper)(function(name3) {
    return alt7(parseDeclKindSignature(keyword)(name3))(parseDeclData1(keyword)(name3));
  });
});
var parseDeclNewtype1 = function(keyword) {
  return function(name3) {
    return bind8(many2(parseTypeVarBindingPlain))(function(vars) {
      return bind8(tokEquals)(function(tok) {
        return bind8(parseProper)(function(wrapper) {
          return bind8(parseTypeAtom)(function(body) {
            return pure9(new DeclNewtype({
              keyword,
              name: name3,
              vars
            }, tok, wrapper, body));
          });
        });
      });
    });
  };
};
var parseDeclNewtype = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("newtype"))(function(keyword) {
  return bind8(parseProper)(function(name3) {
    return alt7(parseDeclKindSignature(keyword)(name3))(parseDeclNewtype1(keyword)(name3));
  });
});
var parseDeclType2 = function(keyword) {
  return function(name3) {
    return bind8(many2(parseTypeVarBindingPlain))(function(vars) {
      return bind8(tokEquals)(function(tok) {
        return bind8(parseType)(function(body) {
          return pure9(new DeclType({
            keyword,
            name: name3,
            vars
          }, tok, body));
        });
      });
    });
  };
};
var parseDeclType1 = function(keyword) {
  return bind8(parseProper)(function(name3) {
    return alt7(parseDeclKindSignature(keyword)(name3))(parseDeclType2(keyword)(name3));
  });
};
var parseDeclType = /* @__PURE__ */ bind8(/* @__PURE__ */ tokKeyword("type"))(function(keyword) {
  return alt7(parseDeclRole(keyword))(parseDeclType1(keyword));
});
var parseDecl = /* @__PURE__ */ alt7(parseDeclData)(/* @__PURE__ */ alt7(parseDeclNewtype)(/* @__PURE__ */ alt7(parseDeclType)(/* @__PURE__ */ alt7(parseDeclClass)(/* @__PURE__ */ alt7(parseDeclInstanceChain)(/* @__PURE__ */ alt7(parseDeclDerive)(/* @__PURE__ */ alt7(parseDeclValue)(/* @__PURE__ */ alt7(parseDeclForeign)(parseDeclFixity))))))));
var parseModuleDecls = /* @__PURE__ */ many2(/* @__PURE__ */ applyFirst3(/* @__PURE__ */ recoverDecl(parseDecl))(/* @__PURE__ */ alt7(tokLayoutSep)(/* @__PURE__ */ lookAhead(tokLayoutEnd))));
var parseModuleBody = /* @__PURE__ */ bind8(/* @__PURE__ */ applyFirst3(parseModuleDecls)(tokLayoutEnd))(function(decls) {
  return bind8(eof2)(function(v) {
    return pure9({
      decls,
      trailingComments: v.value1,
      end: v.value0
    });
  });
});
var parseModule = /* @__PURE__ */ bind8(parseModuleHeader)(function(header) {
  return bind8(parseModuleBody)(function(body) {
    return pure9({
      header,
      body
    });
  });
});

// output/PureScript.CST/index.js
var ParseSucceeded = /* @__PURE__ */ function() {
  function ParseSucceeded2(value0) {
    this.value0 = value0;
  }
  ;
  ParseSucceeded2.create = function(value0) {
    return new ParseSucceeded2(value0);
  };
  return ParseSucceeded2;
}();
var ParseSucceededWithErrors = /* @__PURE__ */ function() {
  function ParseSucceededWithErrors2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucceededWithErrors2.create = function(value0) {
    return function(value12) {
      return new ParseSucceededWithErrors2(value0, value12);
    };
  };
  return ParseSucceededWithErrors2;
}();
var ParseFailed = /* @__PURE__ */ function() {
  function ParseFailed2(value0) {
    this.value0 = value0;
  }
  ;
  ParseFailed2.create = function(value0) {
    return new ParseFailed2(value0);
  };
  return ParseFailed2;
}();
var toRecoveredParserResult = function(v) {
  var v1 = function(v2) {
    if (v instanceof Right && otherwise) {
      return new ParseSucceeded(v.value0.value0);
    }
    ;
    if (v instanceof Left) {
      return new ParseFailed(v.value0);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST (line 42, column 1 - line 45, column 29): " + [v.constructor.name]);
  };
  if (v instanceof Right) {
    var $21 = fromArray(v.value0.value1);
    if ($21 instanceof Just) {
      return new ParseSucceededWithErrors(v.value0.value0, $21.value0);
    }
    ;
    return v1(true);
  }
  ;
  return v1(true);
};
var runRecoveredParser = function(p) {
  var $31 = flip(runParser2)(p);
  return function($32) {
    return toRecoveredParserResult($31($32));
  };
};
var parseModule2 = /* @__PURE__ */ function() {
  var $35 = runRecoveredParser(parseModule);
  return function($36) {
    return $35(lexModule($36));
  };
}();

// output/Data.CatQueue/index.js
var CatQueue = /* @__PURE__ */ function() {
  function CatQueue2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatQueue2.create = function(value0) {
    return function(value12) {
      return new CatQueue2(value0, value12);
    };
  };
  return CatQueue2;
}();
var uncons6 = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v.value0 instanceof Nil) {
      $copy_v = new CatQueue(reverse2(v.value1), Nil.value);
      return;
    }
    ;
    if (v.value0 instanceof Cons) {
      $tco_done = true;
      return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var snoc4 = function(v) {
  return function(a) {
    return new CatQueue(v.value0, new Cons(a, v.value1));
  };
};
var $$null6 = function(v) {
  if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var empty7 = /* @__PURE__ */ function() {
  return new CatQueue(Nil.value, Nil.value);
}();

// output/Data.CatList/index.js
var CatNil = /* @__PURE__ */ function() {
  function CatNil2() {
  }
  ;
  CatNil2.value = new CatNil2();
  return CatNil2;
}();
var CatCons = /* @__PURE__ */ function() {
  function CatCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatCons2.create = function(value0) {
    return function(value12) {
      return new CatCons2(value0, value12);
    };
  };
  return CatCons2;
}();
var link = function(v) {
  return function(v1) {
    if (v instanceof CatNil) {
      return v1;
    }
    ;
    if (v1 instanceof CatNil) {
      return v;
    }
    ;
    if (v instanceof CatCons) {
      return new CatCons(v.value0, snoc4(v.value1)(v1));
    }
    ;
    throw new Error("Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): " + [v.constructor.name, v1.constructor.name]);
  };
};
var foldr4 = function(k) {
  return function(b) {
    return function(q) {
      var foldl4 = function($copy_v) {
        return function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v = $copy_v;
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1, v2) {
              if (v2 instanceof Nil) {
                $tco_done = true;
                return v1;
              }
              ;
              if (v2 instanceof Cons) {
                $tco_var_v = v;
                $tco_var_v1 = v(v1)(v2.value0);
                $copy_v2 = v2.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
      };
      var go = function($copy_xs) {
        return function($copy_ys) {
          var $tco_var_xs = $copy_xs;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(xs, ys) {
            var v = uncons6(xs);
            if (v instanceof Nothing) {
              $tco_done1 = true;
              return foldl4(function(x) {
                return function(i) {
                  return i(x);
                };
              })(b)(ys);
            }
            ;
            if (v instanceof Just) {
              $tco_var_xs = v.value0.value1;
              $copy_ys = new Cons(k(v.value0.value0), ys);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_xs, $copy_ys);
          }
          ;
          return $tco_result;
        };
      };
      return go(q)(Nil.value);
    };
  };
};
var uncons7 = function(v) {
  if (v instanceof CatNil) {
    return Nothing.value;
  }
  ;
  if (v instanceof CatCons) {
    return new Just(new Tuple(v.value0, function() {
      var $66 = $$null6(v.value1);
      if ($66) {
        return CatNil.value;
      }
      ;
      return foldr4(link)(CatNil.value)(v.value1);
    }()));
  }
  ;
  throw new Error("Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var empty8 = /* @__PURE__ */ function() {
  return CatNil.value;
}();
var append4 = link;
var semigroupCatList = {
  append: append4
};
var snoc5 = function(cat) {
  return function(a) {
    return append4(cat)(new CatCons(a, empty7));
  };
};

// output/Control.Monad.Free/index.js
var $runtime_lazy10 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var append5 = /* @__PURE__ */ append(semigroupCatList);
var Free = /* @__PURE__ */ function() {
  function Free2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Free2.create = function(value0) {
    return function(value12) {
      return new Free2(value0, value12);
    };
  };
  return Free2;
}();
var Return = /* @__PURE__ */ function() {
  function Return2(value0) {
    this.value0 = value0;
  }
  ;
  Return2.create = function(value0) {
    return new Return2(value0);
  };
  return Return2;
}();
var Bind = /* @__PURE__ */ function() {
  function Bind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Bind2.create = function(value0) {
    return function(value12) {
      return new Bind2(value0, value12);
    };
  };
  return Bind2;
}();
var toView = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    var runExpF = function(v22) {
      return v22;
    };
    var concatF = function(v22) {
      return function(r) {
        return new Free(v22.value0, append5(v22.value1)(r));
      };
    };
    if (v.value0 instanceof Return) {
      var v2 = uncons7(v.value1);
      if (v2 instanceof Nothing) {
        $tco_done = true;
        return new Return(v.value0.value0);
      }
      ;
      if (v2 instanceof Just) {
        $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);
        return;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): " + [v2.constructor.name]);
    }
    ;
    if (v.value0 instanceof Bind) {
      $tco_done = true;
      return new Bind(v.value0.value0, function(a) {
        return concatF(v.value0.value1(a))(v.value1);
      });
    }
    ;
    throw new Error("Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): " + [v.value0.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var resume$prime = function(k) {
  return function(j) {
    return function(f) {
      var v = toView(f);
      if (v instanceof Return) {
        return j(v.value0);
      }
      ;
      if (v instanceof Bind) {
        return k(v.value0)(v.value1);
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 213, column 17 - line 215, column 20): " + [v.constructor.name]);
    };
  };
};
var fromView = function(f) {
  return new Free(f, empty8);
};
var freeMonad = {
  Applicative0: function() {
    return freeApplicative;
  },
  Bind1: function() {
    return freeBind;
  }
};
var freeFunctor = {
  map: function(k) {
    return function(f) {
      return bindFlipped(freeBind)(function() {
        var $189 = pure(freeApplicative);
        return function($190) {
          return $189(k($190));
        };
      }())(f);
    };
  }
};
var freeBind = {
  bind: function(v) {
    return function(k) {
      return new Free(v.value0, snoc5(v.value1)(k));
    };
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var freeApplicative = {
  pure: function($191) {
    return fromView(Return.create($191));
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy10("freeApply", "Control.Monad.Free", function() {
  return {
    apply: ap(freeMonad),
    Functor0: function() {
      return freeFunctor;
    }
  };
});
var bind9 = /* @__PURE__ */ bind(freeBind);
var pure10 = /* @__PURE__ */ pure(freeApplicative);
var freeMonadRec = {
  tailRecM: function(k) {
    return function(a) {
      return bind9(k(a))(function(v) {
        if (v instanceof Loop) {
          return tailRecM(freeMonadRec)(k)(v.value0);
        }
        ;
        if (v instanceof Done) {
          return pure10(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Free (line 86, column 26 - line 88, column 21): " + [v.constructor.name]);
      });
    };
  },
  Monad0: function() {
    return freeMonad;
  }
};
var liftF = function(f) {
  return fromView(new Bind(f, function($192) {
    return pure10($192);
  }));
};

// output/Data.Bifoldable/index.js
var bifoldableTuple = {
  bifoldMap: function(dictMonoid) {
    var append11 = append(dictMonoid.Semigroup0());
    return function(f) {
      return function(g) {
        return function(v) {
          return append11(f(v.value0))(g(v.value1));
        };
      };
    };
  },
  bifoldr: function(f) {
    return function(g) {
      return function(z) {
        return function(v) {
          return f(v.value0)(g(v.value1)(z));
        };
      };
    };
  },
  bifoldl: function(f) {
    return function(g) {
      return function(z) {
        return function(v) {
          return g(f(z)(v.value0))(v.value1);
        };
      };
    };
  }
};

// output/Data.Bitraversable/index.js
var bitraverse = function(dict) {
  return dict.bitraverse;
};
var ltraverse = function(dictBitraversable) {
  var bitraverse1 = bitraverse(dictBitraversable);
  return function(dictApplicative) {
    var bitraverse22 = bitraverse1(dictApplicative);
    var pure34 = pure(dictApplicative);
    return function(f) {
      return bitraverse22(f)(pure34);
    };
  };
};
var bitraversableTuple = {
  bitraverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    var apply15 = apply(Apply0);
    var map47 = map(Apply0.Functor0());
    return function(f) {
      return function(g) {
        return function(v) {
          return apply15(map47(Tuple.create)(f(v.value0)))(g(v.value1));
        };
      };
    };
  },
  bisequence: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    var apply15 = apply(Apply0);
    var map47 = map(Apply0.Functor0());
    return function(v) {
      return apply15(map47(Tuple.create)(v.value0))(v.value1);
    };
  },
  Bifunctor0: function() {
    return bifunctorTuple;
  },
  Bifoldable1: function() {
    return bifoldableTuple;
  }
};

// output/PureScript.CST.Traversal/index.js
var traverse3 = /* @__PURE__ */ traverse(traversableArray);
var traverse13 = /* @__PURE__ */ traverse(traversableTuple);
var traverse22 = /* @__PURE__ */ traverse(traversableMaybe);
var ltraverse2 = /* @__PURE__ */ ltraverse(bitraversableTuple);
var traverse32 = /* @__PURE__ */ traverse(traversableNonEmptyArray);
var bitraverse2 = /* @__PURE__ */ bitraverse(bitraversableTuple);
var traverseWrapped = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  return function(k) {
    return function(v) {
      return map47(function(value3) {
        return {
          open: v.open,
          close: v.close,
          value: value3
        };
      })(k(v.value));
    };
  };
};
var traverseSeparated = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse3(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(v1) {
        return function(v2) {
          return {
            head: v1,
            tail: v2
          };
        };
      })(k(v.head)))(traverse42(traverse52(k))(v.tail));
    };
  };
};
var traverseRecordUpdate = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof RecordUpdateLeaf) {
        return map47(RecordUpdateLeaf.create(v.value0)(v.value1))(k.onExpr(v.value2));
      }
      ;
      if (v instanceof RecordUpdateBranch) {
        return map47(RecordUpdateBranch.create(v.value0))(traverseWrapped1(traverseSeparated1(traverseRecordUpdate(dictApplicative)(k)))(v.value1));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 419, column 26 - line 421, column 146): " + [v.constructor.name]);
    };
  };
};
var traverseRecordLabeled = function(dictApplicative) {
  var pure210 = pure(dictApplicative);
  var map47 = map(dictApplicative.Apply0().Functor0());
  return function(k) {
    return function(v) {
      if (v instanceof RecordPun) {
        return pure210(new RecordPun(v.value0));
      }
      ;
      if (v instanceof RecordField) {
        return map47(RecordField.create(v.value0)(v.value1))(k(v.value2));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 394, column 27 - line 396, column 57): " + [v.constructor.name]);
    };
  };
};
var traverseRecordAccessor = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  return function(k) {
    return function(r) {
      return map47(function(v) {
        return {
          dot: r.dot,
          path: r.path,
          expr: v
        };
      })(k.onExpr(r.expr));
    };
  };
};
var traversePatternGuard = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse22(dictApplicative);
  var ltraverse1 = ltraverse2(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(binder) {
        return function(expr) {
          return {
            binder,
            expr
          };
        };
      })(traverse42(ltraverse1(k.onBinder))(v.binder)))(k.onExpr(v.expr));
    };
  };
};
var traverseModuleBody = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverse42 = traverse3(dictApplicative);
  return function(k) {
    return function(v) {
      return map47(function(decls) {
        return {
          trailingComments: v.trailingComments,
          end: v.end,
          decls
        };
      })(traverse42(k.onDecl)(v.decls));
    };
  };
};
var traverseModule = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseModuleBody1 = traverseModuleBody(dictApplicative);
  return function(k) {
    return function(v) {
      return map47(function(body) {
        return {
          header: v.header,
          body
        };
      })(traverseModuleBody1(k)(v.body));
    };
  };
};
var traverseLambda = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse32(dictApplicative);
  return function(k) {
    return function(l) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            arrow: l.arrow,
            symbol: l.symbol,
            binders: v,
            body: v1
          };
        };
      })(traverse42(k.onBinder)(l.binders)))(k.onExpr(l.body));
    };
  };
};
var traverseLabeled = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  return function(k) {
    return function(v) {
      return map47(function(value3) {
        return {
          label: v.label,
          separator: v.separator,
          value: value3
        };
      })(k(v.value));
    };
  };
};
var traverseRow = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse22(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(labels) {
        return function(tail2) {
          return {
            labels,
            tail: tail2
          };
        };
      })(traverse42(traverseSeparated1(traverseLabeled1(k.onType)))(v.labels)))(traverse42(traverse52(k.onType))(v.tail));
    };
  };
};
var traverseTypeVarBinding = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof TypeVarKinded) {
        return map47(TypeVarKinded.create)(traverseWrapped1(traverseLabeled1(k.onType))(v.value0));
      }
      ;
      if (v instanceof TypeVarName) {
        return pure210(new TypeVarName(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 320, column 28 - line 322, column 46): " + [v.constructor.name]);
    };
  };
};
var traverseType = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var traverseRow1 = traverseRow(dictApplicative);
  var apply15 = apply(Apply0);
  var flap2 = flap(Functor0);
  var traverse42 = traverse32(dictApplicative);
  var traverseTypeVarBinding1 = traverseTypeVarBinding(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof TypeRow) {
        return map47(TypeRow.create)(traverseWrapped1(traverseRow1(k))(v.value0));
      }
      ;
      if (v instanceof TypeRecord) {
        return map47(TypeRecord.create)(traverseWrapped1(traverseRow1(k))(v.value0));
      }
      ;
      if (v instanceof TypeForall) {
        return apply15(flap2(map47(TypeForall.create(v.value0))(traverse42(traverseTypeVarBinding1(k))(v.value1)))(v.value2))(k.onType(v.value3));
      }
      ;
      if (v instanceof TypeKinded) {
        return apply15(flap2(map47(TypeKinded.create)(k.onType(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof TypeApp) {
        return apply15(map47(TypeApp.create)(k.onType(v.value0)))(traverse42(k.onType)(v.value1));
      }
      ;
      if (v instanceof TypeOp) {
        return apply15(map47(TypeOp.create)(k.onType(v.value0)))(traverse42(traverse52(k.onType))(v.value1));
      }
      ;
      if (v instanceof TypeArrow) {
        return apply15(flap2(map47(TypeArrow.create)(k.onType(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof TypeConstrained) {
        return apply15(flap2(map47(TypeConstrained.create)(k.onType(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof TypeParens) {
        return map47(TypeParens.create)(traverseWrapped1(k.onType)(v.value0));
      }
      ;
      return pure210(v);
    };
  };
};
var traverseIfThenElse = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  return function(k) {
    return function(r) {
      return apply15(apply15(map47(function(v) {
        return function(v1) {
          return function(v2) {
            return {
              "else": r["else"],
              keyword: r.keyword,
              then: r.then,
              cond: v,
              "true": v1,
              "false": v2
            };
          };
        };
      })(k.onExpr(r.cond)))(k.onExpr(r["true"])))(k.onExpr(r["false"]));
    };
  };
};
var traverseWhere = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse22(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  var traverse6 = traverse32(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(expr) {
        return function(bindings) {
          return {
            expr,
            bindings
          };
        };
      })(k.onExpr(v.expr)))(traverse42(traverse52(traverse6(traverseLetBinding(dictApplicative)(k))))(v.bindings));
    };
  };
};
var traverseValueBindingFields = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse3(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(v1) {
        return function(v2) {
          return {
            name: v.name,
            binders: v1,
            guarded: v2
          };
        };
      })(traverse42(k.onBinder)(v.binders)))(traverseGuarded(dictApplicative)(k)(v.guarded));
    };
  };
};
var traverseLetBinding = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var apply15 = apply(Apply0);
  var flap2 = flap(Functor0);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof LetBindingSignature) {
        return map47(LetBindingSignature.create)(traverseLabeled1(k.onType)(v.value0));
      }
      ;
      if (v instanceof LetBindingName) {
        return map47(LetBindingName.create)(traverseValueBindingFields(dictApplicative)(k)(v.value0));
      }
      ;
      if (v instanceof LetBindingPattern) {
        return apply15(flap2(map47(LetBindingPattern.create)(k.onBinder(v.value0)))(v.value1))(traverseWhere(dictApplicative)(k)(v.value2));
      }
      ;
      if (v instanceof LetBindingError) {
        return pure210(new LetBindingError(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 498, column 24 - line 502, column 48): " + [v.constructor.name]);
    };
  };
};
var traverseGuardedExpr = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  var traversePatternGuard1 = traversePatternGuard(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(ps) {
        return function(wh) {
          return {
            bar: v.bar,
            separator: v.separator,
            patterns: ps,
            where: wh
          };
        };
      })(traverseSeparated1(traversePatternGuard1(k))(v.patterns)))(traverseWhere(dictApplicative)(k)(v.where));
    };
  };
};
var traverseGuarded = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverse42 = traverse32(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof Unconditional) {
        return map47(Unconditional.create(v.value0))(traverseWhere(dictApplicative)(k)(v.value1));
      }
      ;
      if (v instanceof Guarded) {
        return map47(Guarded.create)(traverse42(traverseGuardedExpr(dictApplicative)(k))(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 459, column 21 - line 461, column 72): " + [v.constructor.name]);
    };
  };
};
var traverseInstanceBinding = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var traverseValueBindingFields1 = traverseValueBindingFields(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof InstanceBindingSignature) {
        return map47(InstanceBindingSignature.create)(traverseLabeled1(k.onType)(v.value0));
      }
      ;
      if (v instanceof InstanceBindingName) {
        return map47(InstanceBindingName.create)(traverseValueBindingFields1(k)(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 247, column 29 - line 249, column 92): " + [v.constructor.name]);
    };
  };
};
var traverseLetIn = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse32(dictApplicative);
  var traverseLetBinding1 = traverseLetBinding(dictApplicative);
  return function(k) {
    return function(l) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            "in": l["in"],
            keyword: l.keyword,
            bindings: v,
            body: v1
          };
        };
      })(traverse42(traverseLetBinding1(k))(l.bindings)))(k.onExpr(l.body));
    };
  };
};
var traverseForeign = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof ForeignValue) {
        return map47(ForeignValue.create)(traverseLabeled1(k.onType)(v.value0));
      }
      ;
      if (v instanceof ForeignData) {
        return map47(ForeignData.create(v.value0))(traverseLabeled1(k.onType)(v.value1));
      }
      ;
      if (v instanceof ForeignKind) {
        return pure210(v);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 217, column 21 - line 220, column 40): " + [v.constructor.name]);
    };
  };
};
var traverseExprAppSpine = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  return function(k) {
    return function(v) {
      if (v instanceof AppType) {
        return map47(AppType.create(v.value0))(k.onType(v.value1));
      }
      ;
      if (v instanceof AppTerm) {
        return map47(AppTerm.create)(k.onExpr(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 353, column 26 - line 355, column 44): " + [v.constructor.name]);
    };
  };
};
var traverseDoStatement = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverse42 = traverse32(dictApplicative);
  var traverseLetBinding1 = traverseLetBinding(dictApplicative);
  var apply15 = apply(Apply0);
  var flap2 = flap(Functor0);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof DoLet) {
        return map47(DoLet.create(v.value0))(traverse42(traverseLetBinding1(k))(v.value1));
      }
      ;
      if (v instanceof DoDiscard) {
        return map47(DoDiscard.create)(k.onExpr(v.value0));
      }
      ;
      if (v instanceof DoBind) {
        return apply15(flap2(map47(DoBind.create)(k.onBinder(v.value0)))(v.value1))(k.onExpr(v.value2));
      }
      ;
      if (v instanceof DoError) {
        return pure210(new DoError(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 529, column 25 - line 533, column 32): " + [v.constructor.name]);
    };
  };
};
var traverseDoBlock = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverse42 = traverse32(dictApplicative);
  var traverseDoStatement1 = traverseDoStatement(dictApplicative);
  return function(k) {
    return function(d) {
      return map47(function(v) {
        return {
          keyword: d.keyword,
          statements: v
        };
      })(traverse42(traverseDoStatement1(k))(d.statements));
    };
  };
};
var traverseDelimitedNonEmpty = function(dictApplicative) {
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  return function(k) {
    return traverseWrapped1(traverseSeparated1(k));
  };
};
var traverseOneOrDelimited = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverseDelimitedNonEmpty1 = traverseDelimitedNonEmpty(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof One) {
        return map47(One.create)(k(v.value0));
      }
      ;
      if (v instanceof Many) {
        return map47(Many.create)(traverseDelimitedNonEmpty1(k)(v.value0));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Traversal (line 266, column 28 - line 268, column 55): " + [v.constructor.name]);
    };
  };
};
var traverseInstanceHead = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse22(dictApplicative);
  var ltraverse1 = ltraverse2(dictApplicative);
  var traverseOneOrDelimited1 = traverseOneOrDelimited(dictApplicative);
  var traverse52 = traverse3(dictApplicative);
  return function(k) {
    return function(head4) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            className: head4.className,
            keyword: head4.keyword,
            name: head4.name,
            constraints: v,
            types: v1
          };
        };
      })(traverse42(ltraverse1(traverseOneOrDelimited1(k.onType)))(head4.constraints)))(traverse52(k.onType)(head4.types));
    };
  };
};
var traverseInstance = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverseInstanceHead1 = traverseInstanceHead(dictApplicative);
  var traverse42 = traverse22(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  var traverse6 = traverse32(dictApplicative);
  var traverseInstanceBinding1 = traverseInstanceBinding(dictApplicative);
  return function(k) {
    return function(v) {
      return apply15(map47(function(head4) {
        return function(body) {
          return {
            head: head4,
            body
          };
        };
      })(traverseInstanceHead1(k)(v.head)))(traverse42(traverse52(traverse6(traverseInstanceBinding1(k))))(v.body));
    };
  };
};
var traverseDelimited = function(dictApplicative) {
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var traverse42 = traverse22(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  return function(k) {
    return traverseWrapped1(traverse42(traverseSeparated1(k)));
  };
};
var traverseDataHead = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverse42 = traverse3(dictApplicative);
  var traverseTypeVarBinding1 = traverseTypeVarBinding(dictApplicative);
  return function(k) {
    return function(head4) {
      return map47(function(v) {
        return {
          keyword: head4.keyword,
          name: head4.name,
          vars: v
        };
      })(traverse42(traverseTypeVarBinding1(k))(head4.vars));
    };
  };
};
var traverseDataCtor = function(dictApplicative) {
  var map47 = map(dictApplicative.Apply0().Functor0());
  var traverse42 = traverse3(dictApplicative);
  return function(k) {
    return function(v) {
      return map47(function(fields) {
        return {
          name: v.name,
          fields
        };
      })(traverse42(k.onType)(v.fields));
    };
  };
};
var traverseClassHead = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse22(dictApplicative);
  var ltraverse1 = ltraverse2(dictApplicative);
  var traverseOneOrDelimited1 = traverseOneOrDelimited(dictApplicative);
  var traverse52 = traverse3(dictApplicative);
  var traverseTypeVarBinding1 = traverseTypeVarBinding(dictApplicative);
  return function(k) {
    return function(head4) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            fundeps: head4.fundeps,
            keyword: head4.keyword,
            name: head4.name,
            "super": v,
            vars: v1
          };
        };
      })(traverse42(ltraverse1(traverseOneOrDelimited1(k.onType)))(head4["super"])))(traverse52(traverseTypeVarBinding1(k))(head4.vars));
    };
  };
};
var traverseDecl = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverseDataHead1 = traverseDataHead(dictApplicative);
  var traverse42 = traverse22(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  var traverseDataCtor1 = traverseDataCtor(dictApplicative);
  var flap2 = flap(Functor0);
  var traverseClassHead1 = traverseClassHead(dictApplicative);
  var traverse6 = traverse32(dictApplicative);
  var traverseLabeled1 = traverseLabeled(dictApplicative);
  var traverseInstance1 = traverseInstance(dictApplicative);
  var traverseInstanceHead1 = traverseInstanceHead(dictApplicative);
  var traverseValueBindingFields1 = traverseValueBindingFields(dictApplicative);
  var traverseForeign1 = traverseForeign(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof DeclData) {
        return apply15(map47(DeclData.create)(traverseDataHead1(k)(v.value0)))(traverse42(traverse52(traverseSeparated1(traverseDataCtor1(k))))(v.value1));
      }
      ;
      if (v instanceof DeclType) {
        return apply15(flap2(map47(DeclType.create)(traverseDataHead1(k)(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof DeclNewtype) {
        return apply15(flap2(flap2(map47(DeclNewtype.create)(traverseDataHead1(k)(v.value0)))(v.value1))(v.value2))(k.onType(v.value3));
      }
      ;
      if (v instanceof DeclClass) {
        return apply15(map47(DeclClass.create)(traverseClassHead1(k)(v.value0)))(traverse42(traverse52(traverse6(traverseLabeled1(k.onType))))(v.value1));
      }
      ;
      if (v instanceof DeclInstanceChain) {
        return map47(DeclInstanceChain.create)(traverseSeparated1(traverseInstance1(k))(v.value0));
      }
      ;
      if (v instanceof DeclDerive) {
        return map47(DeclDerive.create(v.value0)(v.value1))(traverseInstanceHead1(k)(v.value2));
      }
      ;
      if (v instanceof DeclKindSignature) {
        return map47(DeclKindSignature.create(v.value0))(traverseLabeled1(k.onType)(v.value1));
      }
      ;
      if (v instanceof DeclSignature) {
        return map47(DeclSignature.create)(traverseLabeled1(k.onType)(v.value0));
      }
      ;
      if (v instanceof DeclValue) {
        return map47(DeclValue.create)(traverseValueBindingFields1(k)(v.value0));
      }
      ;
      if (v instanceof DeclForeign) {
        return map47(DeclForeign.create(v.value0)(v.value1))(traverseForeign1(k)(v.value2));
      }
      ;
      return pure210(v);
    };
  };
};
var traverseCaseOf = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  var traverse42 = traverse32(dictApplicative);
  var bitraverse1 = bitraverse2(dictApplicative);
  var traverseGuarded1 = traverseGuarded(dictApplicative);
  return function(k) {
    return function(r) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            keyword: r.keyword,
            of: r.of,
            head: v,
            branches: v1
          };
        };
      })(traverseSeparated1(k.onExpr)(r.head)))(traverse42(bitraverse1(traverseSeparated1(k.onBinder))(traverseGuarded1(k)))(r.branches));
    };
  };
};
var traverseBinder = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverse42 = traverse3(dictApplicative);
  var traverseDelimited1 = traverseDelimited(dictApplicative);
  var traverseRecordLabeled1 = traverseRecordLabeled(dictApplicative);
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var apply15 = apply(Apply0);
  var flap2 = flap(Functor0);
  var traverse52 = traverse32(dictApplicative);
  var traverse6 = traverse13(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof BinderNamed) {
        return map47(BinderNamed.create(v.value0)(v.value1))(k.onBinder(v.value2));
      }
      ;
      if (v instanceof BinderConstructor) {
        return map47(BinderConstructor.create(v.value0))(traverse42(k.onBinder)(v.value1));
      }
      ;
      if (v instanceof BinderArray) {
        return map47(BinderArray.create)(traverseDelimited1(k.onBinder)(v.value0));
      }
      ;
      if (v instanceof BinderRecord) {
        return map47(BinderRecord.create)(traverseDelimited1(traverseRecordLabeled1(k.onBinder))(v.value0));
      }
      ;
      if (v instanceof BinderParens) {
        return map47(BinderParens.create)(traverseWrapped1(k.onBinder)(v.value0));
      }
      ;
      if (v instanceof BinderTyped) {
        return apply15(flap2(map47(BinderTyped.create)(k.onBinder(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof BinderOp) {
        return apply15(map47(BinderOp.create)(k.onBinder(v.value0)))(traverse52(traverse6(k.onBinder))(v.value1));
      }
      ;
      return pure210(v);
    };
  };
};
var traverseAdoBlock = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var apply15 = apply(Apply0);
  var map47 = map(Apply0.Functor0());
  var traverse42 = traverse3(dictApplicative);
  var traverseDoStatement1 = traverseDoStatement(dictApplicative);
  return function(k) {
    return function(a) {
      return apply15(map47(function(v) {
        return function(v1) {
          return {
            "in": a["in"],
            keyword: a.keyword,
            statements: v,
            result: v1
          };
        };
      })(traverse42(traverseDoStatement1(k))(a.statements)))(k.onExpr(a.result));
    };
  };
};
var traverseExpr = function(dictApplicative) {
  var Apply0 = dictApplicative.Apply0();
  var Functor0 = Apply0.Functor0();
  var map47 = map(Functor0);
  var traverseDelimited1 = traverseDelimited(dictApplicative);
  var traverseRecordLabeled1 = traverseRecordLabeled(dictApplicative);
  var traverseWrapped1 = traverseWrapped(dictApplicative);
  var apply15 = apply(Apply0);
  var flap2 = flap(Functor0);
  var traverse42 = traverse32(dictApplicative);
  var bitraverse1 = bitraverse2(dictApplicative);
  var traverse52 = traverse13(dictApplicative);
  var traverseRecordAccessor1 = traverseRecordAccessor(dictApplicative);
  var traverseSeparated1 = traverseSeparated(dictApplicative);
  var traverseRecordUpdate1 = traverseRecordUpdate(dictApplicative);
  var traverseExprAppSpine1 = traverseExprAppSpine(dictApplicative);
  var traverseLambda1 = traverseLambda(dictApplicative);
  var traverseIfThenElse1 = traverseIfThenElse(dictApplicative);
  var traverseCaseOf1 = traverseCaseOf(dictApplicative);
  var traverseLetIn1 = traverseLetIn(dictApplicative);
  var traverseDoBlock1 = traverseDoBlock(dictApplicative);
  var traverseAdoBlock1 = traverseAdoBlock(dictApplicative);
  var pure210 = pure(dictApplicative);
  return function(k) {
    return function(v) {
      if (v instanceof ExprArray) {
        return map47(ExprArray.create)(traverseDelimited1(k.onExpr)(v.value0));
      }
      ;
      if (v instanceof ExprRecord) {
        return map47(ExprRecord.create)(traverseDelimited1(traverseRecordLabeled1(k.onExpr))(v.value0));
      }
      ;
      if (v instanceof ExprParens) {
        return map47(ExprParens.create)(traverseWrapped1(k.onExpr)(v.value0));
      }
      ;
      if (v instanceof ExprTyped) {
        return apply15(flap2(map47(ExprTyped.create)(k.onExpr(v.value0)))(v.value1))(k.onType(v.value2));
      }
      ;
      if (v instanceof ExprInfix) {
        return apply15(map47(ExprInfix.create)(k.onExpr(v.value0)))(traverse42(bitraverse1(traverseWrapped1(k.onExpr))(k.onExpr))(v.value1));
      }
      ;
      if (v instanceof ExprOp) {
        return apply15(map47(ExprOp.create)(k.onExpr(v.value0)))(traverse42(traverse52(k.onExpr))(v.value1));
      }
      ;
      if (v instanceof ExprNegate) {
        return map47(ExprNegate.create(v.value0))(k.onExpr(v.value1));
      }
      ;
      if (v instanceof ExprRecordAccessor) {
        return map47(ExprRecordAccessor.create)(traverseRecordAccessor1(k)(v.value0));
      }
      ;
      if (v instanceof ExprRecordUpdate) {
        return apply15(map47(ExprRecordUpdate.create)(k.onExpr(v.value0)))(traverseWrapped1(traverseSeparated1(traverseRecordUpdate1(k)))(v.value1));
      }
      ;
      if (v instanceof ExprApp) {
        return apply15(map47(ExprApp.create)(k.onExpr(v.value0)))(traverse42(traverseExprAppSpine1(k))(v.value1));
      }
      ;
      if (v instanceof ExprLambda) {
        return map47(ExprLambda.create)(traverseLambda1(k)(v.value0));
      }
      ;
      if (v instanceof ExprIf) {
        return map47(ExprIf.create)(traverseIfThenElse1(k)(v.value0));
      }
      ;
      if (v instanceof ExprCase) {
        return map47(ExprCase.create)(traverseCaseOf1(k)(v.value0));
      }
      ;
      if (v instanceof ExprLet) {
        return map47(ExprLet.create)(traverseLetIn1(k)(v.value0));
      }
      ;
      if (v instanceof ExprDo) {
        return map47(ExprDo.create)(traverseDoBlock1(k)(v.value0));
      }
      ;
      if (v instanceof ExprAdo) {
        return map47(ExprAdo.create)(traverseAdoBlock1(k)(v.value0));
      }
      ;
      return pure210(v);
    };
  };
};

// output/Whine.Muting/index.js
var bind10 = /* @__PURE__ */ bind(bindMaybe);
var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorMaybe);
var alt8 = /* @__PURE__ */ alt(altMaybe);
var insertWith2 = /* @__PURE__ */ insertWith(ordString);
var append6 = /* @__PURE__ */ append(semigroupArray);
var member4 = /* @__PURE__ */ member(ordString);
var insert5 = /* @__PURE__ */ insert2(ordString);
var lookup7 = /* @__PURE__ */ lookup3(ordString);
var $$delete4 = /* @__PURE__ */ $$delete2(ordString);
var foldlWithIndex2 = /* @__PURE__ */ foldlWithIndex(foldableWithIndexArray);
var mapFlipped1 = /* @__PURE__ */ mapFlipped(functorMap);
var unionWith3 = /* @__PURE__ */ unionWith(ordString);
var MutedRange = /* @__PURE__ */ function() {
  function MutedRange2(value0) {
    this.value0 = value0;
  }
  ;
  MutedRange2.create = function(value0) {
    return new MutedRange2(value0);
  };
  return MutedRange2;
}();
var MutedLine = /* @__PURE__ */ function() {
  function MutedLine2(value0) {
    this.value0 = value0;
  }
  ;
  MutedLine2.create = function(value0) {
    return new MutedLine2(value0);
  };
  return MutedLine2;
}();
var Enable = /* @__PURE__ */ function() {
  function Enable2() {
  }
  ;
  Enable2.value = new Enable2();
  return Enable2;
}();
var Disable = /* @__PURE__ */ function() {
  function Disable2() {
  }
  ;
  Disable2.value = new Disable2();
  return Disable2;
}();
var DisableSingleLine = /* @__PURE__ */ function() {
  function DisableSingleLine2() {
  }
  ;
  DisableSingleLine2.value = new DisableSingleLine2();
  return DisableSingleLine2;
}();
var mutedRanges = function(v) {
  var parseLine = function(l) {
    return bind10(lastIndexOf2("-- #")(l))(function(commentStart) {
      var left = trim(take3(commentStart)(l));
      var comment2 = drop3(commentStart + 4 | 0)(l);
      var onPrefix = function(p) {
        return function(r) {
          return mapFlipped5(mapFlipped5(stripPrefix2(p)(comment2))(trim))(function(v1) {
            return new Tuple(r, v1);
          });
        };
      };
      var $21 = left !== "";
      if ($21) {
        return onPrefix("disable ")(DisableSingleLine.value);
      }
      ;
      return alt8(onPrefix("enable ")(Enable.value))(onPrefix("disable ")(Disable.value));
    });
  };
  var trackLine = function(idx) {
    return function(v1) {
      return function(line2) {
        var v2 = parseLine(line2);
        if (v2 instanceof Just && v2.value0.value0 instanceof DisableSingleLine) {
          return {
            open: v1.open,
            closed: insertWith2(append6)(v2.value0.value1)([new MutedLine(idx)])(v1.closed)
          };
        }
        ;
        var v3 = function(v4) {
          if (v2 instanceof Just && (v2.value0.value0 instanceof Enable && otherwise)) {
            return {
              open: v1.open,
              closed: v1.closed
            };
          }
          ;
          if (v2 instanceof Just && v2.value0.value0 instanceof Disable) {
            if (member4(v2.value0.value1)(v1.open)) {
              return {
                open: v1.open,
                closed: v1.closed
              };
            }
            ;
            if (otherwise) {
              return {
                open: insert5(v2.value0.value1)(idx)(v1.open),
                closed: v1.closed
              };
            }
            ;
          }
          ;
          if (v2 instanceof Nothing) {
            return {
              open: v1.open,
              closed: v1.closed
            };
          }
          ;
          throw new Error("Failed pattern match at Whine.Muting (line 52, column 1 - line 52, column 74): " + [v2.constructor.name]);
        };
        if (v2 instanceof Just && v2.value0.value0 instanceof Enable) {
          var $37 = lookup7(v2.value0.value1)(v1.open);
          if ($37 instanceof Just) {
            return {
              open: $$delete4(v2.value0.value1)(v1.open),
              closed: insertWith2(append6)(v2.value0.value1)([new MutedRange({
                start: $37.value0,
                end: idx
              })])(v1.closed)
            };
          }
          ;
          return v3(true);
        }
        ;
        return v3(true);
      };
    };
  };
  var trackedRanges = foldlWithIndex2(trackLine)({
    open: empty4,
    closed: empty4
  })(v.lines);
  var forceCloseOpenRanges = mapFlipped1(trackedRanges.open)(function(start) {
    return [new MutedRange({
      start,
      end: length(v.lines)
    })];
  });
  return unionWith3(append6)(forceCloseOpenRanges)(trackedRanges.closed);
};

// output/Whine.Runner.Glob/foreign.js
var import_micromatch = __toESM(require_micromatch(), 1);

// node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob3, position2) => {
  const pos = position2;
  if (glob3.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate2 = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i < glob3.length) {
    const c = glob3.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate2 = true;
      i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob3.startsWith(cls, i)) {
          if (rangeStart) {
            return ["$.", false, glob3.length - pos, true];
          }
          i += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i++;
      continue;
    }
    if (glob3.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-"));
      i += 2;
      continue;
    }
    if (glob3.startsWith("-", i + 1)) {
      rangeStart = c;
      i += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i++;
  }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob3.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate2) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate2 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate2 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str2, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str2.length) {
        const c = str2.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str2, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str2.length) {
      const c = str2.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str2.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str2, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str2.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob3 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob3.toUpperCase() !== glob3.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob3
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob3, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob3.length; i++) {
      const c = glob3.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob3.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob3, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob3 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob3), !!hasMagic2, uflag];
  }
};

// node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep2 = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep2;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter5 = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter5;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match2 = (list, pattern, options = {}) => {
  const mm2 = new Minimatch(pattern, options);
  list = list.filter((f) => mm2.match(f));
  if (mm2.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match2;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next2 = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next2 !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate2 = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate2 = !negate2;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate2;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next2 = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp[i] = twoStar;
          }
        } else if (next2 === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff2 = this.slashSplit(f);
    this.debug(this.pattern, "split", ff2);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff2[ff2.length - 1];
    if (!filename) {
      for (let i = ff2.length - 2; !filename && i >= 0; i--) {
        filename = ff2[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff2;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/glob/dist/esm/glob.js
import { fileURLToPath as fileURLToPath2 } from "node:url";

// node_modules/path-scurry/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max4) => !isPosInt(max4) ? null : max4 <= Math.pow(2, 8) ? Uint8Array : max4 <= Math.pow(2, 16) ? Uint16Array : max4 <= Math.pow(2, 32) ? Uint32Array : max4 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size6) {
    super(size6);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max4) {
    const HeapCls = getUintArray(max4);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max4, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max4, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max4);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index5, options, context) => c.#backgroundFetch(k, index5, options, context),
      moveToTail: (index5) => c.#moveToTail(index5),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index5) => c.#isStale(index5)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max: max4 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max4 !== 0 && !isPosInt(max4)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max4 ? getUintArray(max4) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max4);
    }
    this.#max = max4;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max4).fill(void 0);
    this.#valList = new Array(max4).fill(void 0);
    this.#next = new UintArray(max4);
    this.#prev = new UintArray(max4);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max4);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index5, ttl, start = perf.now()) => {
      starts[index5] = ttl !== 0 ? start : 0;
      ttls[index5] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index5)) {
            this.#delete(this.#keyList[index5], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index5) => {
      starts[index5] = ttls[index5] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index5) => {
      if (ttls[index5]) {
        const ttl = ttls[index5];
        const start = starts[index5];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index5 = this.#keyMap.get(key);
      if (index5 === void 0) {
        return 0;
      }
      const ttl = ttls[index5];
      const start = starts[index5];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index5) => {
      const s = starts[index5];
      const t = ttls[index5];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index5) => {
      this.#calculatedSize -= sizes[index5];
      sizes[index5] = 0;
    };
    this.#requireSize = (k, v, size6, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size6)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size6 = sizeCalculation(v, k);
          if (!isPosInt(size6)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size6;
    };
    this.#addItemSize = (index5, size6, status) => {
      sizes[index5] = size6;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index5];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index5];
      if (status) {
        status.entrySize = size6;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size6, sizeCalculation) => {
    if (size6 || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index5) {
    return index5 !== void 0 && this.#keyMap.get(this.#keyList[index5]) === index5;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value3 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value3 === void 0)
        continue;
      if (fn(value3, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value3 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value3 === void 0)
        continue;
      fn.call(thisp, value3, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value3 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value3 === void 0)
        continue;
      fn.call(thisp, value3, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value3 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value3 === void 0)
      return void 0;
    const entry = { value: value3 };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value3 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value3 === void 0 || key === void 0)
        continue;
      const entry = { value: value3 };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size6 = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size6 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index5 = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index5 === void 0) {
      index5 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index5] = k;
      this.#valList[index5] = v;
      this.#keyMap.set(k, index5);
      this.#next[this.#tail] = index5;
      this.#prev[index5] = this.#tail;
      this.#tail = index5;
      this.#size++;
      this.#addItemSize(index5, size6, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index5);
      const oldVal = this.#valList[index5];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index5);
        this.#addItemSize(index5, size6, status);
        this.#valList[index5] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index5, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index5);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head4 = this.#head;
    const k = this.#keyList[head4];
    const v = this.#valList[head4];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head4);
    if (free) {
      this.#keyList[head4] = void 0;
      this.#valList[head4] = void 0;
      this.#free.push(head4);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head4];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head4;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 !== void 0) {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index5)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index5);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index5);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index5);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 === void 0 || !allowStale && this.#isStale(index5)) {
      return;
    }
    const v = this.#valList[index5];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index5, options, context) {
    const v = index5 === void 0 ? void 0 : this.#valList[index5];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index5] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index5] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index5] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index5] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index5 === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index5 = this.#keyMap.get(k);
    } else {
      this.#valList[index5] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size6 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size6,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index5 = this.#keyMap.get(k);
    if (index5 === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index5, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index5);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index5);
        if (updateAgeOnGet) {
          this.#updateItemAge(index5);
        }
        if (status)
          this.#statusTTL(status, index5);
        return v;
      }
      const p = this.#backgroundFetch(k, index5, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 !== void 0) {
      const value3 = this.#valList[index5];
      const fetching = this.#isBackgroundFetch(value3);
      if (status)
        this.#statusTTL(status, index5);
      if (this.#isStale(index5)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value3 : void 0;
        } else {
          if (status && allowStale && value3.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value3.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value3.__staleWhileFetching;
        }
        this.#moveToTail(index5);
        if (updateAgeOnGet) {
          this.#updateItemAge(index5);
        }
        return value3;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index5) {
    if (index5 !== this.#tail) {
      if (index5 === this.#head) {
        this.#head = this.#next[index5];
      } else {
        this.#connect(this.#prev[index5], this.#next[index5]);
      }
      this.#connect(this.#tail, index5);
      this.#tail = index5;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index5 = this.#keyMap.get(k);
      if (index5 !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index5);
          const v = this.#valList[index5];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index5] = void 0;
          this.#valList[index5] = void 0;
          if (index5 === this.#tail) {
            this.#tail = this.#prev[index5];
          } else if (index5 === this.#head) {
            this.#head = this.#next[index5];
          } else {
            const pi = this.#prev[index5];
            this.#next[pi] = this.#next[index5];
            const ni = this.#next[index5];
            this.#prev[ni] = this.#prev[index5];
          }
          this.#size--;
          this.#free.push(index5);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index5 of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index5];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/path-scurry/dist/esm/index.js
import { posix, win32 } from "node:path";
import { fileURLToPath } from "node:url";
import { lstatSync as lstatSync2, readdir as readdirCB, readdirSync as readdirSync2, readlinkSync as readlinkSync2, realpathSync as rps } from "fs";
import * as actualFS from "node:fs";
import { lstat, readdir, readlink, realpath } from "node:fs/promises";

// node_modules/path-scurry/node_modules/minipass/dist/esm/index.js
import { EventEmitter } from "node:events";
import Stream from "node:stream";
import { StringDecoder } from "node:string_decoder";
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof Stream || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== Stream.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer4 = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass = class extends EventEmitter {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer4 : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer4(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer4(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer4(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer4(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve2, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve2());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve2;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value3) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve2({ value: value3, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve2({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve2 = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const value3 = this.read();
      return value3 === null ? stop() : { done: false, value: value3 };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// node_modules/path-scurry/dist/esm/index.js
var realpathSync2 = rps.native;
var defaultFS = {
  lstatSync: lstatSync2,
  readdir: readdirCB,
  readdirSync: readdirSync2,
  readlinkSync: readlinkSync2,
  realpathSync: realpathSync2,
  promises: {
    lstat,
    readdir,
    readlink,
    realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize2 = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize2(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = false;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   *
   * @deprecated
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name3, type = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name3;
    this.#matchName = nocase ? normalizeNocase(name3) : normalize2(name3);
    this.#type = type & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path3) {
    if (!path3) {
      return this;
    }
    const rootPath = this.getRootString(path3);
    const dir = path3.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name3 = this.nocase ? normalizeNocase(pathPart) : normalize2(pathPart);
    for (const p of children) {
      if (p.#matchName === name3) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name3 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name3;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name3 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name3;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name3 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name3;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize2(n) : this.#matchName === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read4 = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read4);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read4 = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read4);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c = children[p];
      if (c)
        c.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    if (code === "ENOTDIR" || code === "EPERM") {
      this.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code = "") {
    if (code === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code === "ENOENT")
      ter |= ENOENT;
    if (code === "EINVAL" || code === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type = entToType(e);
    const child = this.newChild(e.name, type, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      const pchild = c[p];
      const name3 = this.nocase ? normalizeNocase(e.name) : normalize2(e.name);
      if (name3 !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index5, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index5 !== c.provisional) {
      if (index5 === c.length - 1)
        c.pop();
      else
        c.splice(index5, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size: size6, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size6;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries2) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries2) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve2 = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve2 = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve2();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name3, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name3, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name3, type = UNKNOWN, opts = {}) {
    return new _PathWin32(name3, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path3) {
    return win32.parse(path3).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare5, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare5)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare5 = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare5;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name3, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name3, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path3) {
    return path3.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name3, type = UNKNOWN, opts = {}) {
    return new _PathPosix(name3, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd2 = process.cwd(), pathImpl, sep3, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
    this.#fs = fsFromOption(fs);
    if (cwd2 instanceof URL || cwd2.startsWith("file://")) {
      cwd2 = fileURLToPath(cwd2);
    }
    const cwdPath = pathImpl.resolve(cwd2);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split3 = cwdPath.substring(this.rootPath.length).split(sep3);
    if (split3.length === 1 && !split3[0]) {
      split3.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split3.length - 1;
    const joinSep = pathImpl.sep;
    let abs4 = this.rootPath;
    let sawFirst = false;
    for (const part of split3) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs4 += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path3 = this.cwd) {
    if (typeof path3 === "string") {
      path3 = this.cwd.resolve(path3);
    }
    return path3.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter6, walkFilter } = opts;
    const results = [];
    if (!filter6 || filter6(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries2) => {
        if (er) {
          return cb(er);
        }
        let len = entries2.length;
        if (!len)
          return cb();
        const next2 = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries2) {
          if (!filter6 || filter6(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next2) : next2());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk(e, next2);
            } else {
              next2();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter6, walkFilter } = opts;
    const results = [];
    if (!filter6 || filter6(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries2 = dir.readdirSync();
      for (const e of entries2) {
        if (!filter6 || filter6(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter6, walkFilter } = opts;
    if (!filter6 || filter6(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries2 = dir.readdirSync();
      for (const e of entries2) {
        if (!filter6 || filter6(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter6, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter6 || filter6(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing = 0;
    const process3 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries2, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries2) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries2, true));
              return;
            }
          }
          for (const e of entries2) {
            if (e && (!filter6 || filter6(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries2) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process3);
          } else if (!sync2) {
            process3();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process3();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter6, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter6 || filter6(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process3 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries2 = dir.readdirSync();
        for (const e of entries2) {
          if (!filter6 || filter6(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries2) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process3);
    };
    process3();
    return results;
  }
  chdir(path3 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path3 === "string" ? this.cwd.resolve(path3) : path3;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd2 = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd2, win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd2 = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd2, posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd2 = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd2, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern2 = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index5, platform) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index5 < 0 || index5 >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index5;
    this.#platform = platform;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// node_modules/glob/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter2 } from "node:events";
import Stream2 from "node:stream";
import { StringDecoder as StringDecoder2 } from "node:string_decoder";
var proc2 = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream2 = (s) => !!s && typeof s === "object" && (s instanceof Minipass2 || s instanceof Stream2 || isReadable2(s) || isWritable2(s));
var isReadable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== Stream2.Writable.prototype.pipe;
var isWritable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.write === "function" && typeof s.end === "function";
var EOF2 = Symbol("EOF");
var MAYBE_EMIT_END2 = Symbol("maybeEmitEnd");
var EMITTED_END2 = Symbol("emittedEnd");
var EMITTING_END2 = Symbol("emittingEnd");
var EMITTED_ERROR2 = Symbol("emittedError");
var CLOSED2 = Symbol("closed");
var READ2 = Symbol("read");
var FLUSH2 = Symbol("flush");
var FLUSHCHUNK2 = Symbol("flushChunk");
var ENCODING2 = Symbol("encoding");
var DECODER2 = Symbol("decoder");
var FLOWING2 = Symbol("flowing");
var PAUSED2 = Symbol("paused");
var RESUME2 = Symbol("resume");
var BUFFER2 = Symbol("buffer");
var PIPES2 = Symbol("pipes");
var BUFFERLENGTH2 = Symbol("bufferLength");
var BUFFERPUSH2 = Symbol("bufferPush");
var BUFFERSHIFT2 = Symbol("bufferShift");
var OBJECTMODE2 = Symbol("objectMode");
var DESTROYED2 = Symbol("destroyed");
var ERROR2 = Symbol("error");
var EMITDATA2 = Symbol("emitData");
var EMITEND3 = Symbol("emitEnd");
var EMITEND22 = Symbol("emitEnd2");
var ASYNC2 = Symbol("async");
var ABORT2 = Symbol("abort");
var ABORTED2 = Symbol("aborted");
var SIGNAL2 = Symbol("signal");
var DATALISTENERS2 = Symbol("dataListeners");
var DISCARDED2 = Symbol("discarded");
var defer5 = (fn) => Promise.resolve().then(fn);
var nodefer2 = (fn) => fn();
var isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike2 = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe2 = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME2]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors2 = class extends Pipe2 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions2 = (o) => !!o.objectMode;
var isEncodingOptions2 = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass2 = class extends EventEmitter2 {
  [FLOWING2] = false;
  [PAUSED2] = false;
  [PIPES2] = [];
  [BUFFER2] = [];
  [OBJECTMODE2];
  [ENCODING2];
  [ASYNC2];
  [DECODER2];
  [EOF2] = false;
  [EMITTED_END2] = false;
  [EMITTING_END2] = false;
  [CLOSED2] = false;
  [EMITTED_ERROR2] = null;
  [BUFFERLENGTH2] = 0;
  [DESTROYED2] = false;
  [SIGNAL2];
  [ABORTED2] = false;
  [DATALISTENERS2] = 0;
  [DISCARDED2] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions2(options)) {
      this[OBJECTMODE2] = true;
      this[ENCODING2] = null;
    } else if (isEncodingOptions2(options)) {
      this[ENCODING2] = options.encoding;
      this[OBJECTMODE2] = false;
    } else {
      this[OBJECTMODE2] = false;
      this[ENCODING2] = null;
    }
    this[ASYNC2] = !!options.async;
    this[DECODER2] = this[ENCODING2] ? new StringDecoder2(this[ENCODING2]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES2] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL2] = signal;
      if (signal.aborted) {
        this[ABORT2]();
      } else {
        signal.addEventListener("abort", () => this[ABORT2]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH2];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING2];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE2];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC2];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC2] = this[ASYNC2] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT2]() {
    this[ABORTED2] = true;
    this.emit("abort", this[SIGNAL2]?.reason);
    this.destroy(this[SIGNAL2]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED2];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED2])
      return false;
    if (this[EOF2])
      throw new Error("write after end");
    if (this[DESTROYED2]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC2] ? defer5 : nodefer2;
    if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView2(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike2(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE2]) {
      if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
        this[FLUSH2](true);
      if (this[FLOWING2])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH2](chunk);
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING2] && !this[DECODER2]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING2]) {
      chunk = this[DECODER2].write(chunk);
    }
    if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
      this[FLUSH2](true);
    if (this[FLOWING2])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH2](chunk);
    if (this[BUFFERLENGTH2] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING2];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED2])
      return null;
    this[DISCARDED2] = false;
    if (this[BUFFERLENGTH2] === 0 || n === 0 || n && n > this[BUFFERLENGTH2]) {
      this[MAYBE_EMIT_END2]();
      return null;
    }
    if (this[OBJECTMODE2])
      n = null;
    if (this[BUFFER2].length > 1 && !this[OBJECTMODE2]) {
      this[BUFFER2] = [
        this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
      ];
    }
    const ret = this[READ2](n || null, this[BUFFER2][0]);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [READ2](n, chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERSHIFT2]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT2]();
      else if (typeof c === "string") {
        this[BUFFER2][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH2] -= n;
      } else {
        this[BUFFER2][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH2] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF2] = true;
    this.writable = false;
    if (this[FLOWING2] || !this[PAUSED2])
      this[MAYBE_EMIT_END2]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME2]() {
    if (this[DESTROYED2])
      return;
    if (!this[DATALISTENERS2] && !this[PIPES2].length) {
      this[DISCARDED2] = true;
    }
    this[PAUSED2] = false;
    this[FLOWING2] = true;
    this.emit("resume");
    if (this[BUFFER2].length)
      this[FLUSH2]();
    else if (this[EOF2])
      this[MAYBE_EMIT_END2]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME2]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING2] = false;
    this[PAUSED2] = true;
    this[DISCARDED2] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED2];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING2];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED2];
  }
  [BUFFERPUSH2](chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] += 1;
    else
      this[BUFFERLENGTH2] += chunk.length;
    this[BUFFER2].push(chunk);
  }
  [BUFFERSHIFT2]() {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] -= 1;
    else
      this[BUFFERLENGTH2] -= this[BUFFER2][0].length;
    return this[BUFFER2].shift();
  }
  [FLUSH2](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
    if (!noDrain && !this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
  }
  [FLUSHCHUNK2](chunk) {
    this.emit("data", chunk);
    return this[FLOWING2];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED2])
      return dest;
    this[DISCARDED2] = false;
    const ended = this[EMITTED_END2];
    opts = opts || {};
    if (dest === proc2.stdout || dest === proc2.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES2].push(!opts.proxyErrors ? new Pipe2(this, dest, opts) : new PipeProxyErrors2(this, dest, opts));
      if (this[ASYNC2])
        defer5(() => this[RESUME2]());
      else
        this[RESUME2]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES2].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES2].length === 1) {
        if (this[FLOWING2] && this[DATALISTENERS2] === 0) {
          this[FLOWING2] = false;
        }
        this[PIPES2] = [];
      } else
        this[PIPES2].splice(this[PIPES2].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED2] = false;
      this[DATALISTENERS2]++;
      if (!this[PIPES2].length && !this[FLOWING2]) {
        this[RESUME2]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH2] !== 0) {
      super.emit("readable");
    } else if (isEndish2(ev) && this[EMITTED_END2]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR2]) {
      const h = handler;
      if (this[ASYNC2])
        defer5(() => h.call(this, this[EMITTED_ERROR2]));
      else
        h.call(this, this[EMITTED_ERROR2]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS2] = this.listeners("data").length;
      if (this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS2] = 0;
      if (!this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END2];
  }
  [MAYBE_EMIT_END2]() {
    if (!this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2]) {
      this[EMITTING_END2] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED2])
        this.emit("close");
      this[EMITTING_END2] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE2] && !data ? false : this[ASYNC2] ? (defer5(() => this[EMITDATA2](data)), true) : this[EMITDATA2](data);
    } else if (ev === "end") {
      return this[EMITEND3]();
    } else if (ev === "close") {
      this[CLOSED2] = true;
      if (!this[EMITTED_END2] && !this[DESTROYED2])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR2] = data;
      super.emit(ERROR2, data);
      const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITDATA2](data) {
    for (const p of this[PIPES2]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED2] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITEND3]() {
    if (this[EMITTED_END2])
      return false;
    this[EMITTED_END2] = true;
    this.readable = false;
    return this[ASYNC2] ? (defer5(() => this[EMITEND22]()), true) : this[EMITEND22]();
  }
  [EMITEND22]() {
    if (this[DECODER2]) {
      const data = this[DECODER2].end();
      if (data) {
        for (const p of this[PIPES2]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED2])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES2]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE2])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE2])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE2]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve2, reject) => {
      this.on(DESTROYED2, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve2());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF2])
        return stop();
      let resolve2;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value3) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        this.pause();
        resolve2({ value: value3, done: !!this[EOF2] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED2, ondestroy);
        stop();
        resolve2({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve2 = res2;
        this.once(DESTROYED2, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR2, stop);
      this.off(DESTROYED2, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const value3 = this.read();
      return value3 === null ? stop() : { done: false, value: value3 };
    };
    this.once("end", stop);
    this.once(ERROR2, stop);
    this.once(DESTROYED2, stop);
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED2]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED2);
      return this;
    }
    this[DESTROYED2] = true;
    this[DISCARDED2] = true;
    this[BUFFER2].length = 0;
    this[BUFFERLENGTH2] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED2])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED2);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream2;
  }
};

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm2 = new Minimatch(ign, this.mmopts);
    for (let i = 0; i < mm2.set.length; i++) {
      const parsed = mm2.set[i];
      const globParts = mm2.globParts[i];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern2(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative2 = p.relative() || ".";
    const relatives = `${relative2}/`;
    for (const m of this.relative) {
      if (m.match(relative2) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative2 = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative2))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path3, n]) => [
      path3,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries2) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries2) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
};

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path3, opts) {
    this.patterns = patterns;
    this.path = path3;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path3) {
    return this.seen.has(path3) || !!this.#ignore?.ignored?.(path3);
  }
  #childrenIgnored(path3) {
    return !!this.#ignore?.childrenIgnored?.(path3);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs4 = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs4) {
      const abs5 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs5 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next2());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next2);
      else {
        t.readdirCB((_, entries2) => this.walkCB3(t, entries2, processor, next2), true);
      }
    }
    next2();
  }
  walkCB3(target, entries2, processor, cb) {
    processor = processor.filterEntries(target, entries2);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next2());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next2);
    }
    next2();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next2);
    }
    next2();
  }
  walkCB3Sync(target, entries2, processor, cb) {
    processor = processor.filterEntries(target, entries2);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next2);
    }
    next2();
  }
};
var GlobWalker = class extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
    this.results = new Minipass2({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = fileURLToPath2(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set, m) => {
      set[0].push(...m.set);
      set[1].push(...m.globParts);
      return set;
    }, [[], []]);
    this.patterns = matchSet.map((set, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern2(set, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate2 = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate: iterate2,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// output/Whine.Runner.Glob/foreign.js
var test2 = ({ include, exclude }) => (file) => {
  return (include.length == 0 || import_micromatch.default.isMatch(file, include)) && (exclude.length == 0 || !import_micromatch.default.isMatch(file, exclude));
};
var glob2 = ({ include, exclude }) => () => globSync(include, { ignore: exclude });

// output/Whine.Runner.Glob/index.js
var emptyGlobs = {
  include: [],
  exclude: []
};

// output/Effect.Aff.Class/index.js
var lift42 = /* @__PURE__ */ lift(monadTransReaderT);
var monadAffAff = {
  liftAff: /* @__PURE__ */ identity(categoryFn),
  MonadEffect0: function() {
    return monadEffectAff;
  }
};
var liftAff = function(dict) {
  return dict.liftAff;
};
var monadAffReader = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var monadEffectReader2 = monadEffectReader(MonadEffect0);
  return {
    liftAff: function() {
      var $79 = lift42(MonadEffect0.Monad0());
      var $80 = liftAff(dictMonadAff);
      return function($81) {
        return $79($80($81));
      };
    }(),
    MonadEffect0: function() {
      return monadEffectReader2;
    }
  };
};
var monadAffWriter = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var Monad0 = MonadEffect0.Monad0();
  var liftAff1 = liftAff(dictMonadAff);
  return function(dictMonoid) {
    var monadEffectWriter3 = monadEffectWriter(dictMonoid)(MonadEffect0);
    return {
      liftAff: function() {
        var $85 = lift(monadTransWriterT(dictMonoid))(Monad0);
        return function($86) {
          return $85(liftAff1($86));
        };
      }(),
      MonadEffect0: function() {
        return monadEffectWriter3;
      }
    };
  };
};

// output/WhineM/index.js
var monadWriterT2 = /* @__PURE__ */ monadWriterT(monoidArray);
var monadTellWriterT2 = /* @__PURE__ */ monadTellWriterT(monoidArray);
var monadEffectWriter2 = /* @__PURE__ */ monadEffectWriter(monoidArray);
var monadAskWriterT2 = /* @__PURE__ */ monadAskWriterT(monoidArray);
var bindWriterT2 = /* @__PURE__ */ bindWriterT(semigroupArray);
var coerce5 = /* @__PURE__ */ coerce();
var applyWriterT2 = /* @__PURE__ */ applyWriterT(semigroupArray);
var applicativeWriterT2 = /* @__PURE__ */ applicativeWriterT(monoidArray);
var map26 = /* @__PURE__ */ map(functorArray);
var monadWhineM = function(dictMonad) {
  return monadWriterT2(monadReaderT(dictMonad));
};
var monadTellArrayViolationWh = function(dictMonad) {
  return monadTellWriterT2(monadReaderT(dictMonad));
};
var monadReportWhineM = function(dictMonad) {
  var monadWhineM1 = monadWhineM(dictMonad);
  return {
    reportViolation: function() {
      var $150 = tell(monadTellArrayViolationWh(dictMonad));
      return function($151) {
        return $150(singleton2($151));
      };
    }(),
    Monad0: function() {
      return monadWhineM1;
    }
  };
};
var monadEffectWhineM = function(dictMonadEffect) {
  return monadEffectWriter2(monadEffectReader(dictMonadEffect));
};
var monadAskWhineM = function(dictMonad) {
  return monadAskWriterT2(monadAskReaderT(dictMonad));
};
var monadAffWhineM = function(dictMonadAff) {
  return monadAffWriter(monadAffReader(dictMonadAff))(monoidArray);
};
var functorWhineM = function(dictFunctor) {
  return functorWriterT(functorReaderT(dictFunctor));
};
var bindWhineM = function(dictBind) {
  return bindWriterT2(bindReaderT(dictBind));
};
var monadContextWhineM = function(dictMonad) {
  var bind30 = bind(bindWhineM(dictMonad.Bind1()));
  var ask3 = ask(monadAskWhineM(dictMonad));
  var monadWhineM1 = monadWhineM(dictMonad);
  return function(dictTypeEquals) {
    return {
      currentModule: function(f) {
        return bind30(ask3)(function(env) {
          var v = coerce5(env);
          return v.currentModule(f);
        });
      },
      Monad0: function() {
        return monadWhineM1;
      }
    };
  };
};
var monadLogWhineM = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var Bind1 = Monad0.Bind1();
  var bind30 = bind(bindWhineM(Bind1));
  var mapFlipped15 = mapFlipped(functorWhineM(Bind1.Apply0().Functor0()));
  var ask3 = ask(monadAskWhineM(Monad0));
  var logDefault2 = logDefault(monadEffectWhineM(dictMonadEffect));
  return function(dictTypeEquals) {
    return {
      log: function(dictLoggable) {
        var logDefault1 = logDefault2(dictLoggable);
        return function(severity) {
          return function(message2) {
            return bind30(mapFlipped15(mapFlipped15(ask3)(coerce5))(function(v) {
              return v.logLevel;
            }))(function(level) {
              return logDefault1({
                level,
                severity
              })(message2);
            });
          };
        };
      }
    };
  };
};
var monadRulesWhineM = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadWhineM1 = monadWhineM(Monad0);
  var monadLogWhineM1 = monadLogWhineM(dictMonadEffect);
  var monadContextWhineM1 = monadContextWhineM(Monad0);
  var monadReportWhineM1 = monadReportWhineM(Monad0);
  return function(dictTypeEquals) {
    var monadLogWhineM2 = monadLogWhineM1(dictTypeEquals);
    var monadContextWhineM2 = monadContextWhineM1(dictTypeEquals);
    return {
      Monad0: function() {
        return monadWhineM1;
      },
      MonadLog1: function() {
        return monadLogWhineM2;
      },
      MonadContext2: function() {
        return monadContextWhineM2;
      },
      MonadReport3: function() {
        return monadReportWhineM1;
      }
    };
  };
};
var applyWhineM = function(dictApply) {
  return applyWriterT2(applyReaderT(dictApply));
};
var applicativeWhineM = function(dictApplicative) {
  return applicativeWriterT2(applicativeReaderT(dictApplicative));
};
var runWhineM = function(dictMonadEffect) {
  return function(env) {
    return function(v) {
      return runReaderT(runWriterT(v))(env);
    };
  };
};
var unliftWhineM = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var Bind1 = Monad0.Bind1();
  var bind30 = bind(bindWhineM(Bind1));
  var ask3 = ask(monadAskWhineM(Monad0));
  var pure34 = pure(applicativeWhineM(Monad0.Applicative0()));
  var map117 = map(Bind1.Apply0().Functor0());
  var runWhineM1 = runWhineM(dictMonadEffect);
  return function(f) {
    return bind30(ask3)(function(env) {
      return pure34(function(x) {
        return map117(fst)(runWhineM1(env)(f(x)));
      });
    });
  };
};
var mapViolations = function(dictMonad) {
  var bind30 = bind(bindReaderT(dictMonad.Bind1()));
  var pure34 = pure(applicativeReaderT(dictMonad.Applicative0()));
  return function(f) {
    return function(v) {
      return mapWriterT(function(x) {
        return bind30(x)(function(v1) {
          return pure34(new Tuple(v1.value0, map26(f)(v1.value1)));
        });
      })(v);
    };
  };
};
var mapEnv = function(f) {
  return function(v) {
    return mapWriterT(withReaderT(f))(v);
  };
};

// output/Whine/index.js
var traverse4 = /* @__PURE__ */ traverse(traversableNonEmptyArray);
var merge2 = /* @__PURE__ */ merge()();
var discard5 = /* @__PURE__ */ discard(discardUnit);
var bind11 = /* @__PURE__ */ bind(bindMaybe);
var lookup8 = /* @__PURE__ */ lookup3(ordString);
var discard12 = /* @__PURE__ */ discard5(bindMaybe);
var guard3 = /* @__PURE__ */ guard(alternativeMaybe);
var any6 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var pure11 = /* @__PURE__ */ pure(applicativeMaybe);
var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorMaybe);
var not5 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean)));
var $$try6 = /* @__PURE__ */ $$try(monadErrorEffect);
var runRules = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var applicativeWhineM2 = applicativeWhineM(Monad0.Applicative0());
  var forWithIndex_2 = forWithIndex_(applicativeWhineM2)(foldableWithIndexMap);
  var mapViolations3 = mapViolations(Monad0);
  var monadRulesWhineM2 = monadRulesWhineM(dictMonadEffect)(refl);
  var Bind1 = Monad0.Bind1();
  var discard23 = discard5(bindWhineM(Bind1));
  var for_2 = for_(applicativeWhineM2);
  var for_1 = for_2(foldableArray);
  var for_22 = for_2(foldableMaybe);
  var Apply0 = Bind1.Apply0();
  var applySecond4 = applySecond(applyWhineM(Apply0));
  var traverseBinder2 = traverseBinder(applicativeWhineM2);
  var traverseDecl2 = traverseDecl(applicativeWhineM2);
  var traverseType2 = traverseType(applicativeWhineM2);
  var $$void9 = $$void(functorWhineM(Apply0.Functor0()));
  var traverseModule2 = traverseModule(applicativeWhineM2);
  return function(dictRangeOf) {
    return function(rs) {
      return function(mdl) {
        var traverseSpine = function(dictApplicative) {
          var map47 = map(dictApplicative.Apply0().Functor0());
          return function(k) {
            return function(v) {
              if (v instanceof AppType) {
                return map47(AppType.create(v.value0))(k.onType(v.value1));
              }
              ;
              if (v instanceof AppTerm) {
                return map47(AppTerm.create)(k.onExpr(v.value0));
              }
              ;
              throw new Error("Failed pattern match at Whine (line 71, column 23 - line 73, column 56): " + [v.constructor.name]);
            };
          };
        };
        var traverseExpr$prime = function(dictApplicative) {
          var Apply01 = dictApplicative.Apply0();
          var apply15 = apply(Apply01);
          var map47 = map(Apply01.Functor0());
          var traverse14 = traverse4(dictApplicative);
          var traverseSpine1 = traverseSpine(dictApplicative);
          var traverseExpr2 = traverseExpr(dictApplicative);
          return function(k) {
            return function(v) {
              if (v instanceof ExprApp) {
                return apply15(map47(ExprApp.create)(k.onExpr(v.value0)))(traverse14(traverseSpine1(k))(v.value1));
              }
              ;
              return traverseExpr2(k)(v);
            };
          };
        };
        var traverseExpr$prime1 = traverseExpr$prime(applicativeWhineM2);
        var allRules = function(f) {
          return function(x) {
            return forWithIndex_2(rs)(function(rid) {
              return function(v) {
                var v1 = f(v.rule);
                return mapViolations3(merge2({
                  rule: rid
                }))(v1(monadRulesWhineM2)(dictRangeOf)(x));
              };
            });
          };
        };
        var onModule = function(v) {
          return discard23(allRules(function(v1) {
            return v1.onModule;
          })(v))(function() {
            return discard23(for_1(v.header.imports)(function(imp) {
              return allRules(function(v1) {
                return v1.onModuleImport;
              })(imp);
            }))(function() {
              return for_22(v.header.exports)(function(v1) {
                return discard23(allRules(function(v2) {
                  return v2.onModuleExport;
                })(v1.value.head))(function() {
                  return for_1(v1.value.tail)(function(v2) {
                    return allRules(function(v3) {
                      return v3.onModuleExport;
                    })(v2.value1);
                  });
                });
              });
            });
          });
        };
        var visitor = {
          onBinder: function(x) {
            return applySecond4(allRules(function(v) {
              return v.onBinder;
            })(x))(traverseBinder2(visitor)(x));
          },
          onExpr: function(x) {
            return applySecond4(allRules(function(v) {
              return v.onExpr;
            })(x))(traverseExpr$prime1(visitor)(x));
          },
          onDecl: function(x) {
            return applySecond4(allRules(function(v) {
              return v.onDecl;
            })(x))(traverseDecl2(visitor)(x));
          },
          onType: function(x) {
            return applySecond4(allRules(function(v) {
              return v.onType;
            })(x))(traverseType2(visitor)(x));
          }
        };
        return $$void9(mapEnv(merge2({
          currentModule: function(f) {
            return f(mdl);
          }
        }))(discard23(onModule(mdl))(function() {
          return traverseModule2(visitor)(mdl);
        })));
      };
    };
  };
};
var checkModule = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var mapViolations3 = mapViolations(Monad0);
  var discard23 = discard5(bindWhineM(Monad0.Bind1()));
  var logDebug3 = logDebug(monadLogWhineM(dictMonadEffect)(refl))(loggableString);
  var reportViolation2 = reportViolation(monadReportWhineM(Monad0));
  var runRules1 = runRules(dictMonadEffect);
  var runRules2 = runRules1(rangeOfRecoveredError);
  var runRules3 = runRules1(rangeOfVoid);
  return function(rules3) {
    return function(v) {
      var lines2 = split("\n")(v.text);
      var ranges = mutedRanges({
        lines: lines2
      });
      var isIntersecting = function(src) {
        return function(v1) {
          if (v1 instanceof MutedLine) {
            return src.start.line === v1.value0;
          }
          ;
          if (v1 instanceof MutedRange) {
            return src.start.line >= v1.value0.start && src.end.line <= v1.value0.end;
          }
          ;
          throw new Error("Failed pattern match at Whine (line 123, column 26 - line 125, column 82): " + [v1.constructor.name]);
        };
      };
      var isMutedByDirective = function(v1) {
        return fromMaybe(false)(bind11(v1.source)(function(source2) {
          return bind11(lookup8(v1.rule)(ranges))(function(rs) {
            return discard12(guard3(any6(isIntersecting(source2))(rs)))(function() {
              return pure11(true);
            });
          });
        }));
      };
      var isExcludedByPath = function(v1) {
        var globs = fromMaybe(emptyGlobs)(mapFlipped6(lookup8(v1.rule)(rules3))(function(v2) {
          return v2.globs;
        }));
        return not5(test2)(globs)(v.path);
      };
      var file = {
        path: v.path,
        lines: new Just(lines2)
      };
      var addMutedAndFile = function(v1) {
        return merge2({
          file,
          muted: isMutedByDirective(v1) || isExcludedByPath(v1)
        })(v1);
      };
      return mapViolations3(addMutedAndFile)(discard23(logDebug3("Parsing " + v.path))(function() {
        var v1 = parseModule2(v.text);
        if (v1 instanceof ParseFailed) {
          return reportViolation2({
            rule: "",
            source: Nothing.value,
            message: "Failed to parse the file"
          });
        }
        ;
        if (v1 instanceof ParseSucceededWithErrors) {
          return discard23(logDebug3("Parsed " + (v.path + ", running rules")))(function() {
            return runRules2(rules3)(v1.value0);
          });
        }
        ;
        if (v1 instanceof ParseSucceeded) {
          return discard23(logDebug3("Parsed " + (v.path + ", running rules")))(function() {
            return runRules3(rules3)(v1.value0);
          });
        }
        ;
        throw new Error("Failed pattern match at Whine (line 104, column 5 - line 112, column 25): " + [v1.constructor.name]);
      }));
    };
  };
};
var checkFile = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var bind114 = bind(bindWhineM(Monad0.Bind1()));
  var liftEffect3 = liftEffect(monadEffectWhineM(dictMonadEffect));
  var reportViolation2 = reportViolation(monadReportWhineM(Monad0));
  var checkModule1 = checkModule(dictMonadEffect);
  return function(rules3) {
    return function(path3) {
      return bind114(liftEffect3($$try6(readTextFile(UTF8.value)(path3))))(function(eText) {
        if (eText instanceof Left) {
          return reportViolation2({
            message: "Failed to read the file: " + message(eText.value0),
            source: Nothing.value,
            muted: false,
            rule: "",
            file: {
              path: path3,
              lines: Nothing.value
            }
          });
        }
        ;
        if (eText instanceof Right) {
          return checkModule1(rules3)({
            path: path3,
            text: eText.value0
          });
        }
        ;
        throw new Error("Failed pattern match at Whine (line 83, column 3 - line 93, column 39): " + [eText.constructor.name]);
      });
    };
  };
};

// output/Ansi.Codes/index.js
var show6 = /* @__PURE__ */ show(showInt);
var intercalate4 = /* @__PURE__ */ intercalate(foldableNonEmptyList)(monoidString);
var map27 = /* @__PURE__ */ map(functorNonEmptyList);
var Bold = /* @__PURE__ */ function() {
  function Bold2() {
  }
  ;
  Bold2.value = new Bold2();
  return Bold2;
}();
var Dim = /* @__PURE__ */ function() {
  function Dim2() {
  }
  ;
  Dim2.value = new Dim2();
  return Dim2;
}();
var Italic = /* @__PURE__ */ function() {
  function Italic2() {
  }
  ;
  Italic2.value = new Italic2();
  return Italic2;
}();
var Underline = /* @__PURE__ */ function() {
  function Underline2() {
  }
  ;
  Underline2.value = new Underline2();
  return Underline2;
}();
var Inverse = /* @__PURE__ */ function() {
  function Inverse2() {
  }
  ;
  Inverse2.value = new Inverse2();
  return Inverse2;
}();
var Strikethrough = /* @__PURE__ */ function() {
  function Strikethrough2() {
  }
  ;
  Strikethrough2.value = new Strikethrough2();
  return Strikethrough2;
}();
var ToEnd = /* @__PURE__ */ function() {
  function ToEnd2() {
  }
  ;
  ToEnd2.value = new ToEnd2();
  return ToEnd2;
}();
var FromBeginning = /* @__PURE__ */ function() {
  function FromBeginning2() {
  }
  ;
  FromBeginning2.value = new FromBeginning2();
  return FromBeginning2;
}();
var Entire = /* @__PURE__ */ function() {
  function Entire2() {
  }
  ;
  Entire2.value = new Entire2();
  return Entire2;
}();
var Black = /* @__PURE__ */ function() {
  function Black2() {
  }
  ;
  Black2.value = new Black2();
  return Black2;
}();
var Red = /* @__PURE__ */ function() {
  function Red2() {
  }
  ;
  Red2.value = new Red2();
  return Red2;
}();
var Green = /* @__PURE__ */ function() {
  function Green2() {
  }
  ;
  Green2.value = new Green2();
  return Green2;
}();
var Yellow = /* @__PURE__ */ function() {
  function Yellow2() {
  }
  ;
  Yellow2.value = new Yellow2();
  return Yellow2;
}();
var Blue = /* @__PURE__ */ function() {
  function Blue2() {
  }
  ;
  Blue2.value = new Blue2();
  return Blue2;
}();
var Magenta = /* @__PURE__ */ function() {
  function Magenta2() {
  }
  ;
  Magenta2.value = new Magenta2();
  return Magenta2;
}();
var Cyan = /* @__PURE__ */ function() {
  function Cyan2() {
  }
  ;
  Cyan2.value = new Cyan2();
  return Cyan2;
}();
var White = /* @__PURE__ */ function() {
  function White2() {
  }
  ;
  White2.value = new White2();
  return White2;
}();
var BrightBlack = /* @__PURE__ */ function() {
  function BrightBlack2() {
  }
  ;
  BrightBlack2.value = new BrightBlack2();
  return BrightBlack2;
}();
var BrightRed = /* @__PURE__ */ function() {
  function BrightRed2() {
  }
  ;
  BrightRed2.value = new BrightRed2();
  return BrightRed2;
}();
var BrightGreen = /* @__PURE__ */ function() {
  function BrightGreen2() {
  }
  ;
  BrightGreen2.value = new BrightGreen2();
  return BrightGreen2;
}();
var BrightYellow = /* @__PURE__ */ function() {
  function BrightYellow2() {
  }
  ;
  BrightYellow2.value = new BrightYellow2();
  return BrightYellow2;
}();
var BrightBlue = /* @__PURE__ */ function() {
  function BrightBlue2() {
  }
  ;
  BrightBlue2.value = new BrightBlue2();
  return BrightBlue2;
}();
var BrightMagenta = /* @__PURE__ */ function() {
  function BrightMagenta2() {
  }
  ;
  BrightMagenta2.value = new BrightMagenta2();
  return BrightMagenta2;
}();
var BrightCyan = /* @__PURE__ */ function() {
  function BrightCyan2() {
  }
  ;
  BrightCyan2.value = new BrightCyan2();
  return BrightCyan2;
}();
var BrightWhite = /* @__PURE__ */ function() {
  function BrightWhite2() {
  }
  ;
  BrightWhite2.value = new BrightWhite2();
  return BrightWhite2;
}();
var Reset = /* @__PURE__ */ function() {
  function Reset2() {
  }
  ;
  Reset2.value = new Reset2();
  return Reset2;
}();
var PMode = /* @__PURE__ */ function() {
  function PMode2(value0) {
    this.value0 = value0;
  }
  ;
  PMode2.create = function(value0) {
    return new PMode2(value0);
  };
  return PMode2;
}();
var PForeground = /* @__PURE__ */ function() {
  function PForeground2(value0) {
    this.value0 = value0;
  }
  ;
  PForeground2.create = function(value0) {
    return new PForeground2(value0);
  };
  return PForeground2;
}();
var PBackground = /* @__PURE__ */ function() {
  function PBackground2(value0) {
    this.value0 = value0;
  }
  ;
  PBackground2.create = function(value0) {
    return new PBackground2(value0);
  };
  return PBackground2;
}();
var Up = /* @__PURE__ */ function() {
  function Up2(value0) {
    this.value0 = value0;
  }
  ;
  Up2.create = function(value0) {
    return new Up2(value0);
  };
  return Up2;
}();
var Down = /* @__PURE__ */ function() {
  function Down2(value0) {
    this.value0 = value0;
  }
  ;
  Down2.create = function(value0) {
    return new Down2(value0);
  };
  return Down2;
}();
var Forward = /* @__PURE__ */ function() {
  function Forward2(value0) {
    this.value0 = value0;
  }
  ;
  Forward2.create = function(value0) {
    return new Forward2(value0);
  };
  return Forward2;
}();
var Back = /* @__PURE__ */ function() {
  function Back2(value0) {
    this.value0 = value0;
  }
  ;
  Back2.create = function(value0) {
    return new Back2(value0);
  };
  return Back2;
}();
var NextLine = /* @__PURE__ */ function() {
  function NextLine2(value0) {
    this.value0 = value0;
  }
  ;
  NextLine2.create = function(value0) {
    return new NextLine2(value0);
  };
  return NextLine2;
}();
var PreviousLine = /* @__PURE__ */ function() {
  function PreviousLine2(value0) {
    this.value0 = value0;
  }
  ;
  PreviousLine2.create = function(value0) {
    return new PreviousLine2(value0);
  };
  return PreviousLine2;
}();
var HorizontalAbsolute = /* @__PURE__ */ function() {
  function HorizontalAbsolute2(value0) {
    this.value0 = value0;
  }
  ;
  HorizontalAbsolute2.create = function(value0) {
    return new HorizontalAbsolute2(value0);
  };
  return HorizontalAbsolute2;
}();
var Position = /* @__PURE__ */ function() {
  function Position2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Position2.create = function(value0) {
    return function(value12) {
      return new Position2(value0, value12);
    };
  };
  return Position2;
}();
var EraseData = /* @__PURE__ */ function() {
  function EraseData2(value0) {
    this.value0 = value0;
  }
  ;
  EraseData2.create = function(value0) {
    return new EraseData2(value0);
  };
  return EraseData2;
}();
var EraseLine = /* @__PURE__ */ function() {
  function EraseLine2(value0) {
    this.value0 = value0;
  }
  ;
  EraseLine2.create = function(value0) {
    return new EraseLine2(value0);
  };
  return EraseLine2;
}();
var ScrollUp = /* @__PURE__ */ function() {
  function ScrollUp2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollUp2.create = function(value0) {
    return new ScrollUp2(value0);
  };
  return ScrollUp2;
}();
var ScrollDown = /* @__PURE__ */ function() {
  function ScrollDown2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollDown2.create = function(value0) {
    return new ScrollDown2(value0);
  };
  return ScrollDown2;
}();
var Graphics = /* @__PURE__ */ function() {
  function Graphics2(value0) {
    this.value0 = value0;
  }
  ;
  Graphics2.create = function(value0) {
    return new Graphics2(value0);
  };
  return Graphics2;
}();
var SavePosition = /* @__PURE__ */ function() {
  function SavePosition2() {
  }
  ;
  SavePosition2.value = new SavePosition2();
  return SavePosition2;
}();
var RestorePosition = /* @__PURE__ */ function() {
  function RestorePosition2() {
  }
  ;
  RestorePosition2.value = new RestorePosition2();
  return RestorePosition2;
}();
var QueryPosition = /* @__PURE__ */ function() {
  function QueryPosition2() {
  }
  ;
  QueryPosition2.value = new QueryPosition2();
  return QueryPosition2;
}();
var HideCursor = /* @__PURE__ */ function() {
  function HideCursor2() {
  }
  ;
  HideCursor2.value = new HideCursor2();
  return HideCursor2;
}();
var ShowCursor = /* @__PURE__ */ function() {
  function ShowCursor2() {
  }
  ;
  ShowCursor2.value = new ShowCursor2();
  return ShowCursor2;
}();
var prefix = "\x1B[";
var eraseParamToString = function(ep) {
  if (ep instanceof ToEnd) {
    return "0";
  }
  ;
  if (ep instanceof FromBeginning) {
    return "1";
  }
  ;
  if (ep instanceof Entire) {
    return "2";
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 95, column 3 - line 98, column 25): " + [ep.constructor.name]);
};
var colorSuffix = "m";
var colorCode = function(c) {
  if (c instanceof Black) {
    return 30;
  }
  ;
  if (c instanceof Red) {
    return 31;
  }
  ;
  if (c instanceof Green) {
    return 32;
  }
  ;
  if (c instanceof Yellow) {
    return 33;
  }
  ;
  if (c instanceof Blue) {
    return 34;
  }
  ;
  if (c instanceof Magenta) {
    return 35;
  }
  ;
  if (c instanceof Cyan) {
    return 36;
  }
  ;
  if (c instanceof White) {
    return 37;
  }
  ;
  if (c instanceof BrightBlack) {
    return 90;
  }
  ;
  if (c instanceof BrightRed) {
    return 91;
  }
  ;
  if (c instanceof BrightGreen) {
    return 92;
  }
  ;
  if (c instanceof BrightYellow) {
    return 93;
  }
  ;
  if (c instanceof BrightBlue) {
    return 94;
  }
  ;
  if (c instanceof BrightMagenta) {
    return 95;
  }
  ;
  if (c instanceof BrightCyan) {
    return 96;
  }
  ;
  if (c instanceof BrightWhite) {
    return 97;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 173, column 3 - line 189, column 22): " + [c.constructor.name]);
};
var codeForRenderingMode = function(m) {
  if (m instanceof Bold) {
    return 1;
  }
  ;
  if (m instanceof Dim) {
    return 2;
  }
  ;
  if (m instanceof Italic) {
    return 3;
  }
  ;
  if (m instanceof Underline) {
    return 4;
  }
  ;
  if (m instanceof Inverse) {
    return 7;
  }
  ;
  if (m instanceof Strikethrough) {
    return 9;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 138, column 3 - line 144, column 23): " + [m.constructor.name]);
};
var graphicsParamToString = function(gp) {
  if (gp instanceof Reset) {
    return "0";
  }
  ;
  if (gp instanceof PMode) {
    return show6(codeForRenderingMode(gp.value0));
  }
  ;
  if (gp instanceof PForeground) {
    return show6(colorCode(gp.value0));
  }
  ;
  if (gp instanceof PBackground) {
    return show6(colorCode(gp.value0) + 10 | 0);
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 116, column 3 - line 120, column 45): " + [gp.constructor.name]);
};
var escapeCodeToString = /* @__PURE__ */ function() {
  var go = function(c) {
    if (c instanceof Up) {
      return show6(c.value0) + "A";
    }
    ;
    if (c instanceof Down) {
      return show6(c.value0) + "B";
    }
    ;
    if (c instanceof Forward) {
      return show6(c.value0) + "C";
    }
    ;
    if (c instanceof Back) {
      return show6(c.value0) + "D";
    }
    ;
    if (c instanceof NextLine) {
      return show6(c.value0) + "E";
    }
    ;
    if (c instanceof PreviousLine) {
      return show6(c.value0) + "F";
    }
    ;
    if (c instanceof HorizontalAbsolute) {
      return show6(c.value0) + "G";
    }
    ;
    if (c instanceof Position) {
      return show6(c.value0) + (";" + (show6(c.value1) + "H"));
    }
    ;
    if (c instanceof EraseData) {
      return eraseParamToString(c.value0) + "J";
    }
    ;
    if (c instanceof EraseLine) {
      return eraseParamToString(c.value0) + "K";
    }
    ;
    if (c instanceof ScrollUp) {
      return show6(c.value0) + "S";
    }
    ;
    if (c instanceof ScrollDown) {
      return show6(c.value0) + "T";
    }
    ;
    if (c instanceof Graphics) {
      return intercalate4(";")(map27(graphicsParamToString)(c.value0)) + colorSuffix;
    }
    ;
    if (c instanceof SavePosition) {
      return "s";
    }
    ;
    if (c instanceof RestorePosition) {
      return "u";
    }
    ;
    if (c instanceof QueryPosition) {
      return "6n";
    }
    ;
    if (c instanceof HideCursor) {
      return "?25l";
    }
    ;
    if (c instanceof ShowCursor) {
      return "?25h";
    }
    ;
    throw new Error("Failed pattern match at Ansi.Codes (line 53, column 5 - line 71, column 37): " + [c.constructor.name]);
  };
  return function($846) {
    return function(v) {
      return prefix + v;
    }(go($846));
  };
}();

// output/Ansi.Output/index.js
var pure12 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var withGraphics = function(params) {
  return function(text2) {
    return escapeCodeToString(new Graphics(params)) + (text2 + escapeCodeToString(new Graphics(pure12(Reset.value))));
  };
};
var foreground = function(c) {
  return pure12(new PForeground(c));
};

// output/Data.String.Utils/foreign.js
function padStartPrimeImpl(targetLength, str2) {
  return str2.padStart(targetLength);
}

// output/Data.String.Utils/index.js
var padStart$prime = function(n) {
  return function(s) {
    return padStartPrimeImpl(n, s);
  };
};

// output/ExitCodes/index.js
var Success = /* @__PURE__ */ function() {
  function Success3() {
  }
  ;
  Success3.value = new Success3();
  return Success3;
}();
var $$Error = /* @__PURE__ */ function() {
  function $$Error2() {
  }
  ;
  $$Error2.value = new $$Error2();
  return $$Error2;
}();
var MisuseOfShellBuiltins = /* @__PURE__ */ function() {
  function MisuseOfShellBuiltins2() {
  }
  ;
  MisuseOfShellBuiltins2.value = new MisuseOfShellBuiltins2();
  return MisuseOfShellBuiltins2;
}();
var CLIUsageError = /* @__PURE__ */ function() {
  function CLIUsageError2() {
  }
  ;
  CLIUsageError2.value = new CLIUsageError2();
  return CLIUsageError2;
}();
var DataFormatError = /* @__PURE__ */ function() {
  function DataFormatError2() {
  }
  ;
  DataFormatError2.value = new DataFormatError2();
  return DataFormatError2;
}();
var CannotOpenInput = /* @__PURE__ */ function() {
  function CannotOpenInput2() {
  }
  ;
  CannotOpenInput2.value = new CannotOpenInput2();
  return CannotOpenInput2;
}();
var AddresseeUnknown = /* @__PURE__ */ function() {
  function AddresseeUnknown2() {
  }
  ;
  AddresseeUnknown2.value = new AddresseeUnknown2();
  return AddresseeUnknown2;
}();
var HostNameUnknown = /* @__PURE__ */ function() {
  function HostNameUnknown2() {
  }
  ;
  HostNameUnknown2.value = new HostNameUnknown2();
  return HostNameUnknown2;
}();
var ServiceUnavailable = /* @__PURE__ */ function() {
  function ServiceUnavailable2() {
  }
  ;
  ServiceUnavailable2.value = new ServiceUnavailable2();
  return ServiceUnavailable2;
}();
var InternalSoftwareError = /* @__PURE__ */ function() {
  function InternalSoftwareError2() {
  }
  ;
  InternalSoftwareError2.value = new InternalSoftwareError2();
  return InternalSoftwareError2;
}();
var SystemError = /* @__PURE__ */ function() {
  function SystemError2() {
  }
  ;
  SystemError2.value = new SystemError2();
  return SystemError2;
}();
var CriticalOSFileMissing = /* @__PURE__ */ function() {
  function CriticalOSFileMissing2() {
  }
  ;
  CriticalOSFileMissing2.value = new CriticalOSFileMissing2();
  return CriticalOSFileMissing2;
}();
var CannotCreateOutputFile = /* @__PURE__ */ function() {
  function CannotCreateOutputFile2() {
  }
  ;
  CannotCreateOutputFile2.value = new CannotCreateOutputFile2();
  return CannotCreateOutputFile2;
}();
var IOError = /* @__PURE__ */ function() {
  function IOError2() {
  }
  ;
  IOError2.value = new IOError2();
  return IOError2;
}();
var TemporaryFailure = /* @__PURE__ */ function() {
  function TemporaryFailure2() {
  }
  ;
  TemporaryFailure2.value = new TemporaryFailure2();
  return TemporaryFailure2;
}();
var RemoteError = /* @__PURE__ */ function() {
  function RemoteError2() {
  }
  ;
  RemoteError2.value = new RemoteError2();
  return RemoteError2;
}();
var PermissionDenied = /* @__PURE__ */ function() {
  function PermissionDenied2() {
  }
  ;
  PermissionDenied2.value = new PermissionDenied2();
  return PermissionDenied2;
}();
var ConfigurationError = /* @__PURE__ */ function() {
  function ConfigurationError2() {
  }
  ;
  ConfigurationError2.value = new ConfigurationError2();
  return ConfigurationError2;
}();
var CannotExecute = /* @__PURE__ */ function() {
  function CannotExecute2() {
  }
  ;
  CannotExecute2.value = new CannotExecute2();
  return CannotExecute2;
}();
var CommandNotFound = /* @__PURE__ */ function() {
  function CommandNotFound2() {
  }
  ;
  CommandNotFound2.value = new CommandNotFound2();
  return CommandNotFound2;
}();
var InvalidExitArgument = /* @__PURE__ */ function() {
  function InvalidExitArgument2() {
  }
  ;
  InvalidExitArgument2.value = new InvalidExitArgument2();
  return InvalidExitArgument2;
}();
var SIGHUP = /* @__PURE__ */ function() {
  function SIGHUP2() {
  }
  ;
  SIGHUP2.value = new SIGHUP2();
  return SIGHUP2;
}();
var SIGINT = /* @__PURE__ */ function() {
  function SIGINT2() {
  }
  ;
  SIGINT2.value = new SIGINT2();
  return SIGINT2;
}();
var SIGQUIT = /* @__PURE__ */ function() {
  function SIGQUIT2() {
  }
  ;
  SIGQUIT2.value = new SIGQUIT2();
  return SIGQUIT2;
}();
var SIGILL = /* @__PURE__ */ function() {
  function SIGILL2() {
  }
  ;
  SIGILL2.value = new SIGILL2();
  return SIGILL2;
}();
var SIGABRT = /* @__PURE__ */ function() {
  function SIGABRT2() {
  }
  ;
  SIGABRT2.value = new SIGABRT2();
  return SIGABRT2;
}();
var SIGFPE = /* @__PURE__ */ function() {
  function SIGFPE2() {
  }
  ;
  SIGFPE2.value = new SIGFPE2();
  return SIGFPE2;
}();
var SIGKILL = /* @__PURE__ */ function() {
  function SIGKILL2() {
  }
  ;
  SIGKILL2.value = new SIGKILL2();
  return SIGKILL2;
}();
var SIGSEGV = /* @__PURE__ */ function() {
  function SIGSEGV2() {
  }
  ;
  SIGSEGV2.value = new SIGSEGV2();
  return SIGSEGV2;
}();
var SIGPIPE = /* @__PURE__ */ function() {
  function SIGPIPE2() {
  }
  ;
  SIGPIPE2.value = new SIGPIPE2();
  return SIGPIPE2;
}();
var SIGALRM = /* @__PURE__ */ function() {
  function SIGALRM2() {
  }
  ;
  SIGALRM2.value = new SIGALRM2();
  return SIGALRM2;
}();
var SIGTERM = /* @__PURE__ */ function() {
  function SIGTERM2() {
  }
  ;
  SIGTERM2.value = new SIGTERM2();
  return SIGTERM2;
}();
var eqExitCode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return true;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return true;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return true;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return true;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return true;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return true;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return true;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return true;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return true;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return true;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return true;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return true;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return true;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return true;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return true;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return true;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return true;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return true;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return true;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return true;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return true;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return true;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return true;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return true;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return true;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return true;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return true;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return true;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return true;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return true;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return true;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordExitCode = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return EQ.value;
      }
      ;
      if (x instanceof Success) {
        return LT.value;
      }
      ;
      if (y instanceof Success) {
        return GT.value;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return EQ.value;
      }
      ;
      if (x instanceof $$Error) {
        return LT.value;
      }
      ;
      if (y instanceof $$Error) {
        return GT.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return EQ.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins) {
        return LT.value;
      }
      ;
      if (y instanceof MisuseOfShellBuiltins) {
        return GT.value;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return EQ.value;
      }
      ;
      if (x instanceof CLIUsageError) {
        return LT.value;
      }
      ;
      if (y instanceof CLIUsageError) {
        return GT.value;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return EQ.value;
      }
      ;
      if (x instanceof DataFormatError) {
        return LT.value;
      }
      ;
      if (y instanceof DataFormatError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotOpenInput) {
        return LT.value;
      }
      ;
      if (y instanceof CannotOpenInput) {
        return GT.value;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof AddresseeUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof AddresseeUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof HostNameUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof HostNameUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return EQ.value;
      }
      ;
      if (x instanceof ServiceUnavailable) {
        return LT.value;
      }
      ;
      if (y instanceof ServiceUnavailable) {
        return GT.value;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return EQ.value;
      }
      ;
      if (x instanceof InternalSoftwareError) {
        return LT.value;
      }
      ;
      if (y instanceof InternalSoftwareError) {
        return GT.value;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return EQ.value;
      }
      ;
      if (x instanceof SystemError) {
        return LT.value;
      }
      ;
      if (y instanceof SystemError) {
        return GT.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return EQ.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing) {
        return LT.value;
      }
      ;
      if (y instanceof CriticalOSFileMissing) {
        return GT.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile) {
        return LT.value;
      }
      ;
      if (y instanceof CannotCreateOutputFile) {
        return GT.value;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return EQ.value;
      }
      ;
      if (x instanceof IOError) {
        return LT.value;
      }
      ;
      if (y instanceof IOError) {
        return GT.value;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return EQ.value;
      }
      ;
      if (x instanceof TemporaryFailure) {
        return LT.value;
      }
      ;
      if (y instanceof TemporaryFailure) {
        return GT.value;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return EQ.value;
      }
      ;
      if (x instanceof RemoteError) {
        return LT.value;
      }
      ;
      if (y instanceof RemoteError) {
        return GT.value;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return EQ.value;
      }
      ;
      if (x instanceof PermissionDenied) {
        return LT.value;
      }
      ;
      if (y instanceof PermissionDenied) {
        return GT.value;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return EQ.value;
      }
      ;
      if (x instanceof ConfigurationError) {
        return LT.value;
      }
      ;
      if (y instanceof ConfigurationError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotExecute) {
        return LT.value;
      }
      ;
      if (y instanceof CannotExecute) {
        return GT.value;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return EQ.value;
      }
      ;
      if (x instanceof CommandNotFound) {
        return LT.value;
      }
      ;
      if (y instanceof CommandNotFound) {
        return GT.value;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return EQ.value;
      }
      ;
      if (x instanceof InvalidExitArgument) {
        return LT.value;
      }
      ;
      if (y instanceof InvalidExitArgument) {
        return GT.value;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGHUP) {
        return LT.value;
      }
      ;
      if (y instanceof SIGHUP) {
        return GT.value;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGINT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGINT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGQUIT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGQUIT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGABRT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGABRT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGFPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGFPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGKILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGKILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGSEGV) {
        return LT.value;
      }
      ;
      if (y instanceof SIGSEGV) {
        return GT.value;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGPIPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGPIPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGALRM) {
        return LT.value;
      }
      ;
      if (y instanceof SIGALRM) {
        return GT.value;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at ExitCodes (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqExitCode;
  }
};
var enumExitCode = {
  succ: function(v) {
    if (v instanceof Success) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof $$Error) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGTERM.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  pred: function(v) {
    if (v instanceof Success) {
      return Nothing.value;
    }
    ;
    if (v instanceof $$Error) {
      return new Just(Success.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return new Just(SIGALRM.value);
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  Ord0: function() {
    return ordExitCode;
  }
};
var boundedExitCode = /* @__PURE__ */ function() {
  return {
    bottom: Success.value,
    top: SIGTERM.value,
    Ord0: function() {
      return ordExitCode;
    }
  };
}();
var boundedEnumExitCode = {
  cardinality: 32,
  toEnum: function(v) {
    if (v === 0) {
      return new Just(Success.value);
    }
    ;
    if (v === 1) {
      return new Just($$Error.value);
    }
    ;
    if (v === 2) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v === 64) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v === 65) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v === 66) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v === 67) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v === 68) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v === 69) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v === 70) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v === 71) {
      return new Just(SystemError.value);
    }
    ;
    if (v === 72) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v === 73) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v === 74) {
      return new Just(IOError.value);
    }
    ;
    if (v === 75) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v === 76) {
      return new Just(RemoteError.value);
    }
    ;
    if (v === 77) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v === 78) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v === 126) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v === 127) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v === 128) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v === 129) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v === 130) {
      return new Just(SIGINT.value);
    }
    ;
    if (v === 131) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v === 132) {
      return new Just(SIGILL.value);
    }
    ;
    if (v === 134) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v === 136) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v === 137) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v === 139) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v === 141) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v === 142) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v === 143) {
      return new Just(SIGTERM.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Success) {
      return 0;
    }
    ;
    if (v instanceof $$Error) {
      return 1;
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return 2;
    }
    ;
    if (v instanceof CLIUsageError) {
      return 64;
    }
    ;
    if (v instanceof DataFormatError) {
      return 65;
    }
    ;
    if (v instanceof CannotOpenInput) {
      return 66;
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return 67;
    }
    ;
    if (v instanceof HostNameUnknown) {
      return 68;
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return 69;
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return 70;
    }
    ;
    if (v instanceof SystemError) {
      return 71;
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return 72;
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return 73;
    }
    ;
    if (v instanceof IOError) {
      return 74;
    }
    ;
    if (v instanceof TemporaryFailure) {
      return 75;
    }
    ;
    if (v instanceof RemoteError) {
      return 76;
    }
    ;
    if (v instanceof PermissionDenied) {
      return 77;
    }
    ;
    if (v instanceof ConfigurationError) {
      return 78;
    }
    ;
    if (v instanceof CannotExecute) {
      return 126;
    }
    ;
    if (v instanceof CommandNotFound) {
      return 127;
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return 128;
    }
    ;
    if (v instanceof SIGHUP) {
      return 128 + 1 | 0;
    }
    ;
    if (v instanceof SIGINT) {
      return 128 + 2 | 0;
    }
    ;
    if (v instanceof SIGQUIT) {
      return 128 + 3 | 0;
    }
    ;
    if (v instanceof SIGILL) {
      return 128 + 4 | 0;
    }
    ;
    if (v instanceof SIGABRT) {
      return 128 + 6 | 0;
    }
    ;
    if (v instanceof SIGFPE) {
      return 128 + 8 | 0;
    }
    ;
    if (v instanceof SIGKILL) {
      return 128 + 9 | 0;
    }
    ;
    if (v instanceof SIGSEGV) {
      return 128 + 11 | 0;
    }
    ;
    if (v instanceof SIGPIPE) {
      return 128 + 13 | 0;
    }
    ;
    if (v instanceof SIGALRM) {
      return 128 + 14 | 0;
    }
    ;
    if (v instanceof SIGTERM) {
      return 128 + 15 | 0;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 153, column 1 - line 219, column 30): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedExitCode;
  },
  Enum1: function() {
    return enumExitCode;
  }
};

// output/Options.Applicative.Internal.Utils/index.js
var eq5 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var whitespaceRegex = /* @__PURE__ */ function() {
  var v = regex("\\s+")(noFlags);
  if (v instanceof Left) {
    return unsafeCrashWith("whitespaceRegex: `\\s+` seems to be invlaid, err: " + v.value0);
  }
  ;
  if (v instanceof Right) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Internal.Utils (line 39, column 19 - line 41, column 15): " + [v.constructor.name]);
}();
var words = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split2(whitespaceRegex)(v);
};
var unWords = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)(" ");
};
var unLines = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)("\n");
};
var startsWith = function(p) {
  return function(s) {
    return eq5(indexOf2(p)(s))(new Just(0));
  };
};
var lines = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split("\n")(v);
};

// output/Data.Exists/index.js
var runExists = unsafeCoerce2;
var mkExists = unsafeCoerce2;

// output/Text.PrettyPrint.Leijen/index.js
var max3 = /* @__PURE__ */ max(ordInt);
var min3 = /* @__PURE__ */ min(ordInt);
var foldr5 = /* @__PURE__ */ foldr(foldableArray);
var SFail = /* @__PURE__ */ function() {
  function SFail2() {
  }
  ;
  SFail2.value = new SFail2();
  return SFail2;
}();
var SEmpty = /* @__PURE__ */ function() {
  function SEmpty2() {
  }
  ;
  SEmpty2.value = new SEmpty2();
  return SEmpty2;
}();
var SChar = /* @__PURE__ */ function() {
  function SChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar2.create = function(value0) {
    return function(value12) {
      return new SChar2(value0, value12);
    };
  };
  return SChar2;
}();
var SText = /* @__PURE__ */ function() {
  function SText2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText2(value0, value12, value22);
      };
    };
  };
  return SText2;
}();
var SLine = /* @__PURE__ */ function() {
  function SLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine2.create = function(value0) {
    return function(value12) {
      return new SLine2(value0, value12);
    };
  };
  return SLine2;
}();
var SFail$prime = /* @__PURE__ */ function() {
  function SFail$prime2() {
  }
  ;
  SFail$prime2.value = new SFail$prime2();
  return SFail$prime2;
}();
var SEmpty$prime = /* @__PURE__ */ function() {
  function SEmpty$prime2() {
  }
  ;
  SEmpty$prime2.value = new SEmpty$prime2();
  return SEmpty$prime2;
}();
var SChar$prime = /* @__PURE__ */ function() {
  function SChar$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar$prime2.create = function(value0) {
    return function(value12) {
      return new SChar$prime2(value0, value12);
    };
  };
  return SChar$prime2;
}();
var SText$prime = /* @__PURE__ */ function() {
  function SText$prime2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText$prime2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText$prime2(value0, value12, value22);
      };
    };
  };
  return SText$prime2;
}();
var SLine$prime = /* @__PURE__ */ function() {
  function SLine$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine$prime2.create = function(value0) {
    return function(value12) {
      return new SLine$prime2(value0, value12);
    };
  };
  return SLine$prime2;
}();
var Fail = /* @__PURE__ */ function() {
  function Fail2() {
  }
  ;
  Fail2.value = new Fail2();
  return Fail2;
}();
var Empty = /* @__PURE__ */ function() {
  function Empty2() {
  }
  ;
  Empty2.value = new Empty2();
  return Empty2;
}();
var Char = /* @__PURE__ */ function() {
  function Char2(value0) {
    this.value0 = value0;
  }
  ;
  Char2.create = function(value0) {
    return new Char2(value0);
  };
  return Char2;
}();
var Text = /* @__PURE__ */ function() {
  function Text2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text2.create = function(value0) {
    return function(value12) {
      return new Text2(value0, value12);
    };
  };
  return Text2;
}();
var Line2 = /* @__PURE__ */ function() {
  function Line3() {
  }
  ;
  Line3.value = new Line3();
  return Line3;
}();
var FlatAlt = /* @__PURE__ */ function() {
  function FlatAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlatAlt2.create = function(value0) {
    return function(value12) {
      return new FlatAlt2(value0, value12);
    };
  };
  return FlatAlt2;
}();
var Cat = /* @__PURE__ */ function() {
  function Cat2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cat2.create = function(value0) {
    return function(value12) {
      return new Cat2(value0, value12);
    };
  };
  return Cat2;
}();
var Nest = /* @__PURE__ */ function() {
  function Nest2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Nest2.create = function(value0) {
    return function(value12) {
      return new Nest2(value0, value12);
    };
  };
  return Nest2;
}();
var Union = /* @__PURE__ */ function() {
  function Union2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Union2.create = function(value0) {
    return function(value12) {
      return new Union2(value0, value12);
    };
  };
  return Union2;
}();
var Column = /* @__PURE__ */ function() {
  function Column2(value0) {
    this.value0 = value0;
  }
  ;
  Column2.create = function(value0) {
    return new Column2(value0);
  };
  return Column2;
}();
var Columns = /* @__PURE__ */ function() {
  function Columns2(value0) {
    this.value0 = value0;
  }
  ;
  Columns2.create = function(value0) {
    return new Columns2(value0);
  };
  return Columns2;
}();
var Nesting = /* @__PURE__ */ function() {
  function Nesting2(value0) {
    this.value0 = value0;
  }
  ;
  Nesting2.create = function(value0) {
    return new Nesting2(value0);
  };
  return Nesting2;
}();
var Nil3 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons3 = /* @__PURE__ */ function() {
  function Cons4(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Cons4(value0, value12, value22);
      };
    };
  };
  return Cons4;
}();
var text = function(v) {
  if (v === "") {
    return Empty.value;
  }
  ;
  return new Text(length5(v), v);
};
var spaces = function(n) {
  if (n <= 0) {
    return "";
  }
  ;
  if (otherwise) {
    return fromCharArray(replicate(n)(" "));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 908, column 1 - line 908, column 24): " + [n.constructor.name]);
};
var space = /* @__PURE__ */ function() {
  return new Char(" ");
}();
var rparen = /* @__PURE__ */ function() {
  return new Char(")");
}();
var rbracket = /* @__PURE__ */ function() {
  return new Char("]");
}();
var nesting = function(f) {
  return new Nesting(f);
};
var nest = function(i) {
  return function(x) {
    return new Nest(i, x);
  };
};
var lparen = /* @__PURE__ */ function() {
  return new Char("(");
}();
var line = /* @__PURE__ */ function() {
  return new FlatAlt(Line2.value, space);
}();
var lbracket = /* @__PURE__ */ function() {
  return new Char("[");
}();
var indentation = function(n) {
  return spaces(n);
};
var forceSimpleDoc = function(v) {
  if (v instanceof SFail$prime) {
    return SFail.value;
  }
  ;
  if (v instanceof SEmpty$prime) {
    return SEmpty.value;
  }
  ;
  if (v instanceof SChar$prime) {
    return new SChar(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  if (v instanceof SText$prime) {
    return new SText(v.value0, v.value1, forceSimpleDoc(force(v.value2)));
  }
  ;
  if (v instanceof SLine$prime) {
    return new SLine(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 600, column 18 - line 605, column 51): " + [v.constructor.name]);
};
var renderFits = function(fits) {
  return function(rfrac) {
    return function(w) {
      return function(headNode) {
        var r = max3(0)(min3(w)(round2(toNumber(w) * rfrac)));
        var nicest$prime = function(n) {
          return function(k) {
            return function(i) {
              return function(ds) {
                return function(x) {
                  return function(y) {
                    var x$prime = best(n)(k)(new Cons3(i, x, ds));
                    var width$prime = min3(w - k | 0)((r - k | 0) + n | 0);
                    var $221 = fits(w)(min3(n)(k))(width$prime)(x$prime);
                    if ($221) {
                      return x$prime;
                    }
                    ;
                    var y$prime = best(n)(k)(new Cons3(i, y, ds));
                    return y$prime;
                  };
                };
              };
            };
          };
        };
        var best = function(v) {
          return function(v1) {
            return function(v2) {
              if (v2 instanceof Nil3) {
                return SEmpty$prime.value;
              }
              ;
              if (v2 instanceof Cons3) {
                if (v2.value1 instanceof Fail) {
                  return SFail$prime.value;
                }
                ;
                if (v2.value1 instanceof Empty) {
                  return best(v)(v1)(v2.value2);
                }
                ;
                if (v2.value1 instanceof Char) {
                  var k$prime = v1 + 1 | 0;
                  return new SChar$prime(v2.value1.value0, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Text) {
                  var k$prime = v1 + v2.value1.value0 | 0;
                  return new SText$prime(v2.value1.value0, v2.value1.value1, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Line2) {
                  return new SLine$prime(v2.value0, defer2(function(v3) {
                    return best(v2.value0)(v2.value0)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof FlatAlt) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, v2.value2));
                }
                ;
                if (v2.value1 instanceof Cat) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, new Cons3(v2.value0, v2.value1.value1, v2.value2)));
                }
                ;
                if (v2.value1 instanceof Nest) {
                  var i$prime = v2.value0 + v2.value1.value0 | 0;
                  return best(v)(v1)(new Cons3(i$prime, v2.value1.value1, v2.value2));
                }
                ;
                if (v2.value1 instanceof Union) {
                  return nicest$prime(v)(v1)(v2.value0)(v2.value2)(v2.value1.value0)(v2.value1.value1);
                }
                ;
                if (v2.value1 instanceof Column) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v1), v2.value2));
                }
                ;
                if (v2.value1 instanceof Columns) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(new Just(w)), v2.value2));
                }
                ;
                if (v2.value1 instanceof Nesting) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v2.value0), v2.value2));
                }
                ;
                throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 788, column 11 - line 802, column 56): " + [v2.value1.constructor.name]);
              }
              ;
              throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 785, column 7 - line 785, column 50): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            };
          };
        };
        return forceSimpleDoc(best(0)(0)(new Cons3(0, headNode, Nil3.value)));
      };
    };
  };
};
var foldr12 = function(dictMonoid) {
  var mempty9 = mempty(dictMonoid);
  return function(f) {
    return function($297) {
      return function(v) {
        if (v instanceof Nothing) {
          return mempty9;
        }
        ;
        if (v instanceof Just) {
          return foldr5(f)(v.value0.last)(v.value0.init);
        }
        ;
        throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 122, column 29 - line 124, column 43): " + [v.constructor.name]);
      }(unsnoc($297));
    };
  };
};
var flatten = function(v) {
  if (v instanceof FlatAlt) {
    return v.value1;
  }
  ;
  if (v instanceof Cat) {
    return new Cat(flatten(v.value0), flatten(v.value1));
  }
  ;
  if (v instanceof Nest) {
    return new Nest(v.value0, flatten(v.value1));
  }
  ;
  if (v instanceof Line2) {
    return Fail.value;
  }
  ;
  if (v instanceof Union) {
    return flatten(v.value0);
  }
  ;
  if (v instanceof Column) {
    return new Column(function($298) {
      return flatten(v.value0($298));
    });
  }
  ;
  if (v instanceof Columns) {
    return new Columns(function($299) {
      return flatten(v.value0($299));
    });
  }
  ;
  if (v instanceof Nesting) {
    return new Nesting(function($300) {
      return flatten(v.value0($300));
    });
  }
  ;
  return v;
};
var group4 = function(x) {
  return new Union(flatten(x), x);
};
var softline = /* @__PURE__ */ group4(line);
var fits1 = function($copy_v) {
  return function($copy_v1) {
    return function($copy_v2) {
      return function($copy_v3) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_var_v2 = $copy_v2;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1, v2, v3) {
          if (v2 < 0) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SFail$prime) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SEmpty$prime) {
            $tco_done = true;
            return true;
          }
          ;
          if (v3 instanceof SChar$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - 1 | 0;
            $copy_v3 = force(v3.value1);
            return;
          }
          ;
          if (v3 instanceof SText$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - v3.value0 | 0;
            $copy_v3 = force(v3.value2);
            return;
          }
          ;
          if (v3 instanceof SLine$prime) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 819, column 1 - line 819, column 55): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $tco_var_v2, $copy_v3);
        }
        ;
        return $tco_result;
      };
    };
  };
};
var renderPretty = /* @__PURE__ */ renderFits(fits1);
var empty9 = /* @__PURE__ */ function() {
  return Empty.value;
}();
var linebreak = /* @__PURE__ */ function() {
  return new FlatAlt(Line2.value, empty9);
}();
var displayS = function(v) {
  if (v instanceof SFail) {
    return unsafeCrashWith("@SFail@ can not appear uncaught in a rendered @SimpleDoc@");
  }
  ;
  if (v instanceof SEmpty) {
    return "";
  }
  ;
  if (v instanceof SChar) {
    return fromCharArray([v.value0]) + displayS(v.value1);
  }
  ;
  if (v instanceof SText) {
    return v.value1 + displayS(v.value2);
  }
  ;
  if (v instanceof SLine) {
    return "\n" + (indentation(v.value0) + displayS(v.value1));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 893, column 1 - line 893, column 32): " + [v.constructor.name]);
};
var column = function(f) {
  return new Column(f);
};
var $$char4 = function(v) {
  if (v === "\n") {
    return line;
  }
  ;
  return new Char(v);
};
var beside = function(x) {
  return function(y) {
    return new Cat(x, y);
  };
};
var docSemigroup = {
  append: beside
};
var append13 = /* @__PURE__ */ append(docSemigroup);
var docMonoid = {
  mempty: empty9,
  Semigroup0: function() {
    return docSemigroup;
  }
};
var foldr11 = /* @__PURE__ */ foldr12(docMonoid);
var string4 = /* @__PURE__ */ function() {
  var $303 = intercalate(foldableArray)(docMonoid)(line);
  var $304 = map(functorArray)(text);
  var $305 = split("\n");
  return function($306) {
    return $303($304($305($306)));
  };
}();
var enclose = function(l) {
  return function(r) {
    return function(x) {
      return append13(l)(append13(x)(r));
    };
  };
};
var brackets = /* @__PURE__ */ enclose(lbracket)(rbracket);
var parens2 = /* @__PURE__ */ enclose(lparen)(rparen);
var width = function(d) {
  return function(f) {
    return column(function(k1) {
      return append13(d)(column(function(k2) {
        return f(k2 - k1 | 0);
      }));
    });
  };
};
var fillBreak = function(f) {
  return function(x) {
    return width(x)(function(w) {
      var $292 = w > f;
      if ($292) {
        return nest(f)(linebreak);
      }
      ;
      return text(spaces(f - w | 0));
    });
  };
};
var appendWithSpace = function(x) {
  return function(y) {
    return append13(x)(append13(space)(y));
  };
};
var hsep = /* @__PURE__ */ foldr11(appendWithSpace);
var appendWithSoftline = function(x) {
  return function(y) {
    return append13(x)(append13(softline)(y));
  };
};
var appendWithLinebreak = function(x) {
  return function(y) {
    return append13(x)(append13(linebreak)(y));
  };
};
var vcat = /* @__PURE__ */ foldr11(appendWithLinebreak);
var appendWithLine = function(x) {
  return function(y) {
    return append13(x)(append13(line)(y));
  };
};
var align = function(d) {
  return column(function(k) {
    return nesting(function(i) {
      return nest(k - i | 0)(d);
    });
  });
};
var hang = function(i) {
  return function(d) {
    return align(nest(i)(d));
  };
};
var indent = function(i) {
  return function(d) {
    return hang(i)(append13(text(spaces(i)))(d));
  };
};

// output/Options.Applicative.Help.Chunk/index.js
var un2 = /* @__PURE__ */ un();
var foldr6 = /* @__PURE__ */ foldr(foldableArray);
var mempty3 = /* @__PURE__ */ mempty(docMonoid);
var fold6 = /* @__PURE__ */ fold(foldableArray);
var mapFlipped7 = /* @__PURE__ */ mapFlipped(functorArray);
var Chunk = function(x) {
  return x;
};
var chunked = function(v) {
  return function(v1) {
    return function(v2) {
      if (v1 instanceof Nothing) {
        return v2;
      }
      ;
      if (v2 instanceof Nothing) {
        return v1;
      }
      ;
      if (v1 instanceof Just && v2 instanceof Just) {
        return new Just(v(v1.value0)(v2.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Help.Chunk (line 57, column 1 - line 58, column 41): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var chunkSemigroup = function(dictSemigroup) {
  return {
    append: chunked(append(dictSemigroup))
  };
};
var extractChunk = function(dictMonoid) {
  var $56 = fromMaybe(mempty(dictMonoid));
  var $57 = un2(Chunk);
  return function($58) {
    return $56($57($58));
  };
};
var isEmpty3 = /* @__PURE__ */ function() {
  var $59 = un2(Chunk);
  return function($60) {
    return isNothing($59($60));
  };
}();
var chunkMonoid = function(dictSemigroup) {
  var chunkSemigroup1 = chunkSemigroup(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return chunkSemigroup1;
    }
  };
};
var mempty1 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var vcatChunks = /* @__PURE__ */ foldr6(/* @__PURE__ */ chunked(appendWithLine))(mempty1);
var vsepChunks = /* @__PURE__ */ foldr6(/* @__PURE__ */ chunked(function(x) {
  return function(y) {
    return appendWithLine(x)(appendWithLine(mempty3)(y));
  };
}))(mempty1);
var chunkFunctor = functorMaybe;
var chunkBesideOrBelow = /* @__PURE__ */ chunked(appendWithSoftline);
var chunkBeside = /* @__PURE__ */ chunked(appendWithSpace);
var chunkApply = applyMaybe;
var chunkApplicative = applicativeMaybe;
var pure13 = /* @__PURE__ */ pure(chunkApplicative);
var listToChunk = function(dictMonoid) {
  var mempty24 = mempty(chunkMonoid(dictMonoid.Semigroup0()));
  var fold110 = fold6(dictMonoid);
  return function(v) {
    if (v.length === 0) {
      return mempty24;
    }
    ;
    return pure13(fold110(v));
  };
};
var stringChunk = function(v) {
  if (v === "") {
    return mempty1;
  }
  ;
  return pure13(text(v));
};
var paragraph = /* @__PURE__ */ function() {
  var $61 = foldr6(function() {
    var $63 = chunked(appendWithSoftline);
    return function($64) {
      return $63(stringChunk($64));
    };
  }())(mempty1);
  return function($62) {
    return $61(words($62));
  };
}();
var tabulate$prime = function(v) {
  return function(v1) {
    if (v1.length === 0) {
      return mempty1;
    }
    ;
    return pure13(vcat(mapFlipped7(v1)(function(v2) {
      return indent(2)(appendWithSpace(fillBreak(v)(v2.value0))(v2.value1));
    })));
  };
};
var tabulate = /* @__PURE__ */ tabulate$prime(24);

// output/Options.Applicative.Help.Types/index.js
var helpBodyIsSymbol = {
  reflectSymbol: function() {
    return "helpBody";
  }
};
var helpErrorIsSymbol = {
  reflectSymbol: function() {
    return "helpError";
  }
};
var helpFooterIsSymbol = {
  reflectSymbol: function() {
    return "helpFooter";
  }
};
var helpHeaderIsSymbol = {
  reflectSymbol: function() {
    return "helpHeader";
  }
};
var helpSuggestionsIsSymbol = {
  reflectSymbol: function() {
    return "helpSuggestions";
  }
};
var helpUsageIsSymbol = {
  reflectSymbol: function() {
    return "helpUsage";
  }
};
var chunkMonoid2 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var extractChunk2 = /* @__PURE__ */ extractChunk(docMonoid);
var ParserHelp = function(x) {
  return x;
};
var parserHelpMonoid = /* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(helpBodyIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpErrorIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpFooterIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpHeaderIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpSuggestionsIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpUsageIsSymbol)(chunkMonoid2)()(monoidRecordNil)))))));
var helpText = function(v) {
  return extractChunk2(vsepChunks([v.helpError, v.helpSuggestions, v.helpHeader, v.helpUsage, v.helpBody, v.helpFooter]));
};
var renderHelp = function(cols) {
  var $65 = renderPretty(1)(cols);
  return function($66) {
    return displayS($65(helpText($66)));
  };
};

// output/Options.Applicative.Types/index.js
var monadExceptT3 = /* @__PURE__ */ monadExceptT(monadIdentity);
var map28 = /* @__PURE__ */ map(/* @__PURE__ */ functorReaderT(/* @__PURE__ */ functorExceptT(functorIdentity)));
var apply6 = /* @__PURE__ */ apply(/* @__PURE__ */ applyReaderT(/* @__PURE__ */ applyExceptT(monadIdentity)));
var bind13 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(/* @__PURE__ */ bindExceptT(monadIdentity)));
var un3 = /* @__PURE__ */ un();
var map111 = /* @__PURE__ */ map(functorMaybe);
var compare4 = /* @__PURE__ */ compare(ordChar);
var compare12 = /* @__PURE__ */ compare(ordString);
var apply1 = /* @__PURE__ */ apply(applyEffect);
var map29 = /* @__PURE__ */ map(functorEffect);
var append14 = /* @__PURE__ */ append(semigroupArray);
var pure14 = /* @__PURE__ */ pure(applicativeEffect);
var over3 = /* @__PURE__ */ over()();
var map33 = /* @__PURE__ */ map(freeFunctor);
var bimap2 = /* @__PURE__ */ bimap(bifunctorStep);
var ParserFailure = function(x) {
  return x;
};
var Internal = /* @__PURE__ */ function() {
  function Internal2() {
  }
  ;
  Internal2.value = new Internal2();
  return Internal2;
}();
var Hidden = /* @__PURE__ */ function() {
  function Hidden2() {
  }
  ;
  Hidden2.value = new Hidden2();
  return Hidden2;
}();
var Visible = /* @__PURE__ */ function() {
  function Visible2() {
  }
  ;
  Visible2.value = new Visible2();
  return Visible2;
}();
var Leaf2 = /* @__PURE__ */ function() {
  function Leaf3(value0) {
    this.value0 = value0;
  }
  ;
  Leaf3.create = function(value0) {
    return new Leaf3(value0);
  };
  return Leaf3;
}();
var MultNode = /* @__PURE__ */ function() {
  function MultNode2(value0) {
    this.value0 = value0;
  }
  ;
  MultNode2.create = function(value0) {
    return new MultNode2(value0);
  };
  return MultNode2;
}();
var AltNode = /* @__PURE__ */ function() {
  function AltNode2(value0) {
    this.value0 = value0;
  }
  ;
  AltNode2.create = function(value0) {
    return new AltNode2(value0);
  };
  return AltNode2;
}();
var OptProperties = function(x) {
  return x;
};
var OptShort = /* @__PURE__ */ function() {
  function OptShort2(value0) {
    this.value0 = value0;
  }
  ;
  OptShort2.create = function(value0) {
    return new OptShort2(value0);
  };
  return OptShort2;
}();
var OptLong = /* @__PURE__ */ function() {
  function OptLong2(value0) {
    this.value0 = value0;
  }
  ;
  OptLong2.create = function(value0) {
    return new OptLong2(value0);
  };
  return OptLong2;
}();
var OptHelpInfo = function(x) {
  return x;
};
var CmdStart = /* @__PURE__ */ function() {
  function CmdStart2() {
  }
  ;
  CmdStart2.value = new CmdStart2();
  return CmdStart2;
}();
var CmdCont = /* @__PURE__ */ function() {
  function CmdCont2() {
  }
  ;
  CmdCont2.value = new CmdCont2();
  return CmdCont2;
}();
var CompletionResult = function(x) {
  return x;
};
var Success2 = /* @__PURE__ */ function() {
  function Success3(value0) {
    this.value0 = value0;
  }
  ;
  Success3.create = function(value0) {
    return new Success3(value0);
  };
  return Success3;
}();
var Failure = /* @__PURE__ */ function() {
  function Failure2(value0) {
    this.value0 = value0;
  }
  ;
  Failure2.create = function(value0) {
    return new Failure2(value0);
  };
  return Failure2;
}();
var CompletionInvoked = /* @__PURE__ */ function() {
  function CompletionInvoked2(value0) {
    this.value0 = value0;
  }
  ;
  CompletionInvoked2.create = function(value0) {
    return new CompletionInvoked2(value0);
  };
  return CompletionInvoked2;
}();
var Completer = function(x) {
  return x;
};
var Backtrack = /* @__PURE__ */ function() {
  function Backtrack2() {
  }
  ;
  Backtrack2.value = new Backtrack2();
  return Backtrack2;
}();
var NoBacktrack = /* @__PURE__ */ function() {
  function NoBacktrack2() {
  }
  ;
  NoBacktrack2.value = new NoBacktrack2();
  return NoBacktrack2;
}();
var SubparserInline = /* @__PURE__ */ function() {
  function SubparserInline2() {
  }
  ;
  SubparserInline2.value = new SubparserInline2();
  return SubparserInline2;
}();
var ParserPrefs = function(x) {
  return x;
};
var Intersperse = /* @__PURE__ */ function() {
  function Intersperse2() {
  }
  ;
  Intersperse2.value = new Intersperse2();
  return Intersperse2;
}();
var NoIntersperse = /* @__PURE__ */ function() {
  function NoIntersperse2() {
  }
  ;
  NoIntersperse2.value = new NoIntersperse2();
  return NoIntersperse2;
}();
var AllPositionals = /* @__PURE__ */ function() {
  function AllPositionals2() {
  }
  ;
  AllPositionals2.value = new AllPositionals2();
  return AllPositionals2;
}();
var ForwardOptions = /* @__PURE__ */ function() {
  function ForwardOptions2() {
  }
  ;
  ForwardOptions2.value = new ForwardOptions2();
  return ForwardOptions2;
}();
var ParserInfo = function(x) {
  return x;
};
var NilP = /* @__PURE__ */ function() {
  function NilP2(value0) {
    this.value0 = value0;
  }
  ;
  NilP2.create = function(value0) {
    return new NilP2(value0);
  };
  return NilP2;
}();
var OptP = /* @__PURE__ */ function() {
  function OptP2(value0) {
    this.value0 = value0;
  }
  ;
  OptP2.create = function(value0) {
    return new OptP2(value0);
  };
  return OptP2;
}();
var MultP = /* @__PURE__ */ function() {
  function MultP2(value0) {
    this.value0 = value0;
  }
  ;
  MultP2.create = function(value0) {
    return new MultP2(value0);
  };
  return MultP2;
}();
var AltP = /* @__PURE__ */ function() {
  function AltP2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AltP2.create = function(value0) {
    return function(value12) {
      return new AltP2(value0, value12);
    };
  };
  return AltP2;
}();
var BindP = /* @__PURE__ */ function() {
  function BindP2(value0) {
    this.value0 = value0;
  }
  ;
  BindP2.create = function(value0) {
    return new BindP2(value0);
  };
  return BindP2;
}();
var Option = function(x) {
  return x;
};
var OptReader = /* @__PURE__ */ function() {
  function OptReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  OptReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new OptReader2(value0, value12, value22);
      };
    };
  };
  return OptReader2;
}();
var FlagReader = /* @__PURE__ */ function() {
  function FlagReader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlagReader2.create = function(value0) {
    return function(value12) {
      return new FlagReader2(value0, value12);
    };
  };
  return FlagReader2;
}();
var ArgReader = /* @__PURE__ */ function() {
  function ArgReader2(value0) {
    this.value0 = value0;
  }
  ;
  ArgReader2.create = function(value0) {
    return new ArgReader2(value0);
  };
  return ArgReader2;
}();
var CmdReader = /* @__PURE__ */ function() {
  function CmdReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  CmdReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new CmdReader2(value0, value12, value22);
      };
    };
  };
  return CmdReader2;
}();
var CReader = function(x) {
  return x;
};
var ReadM = function(x) {
  return x;
};
var ErrorMsg = /* @__PURE__ */ function() {
  function ErrorMsg2(value0) {
    this.value0 = value0;
  }
  ;
  ErrorMsg2.create = function(value0) {
    return new ErrorMsg2(value0);
  };
  return ErrorMsg2;
}();
var InfoMsg = /* @__PURE__ */ function() {
  function InfoMsg2(value0) {
    this.value0 = value0;
  }
  ;
  InfoMsg2.create = function(value0) {
    return new InfoMsg2(value0);
  };
  return InfoMsg2;
}();
var ShowHelpText = /* @__PURE__ */ function() {
  function ShowHelpText2() {
  }
  ;
  ShowHelpText2.value = new ShowHelpText2();
  return ShowHelpText2;
}();
var MissingError = /* @__PURE__ */ function() {
  function MissingError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MissingError2.create = function(value0) {
    return function(value12) {
      return new MissingError2(value0, value12);
    };
  };
  return MissingError2;
}();
var ExpectsArgError = /* @__PURE__ */ function() {
  function ExpectsArgError2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectsArgError2.create = function(value0) {
    return new ExpectsArgError2(value0);
  };
  return ExpectsArgError2;
}();
var UnexpectedError = /* @__PURE__ */ function() {
  function UnexpectedError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  UnexpectedError2.create = function(value0) {
    return function(value12) {
      return new UnexpectedError2(value0, value12);
    };
  };
  return UnexpectedError2;
}();
var SomeParser = /* @__PURE__ */ function() {
  function SomeParser2(value0) {
    this.value0 = value0;
  }
  ;
  SomeParser2.create = function(value0) {
    return new SomeParser2(value0);
  };
  return SomeParser2;
}();
var MultPE = /* @__PURE__ */ function() {
  function MultPE2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MultPE2.create = function(value0) {
    return function(value12) {
      return new MultPE2(value0, value12);
    };
  };
  return MultPE2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Context2.create = function(value0) {
    return function(value12) {
      return new Context2(value0, value12);
    };
  };
  return Context2;
}();
var ParserM = function(x) {
  return x;
};
var readerAsk = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadExceptT3));
var readerAbort = /* @__PURE__ */ function() {
  var $478 = lift(monadTransReaderT)(monadExceptT3);
  var $479 = throwError(monadThrowExceptT(monadIdentity));
  return function($480) {
    return ReadM($478($479($480)));
  };
}();
var readerError = function($481) {
  return readerAbort(ErrorMsg.create($481));
};
var readMFunctor = {
  map: function(f) {
    return function(v) {
      return map28(f)(v);
    };
  }
};
var map42 = /* @__PURE__ */ map(readMFunctor);
var readMApply = {
  apply: function(v) {
    return function(v1) {
      return apply6(v)(v1);
    };
  },
  Functor0: function() {
    return readMFunctor;
  }
};
var readMBind = {
  bind: function(v) {
    return function(f) {
      return bind13(v)(function() {
        var $482 = un3(ReadM);
        return function($483) {
          return $482(f($483));
        };
      }());
    };
  },
  Apply0: function() {
    return readMApply;
  }
};
var readMApplicative = {
  pure: /* @__PURE__ */ function() {
    var $484 = pure(applicativeReaderT(applicativeExceptT(monadIdentity)));
    return function($485) {
      return ReadM($484($485));
    };
  }(),
  Apply0: function() {
    return readMApply;
  }
};
var parserMMonadRec = freeMonadRec;
var tailRecM3 = /* @__PURE__ */ tailRecM(parserMMonadRec);
var parserMBind = freeBind;
var bind14 = /* @__PURE__ */ bind(parserMBind);
var parserMApplicative = freeApplicative;
var pure15 = /* @__PURE__ */ pure(parserMApplicative);
var parseErrorSemigroup = {
  append: function(v) {
    return function(m) {
      return m;
    };
  }
};
var optional3 = function(dictAlt) {
  var alt22 = alt(dictAlt);
  var map102 = map(dictAlt.Functor0());
  return function(dictApplicative) {
    var pure34 = pure(dictApplicative);
    return function(a) {
      return alt22(map102(Just.create)(a))(pure34(Nothing.value));
    };
  };
};
var optVisibilityEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return true;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return true;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return true;
      }
      ;
      return false;
    };
  }
};
var optVisibilityOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return EQ.value;
      }
      ;
      if (x instanceof Internal) {
        return LT.value;
      }
      ;
      if (y instanceof Internal) {
        return GT.value;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return EQ.value;
      }
      ;
      if (x instanceof Hidden) {
        return LT.value;
      }
      ;
      if (y instanceof Hidden) {
        return GT.value;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optVisibilityEq;
  }
};
var optShowDefault = /* @__PURE__ */ function() {
  var $486 = un3(OptProperties);
  var $487 = un3(Option);
  return function($488) {
    return function(v) {
      return v.propShowDefault;
    }($486(function(v) {
      return v.optProps;
    }($487($488))));
  };
}();
var optVisibility = /* @__PURE__ */ function() {
  var $489 = un3(OptProperties);
  var $490 = un3(Option);
  return function($491) {
    return function(v) {
      return v.propVisibility;
    }($489(function(v) {
      return v.optProps;
    }($490($491))));
  };
}();
var optNameEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var optNameOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return compare4(x.value0)(y.value0);
      }
      ;
      if (x instanceof OptShort) {
        return LT.value;
      }
      ;
      if (y instanceof OptShort) {
        return GT.value;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return compare12(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optNameEq;
  }
};
var optMetaVar = /* @__PURE__ */ function() {
  var $492 = un3(OptProperties);
  var $493 = un3(Option);
  return function($494) {
    return function(v) {
      return v.propMetaVar;
    }($492(function(v) {
      return v.optProps;
    }($493($494))));
  };
}();
var optHelp = /* @__PURE__ */ function() {
  var $495 = un3(OptProperties);
  var $496 = un3(Option);
  return function($497) {
    return function(v) {
      return v.propHelp;
    }($495(function(v) {
      return v.optProps;
    }($496($497))));
  };
}();
var optDescMod = /* @__PURE__ */ function() {
  var $498 = un3(OptProperties);
  var $499 = un3(Option);
  return function($500) {
    return function(v) {
      return v.propDescMod;
    }($498(function(v) {
      return v.optProps;
    }($499($500))));
  };
}();
var oneM = function($501) {
  return ParserM(liftF($501));
};
var fromM = function(v) {
  return new BindP(v);
};
var completerSemigroup = {
  append: function(v) {
    return function(v1) {
      return function(s) {
        return apply1(map29(append14)(v(s)))(v1(s));
      };
    };
  }
};
var completerMonoid = {
  mempty: function(v) {
    return pure14([]);
  },
  Semigroup0: function() {
    return completerSemigroup;
  }
};
var cReaderFunctor = {
  map: function(f) {
    return over3(CReader)(function(r) {
      return {
        crCompleter: r.crCompleter,
        crReader: map42(f)(r.crReader)
      };
    });
  }
};
var map82 = /* @__PURE__ */ map(cReaderFunctor);
var parserInfoFunctor = {
  map: function(f) {
    return over3(ParserInfo)(function(i) {
      return {
        infoFailureCode: i.infoFailureCode,
        infoFooter: i.infoFooter,
        infoFullDesc: i.infoFullDesc,
        infoHeader: i.infoHeader,
        infoPolicy: i.infoPolicy,
        infoProgDesc: i.infoProgDesc,
        infoParser: map(parserFunctor)(f)(i.infoParser)
      };
    });
  }
};
var parserFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return new NilP(v(v1.value0));
      }
      ;
      if (v1 instanceof OptP) {
        return new OptP(map(optionFunctor)(v)(v1.value0));
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          return new MultP(mkExists(new MultPE(map(parserFunctor)(function(v3) {
            return function($502) {
              return v(v3($502));
            };
          })(v2.value0), v2.value1)));
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return new AltP(map(parserFunctor)(v)(v1.value0), map(parserFunctor)(v)(v1.value1));
      }
      ;
      if (v1 instanceof BindP) {
        return new BindP(map33(v)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 317, column 1 - line 322, column 36): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var optionFunctor = {
  map: function(f) {
    return over3(Option)(function(o) {
      return {
        optProps: o.optProps,
        optMain: map(optReaderFunctor)(f)(o.optMain)
      };
    });
  }
};
var optReaderFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof OptReader) {
        return new OptReader(v1.value0, map82(v)(v1.value1), v1.value2);
      }
      ;
      if (v1 instanceof FlagReader) {
        return new FlagReader(v1.value0, v(v1.value1));
      }
      ;
      if (v1 instanceof ArgReader) {
        return new ArgReader(map82(v)(v1.value0));
      }
      ;
      if (v1 instanceof CmdReader) {
        return new CmdReader(v1.value0, v1.value1, function() {
          var $503 = map111(map(parserInfoFunctor)(v));
          return function($504) {
            return $503(v1.value2($504));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 264, column 1 - line 268, column 68): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var map92 = /* @__PURE__ */ map(parserFunctor);
var parserAlt = /* @__PURE__ */ function() {
  return {
    alt: AltP.create,
    Functor0: function() {
      return parserFunctor;
    }
  };
}();
var alt1 = /* @__PURE__ */ alt(parserAlt);
var parserApply = {
  apply: function(a) {
    return function(b) {
      return new MultP(mkExists(new MultPE(a, b)));
    };
  },
  Functor0: function() {
    return parserFunctor;
  }
};
var parserApplicative = /* @__PURE__ */ function() {
  return {
    pure: NilP.create,
    Apply0: function() {
      return parserApply;
    }
  };
}();
var pure24 = /* @__PURE__ */ pure(parserApplicative);
var manyM = function(p) {
  var go = function(acc) {
    return bind14(oneM(alt1(map92(Loop.create)(p))(pure24(new Done(unit)))))(function(aa) {
      return pure15(bimap2(function(v) {
        return new Cons(v, acc);
      })(function(v) {
        return reverse2(acc);
      })(aa));
    });
  };
  return tailRecM3(go)(Nil.value);
};
var many3 = function($505) {
  return fromM(manyM($505));
};
var argPolicyEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Intersperse && y instanceof Intersperse) {
        return true;
      }
      ;
      if (x instanceof NoIntersperse && y instanceof NoIntersperse) {
        return true;
      }
      ;
      if (x instanceof AllPositionals && y instanceof AllPositionals) {
        return true;
      }
      ;
      if (x instanceof ForwardOptions && y instanceof ForwardOptions) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Control.Monad.Reader/index.js
var unwrap8 = /* @__PURE__ */ unwrap();
var runReader = function(v) {
  return function($4) {
    return unwrap8(v($4));
  };
};

// output/Options.Applicative.Internal/index.js
var $runtime_lazy11 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var un4 = /* @__PURE__ */ un();
var map30 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorStateT(/* @__PURE__ */ functorReaderT(functorIdentity))));
var monadReaderT2 = /* @__PURE__ */ monadReaderT(monadIdentity);
var monadStateT2 = /* @__PURE__ */ monadStateT(monadReaderT2);
var apply7 = /* @__PURE__ */ apply(/* @__PURE__ */ applyExceptT(monadStateT2));
var bind15 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadStateT2));
var pure16 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadStateT2));
var altExceptT2 = /* @__PURE__ */ altExceptT(parseErrorSemigroup);
var alt9 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadStateT2));
var lift6 = /* @__PURE__ */ lift(monadTransExceptT);
var lift1 = /* @__PURE__ */ lift6(monadStateT2);
var modify_3 = /* @__PURE__ */ modify_(/* @__PURE__ */ monadStateStateT(monadReaderT2));
var lift22 = /* @__PURE__ */ lift(monadTransStateT);
var throwError4 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadStateT2));
var map112 = /* @__PURE__ */ map(functorArray);
var pure17 = /* @__PURE__ */ pure(applicativeArray);
var discard6 = /* @__PURE__ */ discard(discardUnit);
var identity11 = /* @__PURE__ */ identity(categoryFn);
var TNil = /* @__PURE__ */ function() {
  function TNil2() {
  }
  ;
  TNil2.value = new TNil2();
  return TNil2;
}();
var TCons = /* @__PURE__ */ function() {
  function TCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TCons2.create = function(value0) {
    return function(value12) {
      return new TCons2(value0, value12);
    };
  };
  return TCons2;
}();
var P = function(x) {
  return x;
};
var ListT = function(x) {
  return x;
};
var NondetT = function(x) {
  return x;
};
var ComplParser = /* @__PURE__ */ function() {
  function ComplParser2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ComplParser2.create = function(value0) {
    return function(value12) {
      return new ComplParser2(value0, value12);
    };
  };
  return ComplParser2;
}();
var ComplOption = /* @__PURE__ */ function() {
  function ComplOption2(value0) {
    this.value0 = value0;
  }
  ;
  ComplOption2.create = function(value0) {
    return new ComplOption2(value0);
  };
  return ComplOption2;
}();
var ComplResult = /* @__PURE__ */ function() {
  function ComplResult2(value0) {
    this.value0 = value0;
  }
  ;
  ComplResult2.create = function(value0) {
    return new ComplResult2(value0);
  };
  return ComplResult2;
}();
var Completion = function(x) {
  return x;
};
var withReadM = function(f) {
  var f$prime = function(v) {
    if (v instanceof ErrorMsg) {
      return new ErrorMsg(f(v.value0));
    }
    ;
    return v;
  };
  var $298 = mapReaderT(withExcept(f$prime));
  var $299 = un4(ReadM);
  return function($300) {
    return ReadM($298($299($300)));
  };
};
var stepListT = function(v) {
  return v;
};
var runP2 = function(v) {
  return runReader(flip(runStateT)([])(runExceptT(v)));
};
var runNondetT = function(v) {
  return v;
};
var runListT = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var liftM12 = liftM1(dictMonad);
  return function(xs) {
    return bind210(stepListT(xs))(function(s) {
      if (s instanceof TNil) {
        return pure42(Nil.value);
      }
      ;
      if (s instanceof TCons) {
        return liftM12(Cons.create(s.value0))(runListT(dictMonad)(s.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 200, column 3 - line 202, column 53): " + [s.constructor.name]);
    });
  };
};
var runCompletion = function(v) {
  return function(prefs2) {
    var v1 = runReaderT(runExceptT(v))(prefs2);
    if (v1 instanceof ComplResult) {
      return Nothing.value;
    }
    ;
    if (v1 instanceof ComplParser) {
      return new Just(new Left(new Tuple(v1.value0, v1.value1)));
    }
    ;
    if (v1 instanceof ComplOption) {
      return new Just(new Right(v1.value0));
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Internal (line 170, column 38 - line 173, column 42): " + [v1.constructor.name]);
  };
};
var pFunctor = {
  map: function(f) {
    return function(v) {
      return map30(f)(v);
    };
  }
};
var pApply = {
  apply: function(v) {
    return function(v1) {
      return apply7(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var pBind = {
  bind: function(v) {
    return function(k) {
      return bind15(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return pApply;
  }
};
var pApplicative = {
  pure: function(a) {
    return pure16(a);
  },
  Apply0: function() {
    return pApply;
  }
};
var pMonad = {
  Applicative0: function() {
    return pApplicative;
  },
  Bind1: function() {
    return pBind;
  }
};
var pAlt = {
  alt: function(v) {
    return function(v1) {
      return alt9(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var missingArgP = function(dict) {
  return dict.missingArgP;
};
var getPrefs = function(dict) {
  return dict.getPrefs;
};
var exitP = function(dict) {
  return dict.exitP;
};
var exitContext = function(dict) {
  return dict.exitContext;
};
var errorP = function(dict) {
  return dict.errorP;
};
var hoistEither = function(dictMonadP) {
  return either(errorP(dictMonadP))(pure(dictMonadP.Monad0().Applicative0()));
};
var runReadM = function(dictMonadP) {
  var hoistEither1 = hoistEither(dictMonadP);
  return function(v) {
    return function(s) {
      return hoistEither1(runExcept(runReaderT(v)(s)));
    };
  };
};
var hoistMaybe = function(dictMonadP) {
  var errorP1 = errorP(dictMonadP);
  var pure42 = pure(dictMonadP.Monad0().Applicative0());
  return function(err) {
    return maybe(errorP1(err))(pure42);
  };
};
var pMonadP = {
  enterContext: function(name3) {
    return function(pinfo) {
      return lift1(modify_3(cons(new Context(name3, mkExists(pinfo)))));
    };
  },
  exitContext: /* @__PURE__ */ lift1(/* @__PURE__ */ modify_3(/* @__PURE__ */ drop(1))),
  getPrefs: /* @__PURE__ */ P(/* @__PURE__ */ lift1(/* @__PURE__ */ lift22(monadReaderT2)(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadIdentity))))),
  missingArgP: function(e) {
    return function(v) {
      return errorP(pMonadP)(e);
    };
  },
  exitP: function(i) {
    return function(v) {
      return function(p) {
        var $301 = maybe(throwError4(MissingError.create(i)(SomeParser.create(mkExists(p)))))(pure16);
        return function($302) {
          return P($301($302));
        };
      };
    };
  },
  errorP: function($303) {
    return P(throwError4($303));
  },
  Monad0: function() {
    return pMonad;
  },
  Alt1: function() {
    return pAlt;
  }
};
var enterContext = function(dict) {
  return dict.enterContext;
};
var contextNames = function(ns) {
  var go = function(v) {
    return v.value0;
  };
  return reverse(map112(go)(ns));
};
var complResultMonad = {
  Applicative0: function() {
    return complResultApplicative;
  },
  Bind1: function() {
    return complResultBind;
  }
};
var complResultBind = {
  bind: function(m) {
    return function(f) {
      if (m instanceof ComplResult) {
        return f(m.value0);
      }
      ;
      if (m instanceof ComplParser) {
        return new ComplParser(m.value0, m.value1);
      }
      ;
      if (m instanceof ComplOption) {
        return new ComplOption(m.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 134, column 14 - line 137, column 35): " + [m.constructor.name]);
    };
  },
  Apply0: function() {
    return $lazy_complResultApply(0);
  }
};
var complResultApplicative = /* @__PURE__ */ function() {
  return {
    pure: ComplResult.create,
    Apply0: function() {
      return $lazy_complResultApply(0);
    }
  };
}();
var $lazy_complResultFunctor = /* @__PURE__ */ $runtime_lazy11("complResultFunctor", "Options.Applicative.Internal", function() {
  return {
    map: liftM1(complResultMonad)
  };
});
var $lazy_complResultApply = /* @__PURE__ */ $runtime_lazy11("complResultApply", "Options.Applicative.Internal", function() {
  return {
    apply: ap(complResultMonad),
    Functor0: function() {
      return $lazy_complResultFunctor(0);
    }
  };
});
var complResultFunctor = /* @__PURE__ */ $lazy_complResultFunctor(124);
var map210 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorReaderT(complResultFunctor)));
var monadReaderT1 = /* @__PURE__ */ monadReaderT(complResultMonad);
var alt12 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadReaderT1));
var apply12 = /* @__PURE__ */ apply(/* @__PURE__ */ applyExceptT(monadReaderT1));
var pure25 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadReaderT1));
var bind16 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadReaderT1));
var lift32 = /* @__PURE__ */ lift6(monadReaderT1);
var lift43 = /* @__PURE__ */ lift(monadTransReaderT)(complResultMonad);
var completionFunctor = {
  map: function(f) {
    return function(v) {
      return map210(f)(v);
    };
  }
};
var completionAlt = {
  alt: function(v) {
    return function(v1) {
      return alt12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApply = {
  apply: function(v) {
    return function(v1) {
      return apply12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApplicative = {
  pure: function(a) {
    return pure25(a);
  },
  Apply0: function() {
    return completionApply;
  }
};
var pure32 = /* @__PURE__ */ pure(completionApplicative);
var completionBind = {
  bind: function(v) {
    return function(k) {
      return bind16(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return completionApply;
  }
};
var completionMonad = {
  Applicative0: function() {
    return completionApplicative;
  },
  Bind1: function() {
    return completionBind;
  }
};
var completionMonadP = {
  enterContext: function(v) {
    return function(v1) {
      return pure32(unit);
    };
  },
  exitContext: /* @__PURE__ */ pure32(unit),
  getPrefs: /* @__PURE__ */ lift32(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(complResultMonad))),
  missingArgP: function(v) {
    return function($304) {
      return Completion(lift32(lift43(ComplOption.create($304))));
    };
  },
  exitP: function(v) {
    return function(a) {
      return function(p) {
        return function(v1) {
          return Completion(lift32(lift43(new ComplParser(new SomeParser(mkExists(p)), a))));
        };
      };
    };
  },
  errorP: /* @__PURE__ */ function() {
    var $305 = throwError(monadThrowExceptT(monadReaderT1));
    return function($306) {
      return Completion($305($306));
    };
  }(),
  Monad0: function() {
    return completionMonad;
  },
  Alt1: function() {
    return completionAlt;
  }
};
var bimapTStep = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof TNil) {
        return TNil.value;
      }
      ;
      if (v2 instanceof TCons) {
        return new TCons(v(v2.value0), v1(v2.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 186, column 1 - line 186, column 77): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var listTFunctor = function(dictMonad) {
  var liftM12 = liftM1(dictMonad);
  return {
    map: function(f) {
      return function(v) {
        return liftM12(bimapTStep(f)(map(listTFunctor(dictMonad))(f)))(stepListT(v));
      };
    }
  };
};
var listTAlt = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    alt: function(xs) {
      return function(ys) {
        return bind210(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return stepListT(ys);
          }
          ;
          if (s instanceof TCons) {
            return pure42(new TCons(s.value0, alt(listTAlt(dictMonad))(s.value1)(ys)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 227, column 5 - line 229, column 49): " + [s.constructor.name]);
        });
      };
    },
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTPlus = function(dictMonad) {
  var listTAlt1 = listTAlt(dictMonad);
  return {
    empty: pure(dictMonad.Applicative0())(TNil.value),
    Alt0: function() {
      return listTAlt1;
    }
  };
};
var hoistList = function(dictMonad) {
  var pure42 = pure(dictMonad.Applicative0());
  return foldr2(function(x) {
    return function(xt) {
      return pure42(new TCons(x, xt));
    };
  })(empty(listTPlus(dictMonad)));
};
var listTMonadTrans = {
  lift: function(dictMonad) {
    var empty10 = empty(listTPlus(dictMonad));
    var $307 = liftM1(dictMonad)(function(v) {
      return new TCons(v, empty10);
    });
    return function($308) {
      return ListT($307($308));
    };
  }
};
var lift52 = /* @__PURE__ */ lift(listTMonadTrans);
var cut = function(dictMonad) {
  return lift52(monadStateT(dictMonad))(put(monadStateStateT(dictMonad))(true));
};
var nondetTMonadTrans = {
  lift: function(dictMonad) {
    var $309 = lift52(monadStateT(dictMonad));
    var $310 = lift22(dictMonad);
    return function($311) {
      return NondetT($309($310($311)));
    };
  }
};
var listTMonad = function(dictMonad) {
  return {
    Applicative0: function() {
      return listTApplicative(dictMonad);
    },
    Bind1: function() {
      return listTBind(dictMonad);
    }
  };
};
var listTBind = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var alt22 = alt(listTAlt(dictMonad));
  return {
    bind: function(xs) {
      return function(f) {
        return bind210(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return pure42(TNil.value);
          }
          ;
          if (s instanceof TCons) {
            return stepListT(alt22(f(s.value0))(bind(listTBind(dictMonad))(s.value1)(f)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 218, column 5 - line 220, column 53): " + [s.constructor.name]);
        });
      };
    },
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTApply = function(dictMonad) {
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    apply: ap(listTMonad(dictMonad)),
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTApplicative = function(dictMonad) {
  return {
    pure: function() {
      var $312 = hoistList(dictMonad);
      return function($313) {
        return $312(pure17($313));
      };
    }(),
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTAlternative = function(dictMonad) {
  var listTApplicative1 = listTApplicative(dictMonad);
  var listTPlus1 = listTPlus(dictMonad);
  return {
    Applicative0: function() {
      return listTApplicative1;
    },
    Plus1: function() {
      return listTPlus1;
    }
  };
};
var nondetTAltOp = function(dictMonad) {
  var monadStateT1 = monadStateT(dictMonad);
  var alt22 = alt(listTAlt(monadStateT1));
  var listTBind1 = listTBind(monadStateT1);
  var bind210 = bind(listTBind1);
  var lift62 = lift52(monadStateT1);
  var get3 = get(monadStateStateT(dictMonad));
  var discard15 = discard6(listTBind1);
  var guard6 = guard(listTAlternative(monadStateT1));
  return function(m1) {
    return function(m2) {
      return NondetT(alt22(runNondetT(m1))(bind210(lift62(get3))(function(s) {
        return discard15(guard6(!s))(function() {
          return runNondetT(m2);
        });
      })));
    };
  };
};
var nondetTFunctor = function(dictMonad) {
  var map310 = map(listTFunctor(monadStateT(dictMonad)));
  return {
    map: function(f) {
      var $314 = map310(f);
      return function($315) {
        return NondetT($314(runNondetT($315)));
      };
    }
  };
};
var nondetTAlt = function(dictMonad) {
  var alt22 = alt(listTAlt(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    alt: function(v) {
      return function(v1) {
        return alt22(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTPlus = function(dictMonad) {
  var nondetTAlt1 = nondetTAlt(dictMonad);
  return {
    empty: empty(listTPlus(monadStateT(dictMonad))),
    Alt0: function() {
      return nondetTAlt1;
    }
  };
};
var nondetTApply = function(dictMonad) {
  var apply22 = apply(listTApply(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    apply: function(v) {
      return function(v1) {
        return apply22(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTApplicative = function(dictMonad) {
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    pure: function() {
      var $316 = pure(listTApplicative(monadStateT(dictMonad)));
      return function($317) {
        return NondetT($316($317));
      };
    }(),
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var nondetTBind = function(dictMonad) {
  var bind210 = bind(listTBind(monadStateT(dictMonad)));
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    bind: function(v) {
      return function(f) {
        return bind210(v)(function($318) {
          return runNondetT(f($318));
        });
      };
    },
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var takeListT = function(dictMonad) {
  var empty10 = empty(listTPlus(dictMonad));
  var liftM12 = liftM1(dictMonad);
  return function(v) {
    if (v === 0) {
      return $$const(empty10);
    }
    ;
    var $319 = liftM12(bimapTStep(identity11)(takeListT(dictMonad)(v - 1 | 0)));
    return function($320) {
      return ListT($319(stepListT($320)));
    };
  };
};
var disamb = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var bind210 = bind(Bind1);
  var evalStateT2 = evalStateT(Bind1.Apply0().Functor0());
  var monadStateT1 = monadStateT(dictMonad);
  var runListT1 = runListT(monadStateT1);
  var takeListT1 = takeListT(monadStateT1);
  var pure42 = pure(dictMonad.Applicative0());
  return function(allow_amb) {
    return function(xs) {
      return bind210(function(v) {
        return evalStateT2(v)(false);
      }(runListT1(takeListT1(function() {
        if (allow_amb) {
          return 1;
        }
        ;
        return 2;
      }())(runNondetT(xs)))))(function(xs$prime) {
        return pure42(function() {
          if (xs$prime instanceof Cons && xs$prime.value1 instanceof Nil) {
            return new Just(xs$prime.value0);
          }
          ;
          return Nothing.value;
        }());
      });
    };
  };
};

// output/Options.Applicative.Common/index.js
var bind17 = /* @__PURE__ */ bind(bindArray);
var fromFoldable17 = /* @__PURE__ */ fromFoldable(foldableList);
var map31 = /* @__PURE__ */ map(functorMaybe);
var voidRight3 = /* @__PURE__ */ voidRight(functorMaybe);
var guard4 = /* @__PURE__ */ guard(alternativeMaybe);
var any7 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var elem3 = /* @__PURE__ */ elem(foldableArray)(optNameEq);
var discard7 = /* @__PURE__ */ discard(discardUnit);
var discard13 = /* @__PURE__ */ discard7(bindMaybe);
var un5 = /* @__PURE__ */ un();
var lift7 = /* @__PURE__ */ lift(monadTransStateT);
var apply8 = /* @__PURE__ */ apply(applyMaybe);
var alt10 = /* @__PURE__ */ alt(altMaybe);
var bind18 = /* @__PURE__ */ bind(bindMaybe);
var apply13 = /* @__PURE__ */ apply(parserApply);
var oneOf3 = /* @__PURE__ */ oneOf(foldableArray);
var bind22 = /* @__PURE__ */ bind(freeBind);
var greaterThan2 = /* @__PURE__ */ greaterThan(optVisibilityOrd);
var lift12 = /* @__PURE__ */ lift(nondetTMonadTrans);
var pure18 = /* @__PURE__ */ pure(parserApplicative);
var pure19 = /* @__PURE__ */ pure(applicativeMaybe);
var notEq1 = /* @__PURE__ */ notEq(argPolicyEq);
var OptWord = /* @__PURE__ */ function() {
  function OptWord2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OptWord2.create = function(value0) {
    return function(value12) {
      return new OptWord2(value0, value12);
    };
  };
  return OptWord2;
}();
var unexpectedError = function(arg) {
  return function(p) {
    return new UnexpectedError(arg, new SomeParser(mkExists(p)));
  };
};
var simplify = function(v) {
  if (v instanceof Leaf2) {
    return new Leaf2(v.value0);
  }
  ;
  if (v instanceof MultNode) {
    var remove_mult = function(v12) {
      if (v12 instanceof MultNode) {
        return v12.value0;
      }
      ;
      return [v12];
    };
    var v1 = bind17(v.value0)(function($340) {
      return remove_mult(simplify($340));
    });
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new MultNode(v1);
  }
  ;
  if (v instanceof AltNode) {
    var remove_alt = function(v12) {
      if (v12 instanceof AltNode) {
        return v12.value0;
      }
      ;
      if (v12 instanceof MultNode && v12.value0.length === 0) {
        return [];
      }
      ;
      return [v12];
    };
    var v1 = bind17(v.value0)(function($341) {
      return remove_alt(simplify($341));
    });
    if (v1.length === 0) {
      return new MultNode([]);
    }
    ;
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new AltNode(v1);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 280, column 1 - line 280, column 45): " + [v.constructor.name]);
};
var showOption = function(v) {
  if (v instanceof OptLong) {
    return "--" + v.value0;
  }
  ;
  if (v instanceof OptShort) {
    return fromCharArray(["-", v.value0]);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 43, column 1 - line 43, column 32): " + [v.constructor.name]);
};
var parseWord = /* @__PURE__ */ function() {
  var go = function(v) {
    if (v instanceof Cons && (v.value0 === "-" && (v.value1 instanceof Cons && v.value1.value0 === "-"))) {
      return new Just(function() {
        var v1 = function() {
          var v2 = span2(function(v3) {
            return v3 !== "=";
          })(v.value1.value1);
          if (v2.rest instanceof Nil) {
            return new Tuple(v.value1.value1, Nothing.value);
          }
          ;
          if (v2.rest instanceof Cons) {
            return new Tuple(v2.init, new Just(v2.rest.value1));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 107, column 23 - line 109, column 70): " + [v2.constructor.name]);
        }();
        return new OptWord(new OptLong(fromCharArray(fromFoldable17(v1.value0))), map31(function($342) {
          return fromCharArray(fromFoldable17($342));
        })(v1.value1));
      }());
    }
    ;
    if (v instanceof Cons && v.value0 === "-") {
      if (v.value1 instanceof Nil) {
        return Nothing.value;
      }
      ;
      if (v.value1 instanceof Cons) {
        return new Just(function() {
          var arg = voidRight3(v.value1.value1)(guard4(!$$null4(v.value1.value1)));
          return new OptWord(new OptShort(v.value1.value0), map31(function($343) {
            return fromCharArray(fromFoldable17($343));
          })(arg));
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 111, column 25 - line 115, column 79): " + [v.value1.constructor.name]);
    }
    ;
    return Nothing.value;
  };
  var $344 = fromFoldable6(foldableArray);
  return function($345) {
    return go($344(toCharArray($345)));
  };
}();
var optionNames = function(v) {
  if (v instanceof OptReader) {
    return v.value0;
  }
  ;
  if (v instanceof FlagReader) {
    return v.value0;
  }
  ;
  return [];
};
var liftOpt = /* @__PURE__ */ function() {
  return OptP.create;
}();
var isOptionPrefix = function(v) {
  return function(v1) {
    if (v instanceof OptShort && v1 instanceof OptShort) {
      return v.value0 === v1.value0;
    }
    ;
    if (v instanceof OptLong && v1 instanceof OptLong) {
      return startsWith(v.value0)(v1.value0);
    }
    ;
    return false;
  };
};
var optMatches = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bindStateT3 = bindStateT(Monad0);
  var bind32 = bind(bindStateT3);
  var monadStateStateT2 = monadStateStateT(Monad0);
  var get3 = get(monadStateStateT2);
  var missingArgP2 = missingArgP(dictMonadP);
  var lift23 = lift7(Monad0);
  var pure210 = pure(applicativeStateT(Monad0));
  var discard23 = discard7(bindStateT3);
  var put2 = put(monadStateStateT2);
  var runReadM2 = runReadM(dictMonadP);
  return function(disambiguate) {
    return function(opt) {
      return function(v) {
        var is_short = function(v1) {
          if (v1 instanceof OptShort) {
            return true;
          }
          ;
          if (v1 instanceof OptLong) {
            return false;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 90, column 5 - line 90, column 33): " + [v1.constructor.name]);
        };
        var has_name = function(a) {
          if (disambiguate) {
            return any7(isOptionPrefix(a));
          }
          ;
          if (otherwise) {
            return elem3(a);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 93, column 5 - line 95, column 27): " + [a.constructor.name]);
        };
        var errorFor = function(name3) {
          return function(msg) {
            return "option " + (showOption(name3) + (": " + msg));
          };
        };
        if (opt instanceof OptReader) {
          return discard13(guard4(has_name(v.value0)(opt.value0)))(function() {
            return new Just(bind32(get3)(function(args) {
              var missing_arg = missingArgP2(opt.value2(showOption(v.value0)))(un5(CReader)(opt.value1).crCompleter);
              return bind32(function() {
                var v1 = maybe(args)(function(v2) {
                  return new Cons(v2, args);
                })(v.value1);
                if (v1 instanceof Nil) {
                  return lift23(missing_arg);
                }
                ;
                if (v1 instanceof Cons) {
                  return pure210(new Tuple(v1.value0, v1.value1));
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 68, column 27 - line 70, column 56): " + [v1.constructor.name]);
              }())(function(v1) {
                return discard23(put2(v1.value1))(function() {
                  return lift23(runReadM2(withReadM(errorFor(v.value0))(un5(CReader)(opt.value1).crReader))(v1.value0));
                });
              });
            }));
          });
        }
        ;
        if (opt instanceof FlagReader) {
          return discard13(guard4(has_name(v.value0)(opt.value0)))(function() {
            return discard13(guard4(is_short(v.value0) || isNothing(v.value1)))(function() {
              return new Just(bind32(get3)(function(args) {
                var val$prime = map31(function($346) {
                  return function(s) {
                    return cons("-")(s);
                  }(toCharArray($346));
                })(v.value1);
                return discard23(put2(maybe(args)(function() {
                  var $347 = flip(Cons.create)(args);
                  return function($348) {
                    return $347(fromCharArray($348));
                  };
                }())(val$prime)))(function() {
                  return pure210(opt.value1);
                });
              }));
            });
          });
        }
        ;
        return Nothing.value;
      };
    };
  };
};
var isArg = function(v) {
  if (v instanceof ArgReader) {
    return true;
  }
  ;
  return false;
};
var evalParser = function(v) {
  if (v instanceof NilP) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof OptP) {
    return Nothing.value;
  }
  ;
  if (v instanceof MultP) {
    return runExists(function(v1) {
      return apply8(evalParser(v1.value0))(evalParser(v1.value1));
    })(v.value0);
  }
  ;
  if (v instanceof AltP) {
    return alt10(evalParser(v.value0))(evalParser(v.value1));
  }
  ;
  if (v instanceof BindP) {
    return resume$prime(function(p) {
      return function(k) {
        return bind18(evalParser(p))(function($349) {
          return evalParser(BindP.create(k($349)));
        });
      };
    })(Just.create)(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 220, column 1 - line 220, column 44): " + [v.constructor.name]);
};
var searchParser = function(dictMonad) {
  var nondetTPlus2 = nondetTPlus(dictMonad);
  var empty10 = empty(nondetTPlus2);
  var mapFlipped15 = mapFlipped(nondetTFunctor(dictMonad));
  var nondetTAltOp2 = nondetTAltOp(dictMonad);
  var oneOf1 = oneOf3(nondetTPlus2);
  return function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return empty10;
      }
      ;
      if (v1 instanceof OptP) {
        return v(v1.value0);
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          var b = mapFlipped15(searchParser(dictMonad)(v)(v2.value1))(function(p2$prime) {
            return apply13(v2.value0)(p2$prime);
          });
          var a = mapFlipped15(searchParser(dictMonad)(v)(v2.value0))(function(p1$prime) {
            return apply13(p1$prime)(v2.value1);
          });
          return nondetTAltOp2(a)(b);
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return oneOf1([searchParser(dictMonad)(v)(v1.value0), searchParser(dictMonad)(v)(v1.value1)]);
      }
      ;
      if (v1 instanceof BindP) {
        return resume$prime(function(p) {
          return function(k) {
            return oneOf1([mapFlipped15(searchParser(dictMonad)(v)(p))(function(p$prime) {
              return new BindP(bind22(liftF(p$prime))(k));
            }), function() {
              var v2 = evalParser(p);
              if (v2 instanceof Nothing) {
                return empty10;
              }
              ;
              if (v2 instanceof Just) {
                return searchParser(dictMonad)(v)(new BindP(k(v2.value0)));
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Common (line 135, column 7 - line 137, column 49): " + [v2.constructor.name]);
            }()]);
          };
        })($$const(empty10))(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 118, column 1 - line 120, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var searchOpt = function(dictMonadP) {
  var monadStateT3 = monadStateT(dictMonadP.Monad0());
  var searchParser1 = searchParser(monadStateT3);
  var optMatches1 = optMatches(dictMonadP);
  var lift23 = lift12(monadStateT3);
  var map117 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var empty10 = empty(nondetTPlus(monadStateT3));
  return function(pprefs) {
    return function(w) {
      return searchParser1(function(opt) {
        var disambiguate = un5(ParserPrefs)(pprefs).prefDisambiguate && greaterThan2(optVisibility(opt))(Internal.value);
        var v = optMatches1(disambiguate)(un5(Option)(opt).optMain)(w);
        if (v instanceof Just) {
          return lift23(map117(pure18)(v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return empty10;
        }
        ;
        throw new Error("Failed pattern match at Options.Applicative.Common (line 144, column 3 - line 146, column 21): " + [v.constructor.name]);
      });
    };
  };
};
var stepParser = function(dictMonadP) {
  var alt19 = alt(nondetTAlt(monadStateT(dictMonadP.Monad0())));
  var searchOpt1 = searchOpt(dictMonadP);
  return function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          if (v1 instanceof AllPositionals) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          if (v1 instanceof ForwardOptions) {
            var v4 = parseWord(v2);
            if (v4 instanceof Just) {
              return alt19(searchOpt1(v)(v4.value0)(v3))(searchArg(dictMonadP)(v)(v2)(v3));
            }
            ;
            if (v4 instanceof Nothing) {
              return searchArg(dictMonadP)(v)(v2)(v3);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 174, column 42 - line 176, column 36): " + [v4.constructor.name]);
          }
          ;
          var v4 = parseWord(v2);
          if (v4 instanceof Just) {
            return searchOpt1(v)(v4.value0)(v3);
          }
          ;
          if (v4 instanceof Nothing) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 177, column 29 - line 179, column 36): " + [v4.constructor.name]);
        };
      };
    };
  };
};
var searchArg = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var monadStateT3 = monadStateT(Monad0);
  var searchParser1 = searchParser(monadStateT3);
  var discard23 = discard7(nondetTBind(monadStateT3));
  var when5 = when(nondetTApplicative(monadStateT3));
  var cut2 = cut(monadStateT3);
  var lift23 = lift12(monadStateT3);
  var bindStateT3 = bindStateT(Monad0);
  var bind32 = bind(bindStateT3);
  var applyFirst4 = applyFirst(applyStateT(Monad0));
  var monadStateStateT2 = monadStateStateT(Monad0);
  var get3 = get(monadStateStateT2);
  var put2 = put(monadStateStateT2);
  var map117 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var lift33 = lift7(Monad0);
  var Apply0 = Monad0.Bind1().Apply0();
  var applyFirst1 = applyFirst(Apply0);
  var applySecond4 = applySecond(Apply0);
  var enterContext2 = enterContext(dictMonadP);
  var exitContext2 = exitContext(dictMonadP);
  var map213 = map(nondetTFunctor(monadStateT3));
  var discard32 = discard7(bindStateT3);
  var pure210 = pure(applicativeStateT(Monad0));
  var empty10 = empty(nondetTPlus(monadStateT3));
  var runReadM2 = runReadM(dictMonadP);
  return function(prefs2) {
    return function(arg) {
      return searchParser1(function(opt) {
        return discard23(when5(isArg(un5(Option)(opt).optMain))(cut2))(function() {
          var v = un5(Option)(opt).optMain;
          if (v instanceof CmdReader) {
            var v1 = new Tuple(v.value2(arg), un5(ParserPrefs)(prefs2).prefBacktrack);
            if (v1.value0 instanceof Just && v1.value1 instanceof NoBacktrack) {
              return lift23(bind32(applyFirst4(get3)(put2(Nil.value)))(function(args) {
                return map117(pure18)(lift33(applyFirst1(applySecond4(enterContext2(arg)(v1.value0.value0))(runParserInfo(dictMonadP)(v1.value0.value0)(args)))(exitContext2)));
              }));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof Backtrack) {
              return map213(pure18)(lift23(StateT(function(args) {
                return applyFirst1(applySecond4(enterContext2(arg)(v1.value0.value0))(runParser3(dictMonadP)(un5(ParserInfo)(v1.value0.value0).infoPolicy)(CmdStart.value)(un5(ParserInfo)(v1.value0.value0).infoParser)(args)))(exitContext2);
              })));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof SubparserInline) {
              return lift23(discard32(lift33(enterContext2(arg)(v1.value0.value0)))(function() {
                return pure210(un5(ParserInfo)(v1.value0.value0).infoParser);
              }));
            }
            ;
            if (v1.value0 instanceof Nothing) {
              return empty10;
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 154, column 7 - line 166, column 38): " + [v1.constructor.name]);
          }
          ;
          if (v instanceof ArgReader) {
            return map213(pure18)(lift23(lift33(runReadM2(un5(CReader)(v.value0).crReader)(arg))));
          }
          ;
          return empty10;
        });
      });
    };
  };
};
var runParserInfo = function(dictMonadP) {
  return function(i) {
    return runParserFully(dictMonadP)(un5(ParserInfo)(i).infoPolicy)(un5(ParserInfo)(i).infoParser);
  };
};
var runParserFully = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bind32 = bind(Monad0.Bind1());
  var pure210 = pure(Monad0.Applicative0());
  var errorP2 = errorP(dictMonadP);
  return function(policy) {
    return function(p) {
      return function(args) {
        return bind32(runParser3(dictMonadP)(policy)(CmdStart.value)(p)(args))(function(v) {
          if (v.value1 instanceof Nil) {
            return pure210(v.value0);
          }
          ;
          if (v.value1 instanceof Cons) {
            return errorP2(unexpectedError(v.value1.value0)(pure18(unit)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 214, column 3 - line 216, column 66): " + [v.value1.constructor.name]);
        });
      };
    };
  };
};
var runParser3 = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var disamb2 = disamb(monadStateT(Monad0));
  var exitP2 = exitP(dictMonadP);
  var bind32 = bind(Monad0.Bind1());
  var getPrefs2 = getPrefs(dictMonadP);
  var hoistMaybe2 = hoistMaybe(dictMonadP);
  return function(policy) {
    return function(isCmdStart) {
      return function(p) {
        return function(args) {
          var result = apply8(map31(Tuple.create)(evalParser(p)))(pure19(args));
          var newPolicy = function(a) {
            if (policy instanceof NoIntersperse) {
              var $299 = isJust(parseWord(a));
              if ($299) {
                return NoIntersperse.value;
              }
              ;
              return AllPositionals.value;
            }
            ;
            return policy;
          };
          var do_step = function(prefs2) {
            return function(arg) {
              return function(argt) {
                return function(v) {
                  return runStateT(v)(argt);
                }(disamb2(!un5(ParserPrefs)(prefs2).prefDisambiguate)(stepParser(dictMonadP)(prefs2)(policy)(arg)(p)));
              };
            };
          };
          if (args instanceof Nil) {
            return exitP2(isCmdStart)(policy)(p)(result);
          }
          ;
          if (args instanceof Cons && (args.value0 === "--" && notEq1(policy)(AllPositionals.value))) {
            return runParser3(dictMonadP)(AllPositionals.value)(CmdCont.value)(p)(args.value1);
          }
          ;
          if (args instanceof Cons) {
            return bind32(getPrefs2)(function(prefs2) {
              return bind32(do_step(prefs2)(args.value0)(args.value1))(function(v) {
                if (v.value0 instanceof Nothing) {
                  return hoistMaybe2(unexpectedError(args.value0)(p))(result);
                }
                ;
                if (v.value0 instanceof Just) {
                  return runParser3(dictMonadP)(newPolicy(args.value0))(CmdCont.value)(v.value0.value0)(v.value1);
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 192, column 5 - line 194, column 60): " + [v.value0.constructor.name]);
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 186, column 38 - line 194, column 60): " + [args.constructor.name]);
        };
      };
    };
  };
};
var treeMapParser = function(g) {
  var has_default = function(p) {
    return isJust(evalParser(p));
  };
  var hasArg = function(v) {
    if (v instanceof NilP) {
      return false;
    }
    ;
    if (v instanceof OptP) {
      return isArg(un5(Option)(v.value0).optMain);
    }
    ;
    if (v instanceof MultP) {
      return runExists(function(v1) {
        return hasArg(v1.value0) || hasArg(v1.value1);
      })(v.value0);
    }
    ;
    if (v instanceof AltP) {
      return hasArg(v.value0) || hasArg(v.value1);
    }
    ;
    if (v instanceof BindP) {
      return resume$prime(function(p) {
        return function(v1) {
          return hasArg(p);
        };
      })($$const(false))(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 272, column 5 - line 272, column 44): " + [v.constructor.name]);
  };
  var go = function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return function(v4) {
            if (v4 instanceof NilP) {
              return new MultNode([]);
            }
            ;
            if (v4 instanceof OptP) {
              if (greaterThan2(optVisibility(v4.value0))(Internal.value)) {
                return new Leaf2(v3({
                  hinfoMulti: v,
                  hinfoDefault: v1,
                  hinfoUnreachableArgs: v2
                })(v4.value0));
              }
              ;
              if (otherwise) {
                return new MultNode([]);
              }
              ;
            }
            ;
            if (v4 instanceof MultP) {
              return runExists(function(v5) {
                var r$prime = v2 || hasArg(v5.value0);
                return new MultNode([go(v)(v1)(v2)(v3)(v5.value0), go(v)(v1)(r$prime)(v3)(v5.value1)]);
              })(v4.value0);
            }
            ;
            if (v4 instanceof AltP) {
              var d$prime = v1 || (has_default(v4.value0) || has_default(v4.value1));
              return new AltNode([go(v)(d$prime)(v2)(v3)(v4.value0), go(v)(d$prime)(v2)(v3)(v4.value1)]);
            }
            ;
            if (v4 instanceof BindP) {
              return resume$prime(function(p) {
                return function(k) {
                  var go$prime = go(true)(v1)(v2)(v3)(p);
                  var v5 = evalParser(p);
                  if (v5 instanceof Nothing) {
                    return go$prime;
                  }
                  ;
                  if (v5 instanceof Just) {
                    return new MultNode([go$prime, go(true)(v1)(v2)(v3)(new BindP(k(v5.value0)))]);
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.Common (line 267, column 12 - line 269, column 68): " + [v5.constructor.name]);
                };
              })($$const(new MultNode([])))(v4.value0);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 248, column 5 - line 251, column 21): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name, v4.constructor.name]);
          };
        };
      };
    };
  };
  var $350 = go(false)(false)(false)(g);
  return function($351) {
    return simplify($350($351));
  };
};
var mapParser = function(f) {
  var flatten2 = function(v) {
    if (v instanceof Leaf2) {
      return [v.value0];
    }
    ;
    if (v instanceof MultNode) {
      return bind17(v.value0)(flatten2);
    }
    ;
    if (v instanceof AltNode) {
      return bind17(v.value0)(flatten2);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 235, column 5 - line 235, column 27): " + [v.constructor.name]);
  };
  var $352 = treeMapParser(f);
  return function($353) {
    return flatten2($352($353));
  };
};

// output/Options.Applicative.Builder.Internal/index.js
var over4 = /* @__PURE__ */ over()();
var append7 = /* @__PURE__ */ append(semigroupArray);
var map34 = /* @__PURE__ */ map(functorArray);
var lookup9 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var alt11 = /* @__PURE__ */ alt(altMaybe);
var identity12 = /* @__PURE__ */ identity(categoryFn);
var apply9 = /* @__PURE__ */ apply(applyMaybe);
var alt13 = /* @__PURE__ */ alt(parserAlt);
var pure20 = /* @__PURE__ */ pure(parserApplicative);
var OptionFields = function(x) {
  return x;
};
var FlagFields = function(x) {
  return x;
};
var DefaultProp = /* @__PURE__ */ function() {
  function DefaultProp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DefaultProp2.create = function(value0) {
    return function(value12) {
      return new DefaultProp2(value0, value12);
    };
  };
  return DefaultProp2;
}();
var Mod = /* @__PURE__ */ function() {
  function Mod2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Mod2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Mod2(value0, value12, value22);
      };
    };
  };
  return Mod2;
}();
var CommandFields = function(x) {
  return x;
};
var optionFieldsHasValue = {
  hasValueDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasName = {
  name: function(n) {
    return over4(OptionFields)(function(fields) {
      return {
        optCompleter: fields.optCompleter,
        optNoArgError: fields.optNoArgError,
        optNames: append7([n])(fields.optNames)
      };
    });
  }
};
var name2 = function(dict) {
  return dict.name;
};
var mkCommand = function(m) {
  var v = m.value0({
    cmdCommands: [],
    cmdGroup: Nothing.value
  });
  return new Tuple(v.cmdGroup, new Tuple(map34(fst)(v.cmdCommands), new Tuple(function(v1) {
    return lookup9(v1)(v.cmdCommands);
  }, unit)));
};
var flagFieldsHasName = {
  name: function(n) {
    return over4(FlagFields)(function(fields) {
      return {
        flagActive: fields.flagActive,
        flagNames: append7([n])(fields.flagNames)
      };
    });
  }
};
var defaultPropSemigroup = {
  append: function(v) {
    return function(v1) {
      return new DefaultProp(alt11(v.value0)(v1.value0), alt11(v.value1)(v1.value1));
    };
  }
};
var append15 = /* @__PURE__ */ append(defaultPropSemigroup);
var modSemigroup = {
  append: function(v) {
    return function(v1) {
      return new Mod(function($69) {
        return v1.value0(v.value0($69));
      }, append15(v1.value1)(v.value1), function($70) {
        return v1.value2(v.value2($70));
      });
    };
  }
};
var defaultPropMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new DefaultProp(Nothing.value, Nothing.value),
    Semigroup0: function() {
      return defaultPropSemigroup;
    }
  };
}();
var mempty4 = /* @__PURE__ */ mempty(defaultPropMonoid);
var fieldMod = function(f) {
  return new Mod(f, mempty4, identity12);
};
var modMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new Mod(identity12, mempty4, identity12),
    Semigroup0: function() {
      return modSemigroup;
    }
  };
}();
var optionMod = /* @__PURE__ */ function() {
  return Mod.create(identity12)(mempty4);
}();
var internal = /* @__PURE__ */ optionMod(/* @__PURE__ */ over4(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: Internal.value
  };
}));
var commandFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var baseProps = /* @__PURE__ */ function() {
  return {
    propMetaVar: "",
    propVisibility: Visible.value,
    propHelp: mempty(chunkMonoid(docSemigroup)),
    propShowDefault: Nothing.value,
    propDescMod: Nothing.value
  };
}();
var mkProps = function(v) {
  return function(g) {
    var props = over4(OptProperties)(function(r) {
      return {
        propDescMod: r.propDescMod,
        propHelp: r.propHelp,
        propMetaVar: r.propMetaVar,
        propVisibility: r.propVisibility,
        propShowDefault: apply9(v.value1)(v.value0)
      };
    })(g(baseProps));
    return props;
  };
};
var mkOption = function(d) {
  return function(g) {
    return function(rdr) {
      return {
        optMain: rdr,
        optProps: mkProps(d)(g)
      };
    };
  };
};
var mkParser = function(v) {
  return function(g) {
    return function(rdr) {
      var o = liftOpt(mkOption(v)(g)(rdr));
      return maybe(o)(function(a) {
        return alt13(o)(pure20(a));
      })(v.value0);
    };
  };
};
var argumentFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};

// output/Options.Applicative.Builder/index.js
var identity13 = /* @__PURE__ */ identity(categoryFn);
var over5 = /* @__PURE__ */ over()();
var un6 = /* @__PURE__ */ un();
var append8 = /* @__PURE__ */ append(modSemigroup);
var mempty5 = /* @__PURE__ */ mempty(completerMonoid);
var bind19 = /* @__PURE__ */ bind(readMBind);
var pure21 = /* @__PURE__ */ pure(readMApplicative);
var mempty12 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var min4 = /* @__PURE__ */ min(optVisibilityOrd);
var alt14 = /* @__PURE__ */ alt(parserAlt);
var pure110 = /* @__PURE__ */ pure(parserApplicative);
var show7 = /* @__PURE__ */ show(showString);
var append32 = /* @__PURE__ */ append(semigroupArray);
var mempty22 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "argCompleter";
  }
})(completerMonoid)()(monoidRecordNil)));
var fold7 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var PrefsMod = function(x) {
  return x;
};
var InfoMod = function(x) {
  return x;
};
var value = function(dictHasValue) {
  return function(x) {
    return new Mod(identity13, new DefaultProp(new Just(x), Nothing.value), identity13);
  };
};
var value1 = /* @__PURE__ */ value(optionFieldsHasValue);
var subparserInline = /* @__PURE__ */ over5(ParserPrefs)(function(p) {
  return {
    prefColumns: p.prefColumns,
    prefDisambiguate: p.prefDisambiguate,
    prefMultiSuffix: p.prefMultiSuffix,
    prefShowHelpOnEmpty: p.prefShowHelpOnEmpty,
    prefShowHelpOnError: p.prefShowHelpOnError,
    prefBacktrack: SubparserInline.value
  };
});
var str = readerAsk;
var showHelpOnError = /* @__PURE__ */ over5(ParserPrefs)(function(p) {
  return {
    prefBacktrack: p.prefBacktrack,
    prefColumns: p.prefColumns,
    prefDisambiguate: p.prefDisambiguate,
    prefMultiSuffix: p.prefMultiSuffix,
    prefShowHelpOnEmpty: p.prefShowHelpOnEmpty,
    prefShowHelpOnError: true
  };
});
var $$short = function(dictHasName) {
  var $121 = name2(dictHasName);
  return function($122) {
    return fieldMod($121(OptShort.create($122)));
  };
};
var progDesc = function(s) {
  return over5(ParserInfo)(function(i) {
    return {
      infoFailureCode: i.infoFailureCode,
      infoFooter: i.infoFooter,
      infoFullDesc: i.infoFullDesc,
      infoHeader: i.infoHeader,
      infoParser: i.infoParser,
      infoPolicy: i.infoPolicy,
      infoProgDesc: paragraph(s)
    };
  });
};
var noArgError = function(e) {
  return fieldMod(over5(OptionFields)(function(p) {
    return {
      optCompleter: p.optCompleter,
      optNames: p.optNames,
      optNoArgError: $$const(e)
    };
  }));
};
var prefs = function(m) {
  var base = {
    prefMultiSuffix: "",
    prefDisambiguate: false,
    prefShowHelpOnError: false,
    prefShowHelpOnEmpty: false,
    prefBacktrack: Backtrack.value,
    prefColumns: 80
  };
  return un6(PrefsMod)(m)(base);
};
var prefsModSemigroup = {
  append: function(m1) {
    return function(m2) {
      var $123 = un6(PrefsMod)(m2);
      var $124 = un6(PrefsMod)(m1);
      return function($125) {
        return $123($124($125));
      };
    };
  }
};
var metavar = function(dictHasMetavar) {
  return function($$var) {
    return optionMod(over5(OptProperties)(function(p) {
      return {
        propDescMod: p.propDescMod,
        propHelp: p.propHelp,
        propShowDefault: p.propShowDefault,
        propVisibility: p.propVisibility,
        propMetaVar: $$var
      };
    }));
  };
};
var metavar1 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var metavar2 = /* @__PURE__ */ metavar(commandFieldsHasMetavar);
var option2 = function(r) {
  return function(m) {
    var v = append8(metavar1("ARG"))(m);
    var v1 = v.value0({
      optNames: [],
      optCompleter: mempty5,
      optNoArgError: ExpectsArgError.create
    });
    var crdr = {
      crCompleter: v1.optCompleter,
      crReader: r
    };
    var rdr = new OptReader(v1.optNames, crdr, v1.optNoArgError);
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var strOption = /* @__PURE__ */ option2(str);
var subparser = function(m) {
  var v = append8(metavar2("COMMAND"))(m);
  var v1 = mkCommand(m);
  var rdr = new CmdReader(v1.value0, v1.value1.value0, v1.value1.value1.value0);
  return mkParser(v.value1)(v.value2)(rdr);
};
var $$long = function(dictHasName) {
  var $126 = name2(dictHasName);
  return function($127) {
    return fieldMod($126(OptLong.create($127)));
  };
};
var info3 = function(parser) {
  return function(m) {
    var base = {
      infoParser: parser,
      infoFullDesc: true,
      infoProgDesc: mempty12,
      infoHeader: mempty12,
      infoFooter: mempty12,
      infoFailureCode: $$Error.value,
      infoPolicy: Intersperse.value
    };
    return un6(InfoMod)(m)(base);
  };
};
var hidden = /* @__PURE__ */ optionMod(/* @__PURE__ */ over5(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: min4(Hidden.value)(p.propVisibility)
  };
}));
var help = function(s) {
  return optionMod(over5(OptProperties)(function(p) {
    return {
      propDescMod: p.propDescMod,
      propMetaVar: p.propMetaVar,
      propShowDefault: p.propShowDefault,
      propVisibility: p.propVisibility,
      propHelp: paragraph(s)
    };
  }));
};
var flag$prime = function(actv) {
  return function(v) {
    var rdr = function() {
      var v1 = v.value0({
        flagNames: [],
        flagActive: actv
      });
      return new FlagReader(v1.flagNames, v1.flagActive);
    }();
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var flag = function(defv) {
  return function(actv) {
    return function(m) {
      return alt14(flag$prime(actv)(m))(pure110(defv));
    };
  };
};
var $$switch = /* @__PURE__ */ flag(false)(true);
var eitherReader = function(f) {
  return bind19(readerAsk)(function() {
    var $131 = either(readerError)(pure21);
    return function($132) {
      return $131(f($132));
    };
  }());
};
var $$int2 = /* @__PURE__ */ eitherReader(function(s) {
  var v = fromString3(s);
  if (v instanceof Nothing) {
    return new Left("Can't parse as Int: `" + (show7(s) + "`"));
  }
  ;
  if (v instanceof Just) {
    return new Right(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Builder (line 124, column 28 - line 126, column 20): " + [v.constructor.name]);
});
var command = function(cmd) {
  return function(pinfo) {
    return fieldMod(over5(CommandFields)(function(p) {
      return {
        cmdGroup: p.cmdGroup,
        cmdCommands: append32([new Tuple(cmd, pinfo)])(p.cmdCommands)
      };
    }));
  };
};
var argument = function(p) {
  return function(v) {
    var v1 = v.value0(mempty22);
    var rdr = {
      crCompleter: v1.argCompleter,
      crReader: p
    };
    return mkParser(v.value1)(v.value2)(new ArgReader(rdr));
  };
};
var strArgument = /* @__PURE__ */ argument(str);
var abortOption = function(err) {
  return function(m) {
    return option2(readerAbort(err))(function(v) {
      return append8(v)(m);
    }(fold7([noArgError(err), value1(identity13), metavar1("")])));
  };
};

// output/Node.Stream/foreign.js
var writeStringImpl = (w, str2, enc) => w.write(str2, enc);

// output/Node.Stream/index.js
var writeString = function(w) {
  return function(enc) {
    return function(str2) {
      return function() {
        return writeStringImpl(w, str2, encodingToNode(enc));
      };
    };
  };
};

// output/Options.Applicative.BashCompletion/index.js
var pure26 = /* @__PURE__ */ pure(applicativeEffect);
var un7 = /* @__PURE__ */ un();
var map35 = /* @__PURE__ */ map(functorMaybe);
var map113 = /* @__PURE__ */ map(functorArray);
var runParserInfo2 = /* @__PURE__ */ runParserInfo(completionMonadP);
var fromFoldable18 = /* @__PURE__ */ fromFoldable6(foldableArray);
var identity14 = /* @__PURE__ */ identity(categoryFn);
var bind20 = /* @__PURE__ */ bind(bindMaybe);
var notEq4 = /* @__PURE__ */ notEq(argPolicyEq);
var map211 = /* @__PURE__ */ map(functorEffect);
var fold8 = /* @__PURE__ */ fold(foldableArray)(monoidArray);
var sequence2 = /* @__PURE__ */ sequence(traversableArray)(applicativeEffect);
var unLines2 = /* @__PURE__ */ unLines(foldableArray);
var alt15 = /* @__PURE__ */ alt(parserAlt);
var map36 = /* @__PURE__ */ map(parserFunctor);
var apply10 = /* @__PURE__ */ apply(parserApply);
var append16 = /* @__PURE__ */ append(modSemigroup);
var $$long2 = /* @__PURE__ */ $$long(flagFieldsHasName);
var long1 = /* @__PURE__ */ $$long(optionFieldsHasName);
var value2 = /* @__PURE__ */ value(optionFieldsHasValue);
var pure111 = /* @__PURE__ */ pure(parserApplicative);
var fromFoldable19 = /* @__PURE__ */ fromFoldable(foldableList);
var Standard = /* @__PURE__ */ function() {
  function Standard2() {
  }
  ;
  Standard2.value = new Standard2();
  return Standard2;
}();
var Enriched = /* @__PURE__ */ function() {
  function Enriched2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Enriched2.create = function(value0) {
    return function(value12) {
      return new Enriched2(value0, value12);
    };
  };
  return Enriched2;
}();
var zshCompletionScript = function(prog) {
  return function(progn) {
    return pure26(["#compdef " + progn, "", "local request", "local completions", "local word", "local index=$((CURRENT - 1))", "", "request=(--bash-completion-enriched --bash-completion-index $index)", "for arg in ${words[@]}; do", "  request=(${request[@]} --bash-completion-word $arg)", "done", "", "IFS=$'\\n' completions=($( " + (prog + ' "${request[@]}" ))'), "", "for word in $completions; do", "  local -a parts", "", "  # Split the line at a tab if there is one.", "  IFS=$'\\t' parts=($( echo $word ))", "", "  if [[ -n $parts[2] ]]; then", '     if [[ $word[1] == "-" ]]; then', '       local desc=("$parts[1] ($parts[2])")', "       compadd -d desc -- $parts[1]", "     else", '       local desc=($(print -f  "%-019s -- %s" $parts[1] $parts[2]))', "       compadd -l -d desc -- $parts[1]", "     fi", "  else", "    compadd -f -- $word", "  fi", "done"]);
  };
};
var fishCompletionScript = function(prog) {
  return function(progn) {
    return pure26([" function _" + progn, "    set -l cl (commandline --tokenize --current-process)", "    # Hack around fish issue #3934", "    set -l cn (commandline --tokenize --cut-at-cursor --current-process)", "    set -l cn (count $cn)", "    set -l tmpline --bash-completion-enriched --bash-completion-index $cn", "    for arg in $cl", "      set tmpline $tmpline --bash-completion-word $arg", "    end", "    for opt in (" + (prog + " $tmpline)"), "      if test -d $opt", '        echo -E "$opt/"', "      else", '        echo -E "$opt"', "      end", "    end", "end", "", "complete --no-files --command " + (progn + (" --arguments '(_" + (progn + ")'")))]);
  };
};
var bashCompletionScript = function(prog) {
  return function(progn) {
    return pure26(["_" + (progn + "()"), "{", "    local CMDLINE", "    local IFS=$'\\n'", "    CMDLINE=(--bash-completion-index $COMP_CWORD)", "", "    for arg in ${COMP_WORDS[@]}; do", "        CMDLINE=(${CMDLINE[@]} --bash-completion-word $arg)", "    done", "", "    COMPREPLY=( $(" + (prog + ' "${CMDLINE[@]}") )'), "}", "", "complete -o filenames -F _" + (progn + (" " + progn))]);
  };
};
var arraySplitAt = function(idx) {
  return function(arr) {
    if (idx === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    return {
      init: slice(0)(idx)(arr),
      rest: slice(idx)(length(arr))(arr)
    };
  };
};
var bashCompletionQuery = function(pinfo) {
  return function(pprefs) {
    return function(richness) {
      return function(ws) {
        return function(i) {
          return function(v) {
            var v1 = arraySplitAt(i)(ws);
            var run_completer = function(c) {
              return un7(Completer)(c)(fromMaybe("")(head(v1.rest)));
            };
            var render_line = function(len) {
              return function(doc) {
                var v22 = map35(uncons2)(fromArray(lines(displayS(renderPretty(1)(len)(doc)))));
                if (v22 instanceof Nothing) {
                  return "";
                }
                ;
                if (v22 instanceof Just && v22.value0.tail.length === 0) {
                  return v22.value0.head;
                }
                ;
                if (v22 instanceof Just) {
                  return v22.value0.head + "...";
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 162, column 27 - line 165, column 43): " + [v22.constructor.name]);
              };
            };
            var is_completion = function() {
              var v22 = head(v1.rest);
              if (v22 instanceof Just) {
                return startsWith(v22.value0);
              }
              ;
              if (v22 instanceof Nothing) {
                return $$const(true);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 175, column 7 - line 177, column 30): " + [v22.constructor.name]);
            }();
            var filter_names = filter(is_completion);
            var show_names = function() {
              var $129 = map113(showOption);
              return function($130) {
                return filter_names($129($130));
              };
            }();
            var compl = runParserInfo2(pinfo)(fromFoldable18(drop(1)(v1.init)));
            var add_opt_help = function(dictFunctor) {
              var map47 = map(dictFunctor);
              return function(opt) {
                if (richness instanceof Standard) {
                  return identity14;
                }
                ;
                if (richness instanceof Enriched) {
                  return map47(function(o) {
                    var h = un7(Chunk)(optHelp(opt));
                    return maybe(o)(function(h$prime) {
                      return o + ("	" + render_line(richness.value0)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 138, column 24 - line 143, column 79): " + [richness.constructor.name]);
              };
            };
            var add_opt_help1 = add_opt_help(functorArray);
            var add_cmd_help = function(dictFunctor) {
              var map47 = map(dictFunctor);
              return function(p) {
                if (richness instanceof Standard) {
                  return identity14;
                }
                ;
                if (richness instanceof Enriched) {
                  return map47(function(cmd) {
                    var h = bind20(p(cmd))(function() {
                      var $131 = un7(Chunk);
                      var $132 = un7(ParserInfo);
                      return function($133) {
                        return $131(function(v22) {
                          return v22.infoProgDesc;
                        }($132($133)));
                      };
                    }());
                    return maybe(cmd)(function(h$prime) {
                      return cmd + ("	" + render_line(richness.value1)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 148, column 22 - line 153, column 85): " + [richness.constructor.name]);
              };
            };
            var add_cmd_help1 = add_cmd_help(functorArray);
            var opt_completions = function(argPolicy) {
              return function(hinfo) {
                return function(opt) {
                  var v22 = un7(Option)(opt).optMain;
                  if (v22 instanceof OptReader) {
                    if (notEq4(argPolicy)(AllPositionals.value)) {
                      return pure26(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure26([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof FlagReader) {
                    if (notEq4(argPolicy)(AllPositionals.value)) {
                      return pure26(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure26([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof ArgReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure26([]);
                    }
                    ;
                    if (otherwise) {
                      return run_completer(un7(CReader)(v22.value0).crCompleter);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof CmdReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure26([]);
                    }
                    ;
                    if (otherwise) {
                      return pure26(add_cmd_help1(v22.value2)(filter_names(v22.value1)));
                    }
                    ;
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 113, column 43 - line 133, column 53): " + [v22.constructor.name]);
                };
              };
            };
            var list_options = function(a) {
              var $134 = map211(fold8);
              var $135 = mapParser(opt_completions(a));
              return function($136) {
                return $134(sequence2($135($136)));
              };
            };
            var v2 = runCompletion(compl)(pprefs);
            if (v2 instanceof Just && v2.value0 instanceof Left) {
              return runExists(function(p) {
                return list_options(v2.value0.value0.value1)(p);
              })(v2.value0.value0.value0.value0);
            }
            ;
            if (v2 instanceof Just && v2.value0 instanceof Right) {
              return run_completer(v2.value0.value0);
            }
            ;
            if (v2 instanceof Nothing) {
              return pure26([]);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 83, column 52 - line 89, column 15): " + [v2.constructor.name]);
          };
        };
      };
    };
  };
};
var bashCompletionParser = function(pinfo) {
  return function(pprefs) {
    var failure = function(opts) {
      return {
        execCompletion: function(progn) {
          return map211(unLines2)(opts(progn));
        }
      };
    };
    var complParser = alt15(map36(failure)(apply10(apply10(map36(bashCompletionQuery(pinfo)(pprefs))(alt15(apply10(apply10(flag$prime(Enriched.create)(append16($$long2("bash-completion-enriched"))(internal)))(option2($$int2)(append16(append16(long1("bash-completion-option-desc-length"))(internal))(value2(40)))))(option2($$int2)(append16(append16(long1("bash-completion-command-desc-length"))(internal))(value2(40)))))(pure111(Standard.value))))(map36(fromFoldable19)(many3(strOption(append16(long1("bash-completion-word"))(internal))))))(option2($$int2)(append16(long1("bash-completion-index"))(internal)))))(alt15(map36(failure)(map36(bashCompletionScript)(strOption(append16(long1("bash-completion-script"))(internal)))))(alt15(map36(failure)(map36(fishCompletionScript)(strOption(append16(long1("fish-completion-script"))(internal)))))(map36(failure)(map36(zshCompletionScript)(strOption(append16(long1("zsh-completion-script"))(internal)))))));
    return complParser;
  };
};

// output/Options.Applicative.Help.Core/index.js
var over6 = /* @__PURE__ */ over()();
var mempty6 = /* @__PURE__ */ mempty(parserHelpMonoid);
var fold9 = /* @__PURE__ */ fold2(monoidArray);
var un8 = /* @__PURE__ */ un();
var chunkMonoid3 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var mempty13 = /* @__PURE__ */ mempty(chunkMonoid3);
var eq15 = /* @__PURE__ */ eq(optVisibilityEq);
var map37 = /* @__PURE__ */ map(functorArray);
var sort2 = /* @__PURE__ */ sort(optNameOrd);
var append9 = /* @__PURE__ */ append(/* @__PURE__ */ chunkSemigroup(docSemigroup));
var map114 = /* @__PURE__ */ map(chunkFunctor);
var listToChunk2 = /* @__PURE__ */ listToChunk(docMonoid);
var identity15 = /* @__PURE__ */ identity(categoryFn);
var map212 = /* @__PURE__ */ map(functorMaybe);
var discard8 = /* @__PURE__ */ discard(discardUnit)(bindMaybe);
var guard5 = /* @__PURE__ */ guard(alternativeMaybe);
var pure27 = /* @__PURE__ */ pure(applicativeMaybe);
var extractChunk3 = /* @__PURE__ */ extractChunk(docMonoid);
var bind21 = /* @__PURE__ */ bind(bindArray);
var pure112 = /* @__PURE__ */ pure(applicativeArray);
var mempty23 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidMaybe(semigroupString))(chunkMonoid3));
var append17 = /* @__PURE__ */ append(semigroupArray);
var eq22 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var OptDescStyle = function(x) {
  return x;
};
var usageHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: chunk
    };
  })(mempty6);
};
var suggestionsHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpUsage: v.helpUsage,
      helpSuggestions: chunk
    };
  })(mempty6);
};
var intersperse2 = function(sep3) {
  var $64 = mapWithIndex2(function(idx) {
    return function(e) {
      var $49 = idx === 0;
      if ($49) {
        return [e];
      }
      ;
      return [sep3, e];
    };
  });
  return function($65) {
    return fold9($64($65));
  };
};
var optDesc = function(pprefs) {
  return function(style) {
    return function(info4) {
      return function(opt) {
        var suffix = function() {
          if (un8(OptHelpInfo)(info4).hinfoMulti) {
            return stringChunk(un8(ParserPrefs)(pprefs).prefMultiSuffix);
          }
          ;
          if (otherwise) {
            return mempty13;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 58, column 7 - line 62, column 17): ");
        }();
        var show_opt = function() {
          if (un8(OptHelpInfo)(info4).hinfoDefault && !un8(OptDescStyle)(style).descOptional) {
            return false;
          }
          ;
          if (eq15(optVisibility(opt))(Hidden.value)) {
            return un8(OptDescStyle)(style).descHidden;
          }
          ;
          if (otherwise) {
            return eq15(optVisibility(opt))(Visible.value);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 51, column 7 - line 57, column 39): ");
        }();
        var ns = optionNames(un8(Option)(opt).optMain);
        var mv = stringChunk(optMetaVar(opt));
        var descs = map37(function($66) {
          return string4(showOption($66));
        })(sort2(ns));
        var render = function(chunk) {
          if (!show_opt) {
            return mempty13;
          }
          ;
          if (isEmpty3(chunk) || !un8(OptDescStyle)(style).descSurround) {
            return append9(chunk)(suffix);
          }
          ;
          if (un8(OptHelpInfo)(info4).hinfoDefault) {
            return append9(map114(brackets)(chunk))(suffix);
          }
          ;
          if ($$null(drop(1)(descs))) {
            return append9(chunk)(suffix);
          }
          ;
          if (otherwise) {
            return append9(map114(parens2)(chunk))(suffix);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 63, column 7 - line 73, column 43): " + [chunk.constructor.name]);
        };
        var desc$prime = chunkBeside(listToChunk2(intersperse2(un8(OptDescStyle)(style).descSep)(descs)))(mv);
        return maybe(identity15)(map114)(optDescMod(opt))(render(desc$prime));
      };
    };
  };
};
var headerHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpHeader: chunk
    };
  })(mempty6);
};
var fullDesc = function(pprefs) {
  var style = {
    descSep: string4(","),
    descHidden: true,
    descOptional: true,
    descSurround: false
  };
  var doc = function(info4) {
    return function(opt) {
      var show_def = function(s) {
        return parens2(appendWithSpace(string4("default:"))(string4(s)));
      };
      var n = optDesc(pprefs)(style)(info4)(opt);
      var hdef = map212(show_def)(optShowDefault(opt));
      var h = optHelp(opt);
      return discard8(guard5(!isEmpty3(n)))(function() {
        return discard8(guard5(!isEmpty3(h)))(function() {
          return pure27(new Tuple(extractChunk3(n), align(extractChunk3(chunkBeside(h)(hdef)))));
        });
      });
    };
  };
  var $67 = mapParser(doc);
  return function($68) {
    return tabulate(catMaybes($67($68)));
  };
};
var footerHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpFooter: chunk
    };
  })(mempty6);
};
var fold_tree = function(v) {
  if (v instanceof Leaf2) {
    return v.value0;
  }
  ;
  if (v instanceof MultNode) {
    return foldr2(function($69) {
      return chunkBesideOrBelow(fold_tree($69));
    })(mempty13)(v.value0);
  }
  ;
  if (v instanceof AltNode) {
    var alt_node = function(v1) {
      if (v1.length === 1) {
        return v1[0];
      }
      ;
      return map114(parens2)(foldr2(chunked(function(x) {
        return function(y) {
          return appendWithSoftline(x)(appendWithSoftline($$char4("|"))(y));
        };
      }))(mempty13)(v1));
    };
    return alt_node(filter(function($70) {
      return !isEmpty3($70);
    })(map37(fold_tree)(v.value0)));
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 116, column 1 - line 116, column 46): " + [v.constructor.name]);
};
var errorHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpError: chunk
    };
  })(mempty6);
};
var cmdDesc = /* @__PURE__ */ function() {
  var desc = function(v) {
    return function(opt) {
      var v1 = un8(Option)(opt).optMain;
      if (v1 instanceof CmdReader) {
        return new Tuple(v1.value0, tabulate(bind21(reverse(v1.value1))(function(cmd) {
          return bind21(maybe([])(pure112)(map212(function() {
            var $71 = un8(ParserInfo);
            return function($72) {
              return function(v2) {
                return v2.infoProgDesc;
              }($71($72));
            };
          }())(v1.value2(cmd))))(function(d) {
            return pure112(new Tuple(string4(cmd), align(extractChunk3(d))));
          });
        })));
      }
      ;
      return mempty23;
    };
  };
  return mapParser(desc);
}();
var briefDesc$prime = function(showOptional) {
  return function(pprefs) {
    var style = {
      descSep: string4("|"),
      descHidden: false,
      descOptional: showOptional,
      descSurround: true
    };
    var $73 = treeMapParser(optDesc(pprefs)(style));
    return function($74) {
      return fold_tree($73($74));
    };
  };
};
var missingDesc = /* @__PURE__ */ briefDesc$prime(false);
var briefDesc = /* @__PURE__ */ briefDesc$prime(true);
var parserUsage = function(pprefs) {
  return function(p) {
    return function(progn) {
      return hsep([string4("Usage:"), string4(progn), align(extractChunk3(briefDesc(pprefs)(p)))]);
    };
  };
};
var bodyHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpBody: chunk
    };
  })(mempty6);
};
var parserHelp = function(pprefs) {
  return function(p) {
    var with_title = function(title2) {
      return map114(function(v) {
        return appendWithLine(string4(title2))(v);
      });
    };
    var group_title = function(arr) {
      var v = uncons2(arr);
      return with_title(fromMaybe("Available commands:")(fst(v.head)))(vcatChunks(append17([snd(v.head)])(map37(snd)(v.tail))));
    };
    var cs = groupBy(on(eq22)(fst))(cmdDesc(p));
    return bodyHelp(vsepChunks(append17([with_title("Available options:")(fullDesc(pprefs)(p))])(map37(group_title)(cs))));
  };
};

// output/Data.Function.Memoize/index.js
var bind23 = /* @__PURE__ */ bind(bindLazy);
var NatTrie = /* @__PURE__ */ function() {
  function NatTrie2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  NatTrie2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new NatTrie2(value0, value12, value22);
      };
    };
  };
  return NatTrie2;
}();
var tabulateNat = {
  tabulate: /* @__PURE__ */ function() {
    var tabulateImpl = function(f) {
      var walk = function(v) {
        return function(v1) {
          if (v instanceof Nil) {
            return v1.value0;
          }
          ;
          if (v instanceof Cons && !v.value0) {
            return bind23(v1.value1)(walk(v.value1));
          }
          ;
          if (v instanceof Cons && v.value0) {
            return bind23(v1.value2)(walk(v.value1));
          }
          ;
          throw new Error("Failed pattern match at Data.Function.Memoize (line 172, column 7 - line 172, column 60): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      var build = function(n) {
        return new NatTrie(defer2(function(v) {
          return f(n);
        }), defer2(function(v) {
          return build(n * 2 | 0);
        }), defer2(function(v) {
          return build((n * 2 | 0) + 1 | 0);
        }));
      };
      var trie = build(0);
      var bits = function() {
        var bits$prime = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 === 0) {
                $tco_done = true;
                return v;
              }
              ;
              $tco_var_v = new Cons((v1 & 1) !== 0, v);
              $copy_v1 = v1 >>> 1;
              return;
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return bits$prime(Nil.value);
      }();
      var go = function(n) {
        return walk(bits(n))(trie);
      };
      return go;
    };
    return tabulateImpl;
  }()
};
var tabulate2 = function(dict) {
  return dict.tabulate;
};
var tabulateTuple = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(dictTabulate1) {
    var tabulate4 = tabulate2(dictTabulate1);
    return {
      tabulate: function(f) {
        var f$prime = tabulate3(function(a) {
          return tabulate4(function(b) {
            return f(new Tuple(a, b));
          });
        });
        return function(v) {
          return bind23(f$prime(v.value0))(function(g) {
            return g(v.value1);
          });
        };
      }
    };
  };
};
var memoize = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(f) {
    var f1 = tabulate3(f);
    return function($141) {
      return force(f1($141));
    };
  };
};
var memoize2 = function(dictTabulate) {
  var tabulateTuple1 = tabulateTuple(dictTabulate);
  return function(dictTabulate1) {
    var memoize1 = memoize(tabulateTuple1(dictTabulate1));
    return function(f) {
      var f1 = memoize1(uncurry(f));
      return curry(f1);
    };
  };
};

// output/Options.Applicative.Help.Levenshtein/index.js
var $runtime_lazy12 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var memoize22 = /* @__PURE__ */ memoize2(tabulateNat)(tabulateNat);
var minimum3 = /* @__PURE__ */ minimum2(ordInt)(/* @__PURE__ */ foldable1NonEmpty(foldableArray));
var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();
var editDistance = function(dictEq) {
  var eq6 = eq(dictEq);
  return function(xs) {
    return function(ys) {
      var dist = function(v) {
        return function(v1) {
          if (v === 0) {
            return v1;
          }
          ;
          if (v1 === 0) {
            return v;
          }
          ;
          return minimum3(new NonEmpty($lazy_dist$prime(37)(v - 1 | 0)(v1) + 1 | 0, [$lazy_dist$prime(38)(v)(v1 - 1 | 0) + 1 | 0, function() {
            var $14 = eq6(unsafeIndex2(xs)(v - 1 | 0))(unsafeIndex2(ys)(v1 - 1 | 0));
            if ($14) {
              return $lazy_dist$prime(40)(v - 1 | 0)(v1 - 1 | 0);
            }
            ;
            return 1 + $lazy_dist$prime(41)(v - 1 | 0)(v1 - 1 | 0) | 0;
          }()]));
        };
      };
      var $lazy_dist$prime = $runtime_lazy12("dist'", "Options.Applicative.Help.Levenshtein", function() {
        return memoize22(function(a) {
          return function(b) {
            return dist(a)(b);
          };
        });
      });
      var dist$prime = $lazy_dist$prime(31);
      return dist$prime(length(xs))(length(ys));
    };
  };
};

// output/Options.Applicative.Extra/index.js
var un9 = /* @__PURE__ */ un();
var mempty7 = /* @__PURE__ */ mempty(parserHelpMonoid);
var pure28 = /* @__PURE__ */ pure(chunkApplicative);
var unWords2 = /* @__PURE__ */ unWords(foldableArray);
var append10 = /* @__PURE__ */ append(semigroupArray);
var map38 = /* @__PURE__ */ map(chunkFunctor);
var map115 = /* @__PURE__ */ map(functorArray);
var fold10 = /* @__PURE__ */ fold2(monoidArray);
var editDistance2 = /* @__PURE__ */ editDistance(eqChar);
var apply11 = /* @__PURE__ */ apply(chunkApply);
var mempty14 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var fold14 = /* @__PURE__ */ fold2(parserHelpMonoid);
var over7 = /* @__PURE__ */ over()();
var mapFlipped8 = /* @__PURE__ */ mapFlipped(functorEffect);
var bind24 = /* @__PURE__ */ bind(bindMaybe);
var fromEnum8 = /* @__PURE__ */ fromEnum(boundedEnumExitCode);
var pure113 = /* @__PURE__ */ pure(applicativeEffect);
var bind110 = /* @__PURE__ */ bind(bindEffect);
var $$void6 = /* @__PURE__ */ $$void(functorEffect);
var alt16 = /* @__PURE__ */ alt(parserAlt);
var map39 = /* @__PURE__ */ map(parserFunctor);
var runParserInfo3 = /* @__PURE__ */ runParserInfo(pMonadP);
var fromFoldable20 = /* @__PURE__ */ fromFoldable6(foldableArray);
var map43 = /* @__PURE__ */ map(functorEffect);
var renderFailure = function(failure) {
  return function(progn) {
    var v = un9(ParserFailure)(failure)(progn);
    return new Tuple(renderHelp(v.value1.value1.value0)(v.value0), v.value1.value0);
  };
};
var parserFailure = function(pprefs) {
  return function(pinfo) {
    return function(msg) {
      return function(ctx) {
        var with_context = function(arr) {
          return function(i) {
            return function(f) {
              var v = head(arr);
              if (v instanceof Nothing) {
                return f([])(i);
              }
              ;
              if (v instanceof Just) {
                return runExists(function(i$prime) {
                  return f(contextNames(arr))(i$prime);
                })(v.value0.value1);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Extra (line 183, column 28 - line 185, column 73): " + [v.constructor.name]);
            };
          };
        };
        var usage_help = function(progn) {
          return function(names) {
            return function(v) {
              if (msg instanceof InfoMsg) {
                return mempty7;
              }
              ;
              return usageHelp(vcatChunks([pure28(parserUsage(pprefs)(v.infoParser)(unWords2(append10([progn])(names)))), map38(indent(2))(v.infoProgDesc)]));
            };
          };
        };
        var suggestion_help = suggestionsHelp(function() {
          if (msg instanceof UnexpectedError) {
            var opt_completions = function(v) {
              return function(v1) {
                if (v1.optMain instanceof OptReader) {
                  return map115(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof FlagReader) {
                  return map115(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof ArgReader) {
                  return [];
                }
                ;
                if (v1.optMain instanceof CmdReader) {
                  if (v.hinfoUnreachableArgs) {
                    return [];
                  }
                  ;
                  if (otherwise) {
                    return v1.optMain.value1;
                  }
                  ;
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Extra (line 273, column 64 - line 280, column 37): " + [v1.optMain.constructor.name]);
              };
            };
            var possibles = fold10(runExists(function(zz) {
              return mapParser(opt_completions)(zz);
            })(msg.value1.value0));
            var isClose = function(a) {
              return on(editDistance2)(toCharArray)(a)(msg.value0) < 3;
            };
            var good = filter(isClose)(possibles);
            var prose = function() {
              var $81 = length(good) < 2;
              if ($81) {
                return stringChunk("Did you mean this?");
              }
              ;
              return stringChunk("Did you mean one of these?");
            }();
            var suggestions = apply11(map38(appendWithLine)(prose))(map38(indent(4))(vcatChunks(map115(stringChunk)(good))));
            return suggestions;
          }
          ;
          return mempty14;
        }());
        var show_full_help = function() {
          if (msg instanceof ShowHelpText) {
            return true;
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return true;
          }
          ;
          return un9(ParserPrefs)(pprefs).prefShowHelpOnError;
        }();
        var exit_code = function() {
          if (msg instanceof ErrorMsg) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof MissingError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof UnexpectedError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ShowHelpText) {
            return Success.value;
          }
          ;
          if (msg instanceof InfoMsg) {
            return Success.value;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 171, column 17 - line 177, column 44): " + [msg.constructor.name]);
        }();
        var error_help = errorHelp(function() {
          if (msg instanceof ShowHelpText) {
            return mempty14;
          }
          ;
          if (msg instanceof ErrorMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof InfoMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return mempty14;
          }
          ;
          if (msg instanceof MissingError) {
            return runExists(function(x) {
              return chunkBeside(stringChunk("Missing:"))(missingDesc(pprefs)(x));
            })(msg.value1.value0);
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return stringChunk("The option `" + (msg.value0 + "` expects an argument."));
          }
          ;
          if (msg instanceof UnexpectedError) {
            var msg$prime = function() {
              var $105 = startsWith("-")(msg.value0);
              if ($105) {
                return "Invalid option `" + (msg.value0 + "'");
              }
              ;
              return "Invalid argument `" + (msg.value0 + "'");
            }();
            return stringChunk(msg$prime);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 196, column 30 - line 225, column 30): " + [msg.constructor.name]);
        }());
        var base_help = function(v) {
          var h = headerHelp(v.infoHeader);
          var f = footerHelp(v.infoFooter);
          if (show_full_help) {
            return fold14([h, f, parserHelp(pprefs)(v.infoParser)]);
          }
          ;
          return mempty7;
        };
        return function(progn) {
          var h = with_context(ctx)(pinfo)(function(names) {
            return function(pinfo$prime) {
              return fold14([base_help(pinfo$prime), usage_help(progn)(names)(pinfo$prime), suggestion_help, error_help]);
            };
          });
          return new Tuple(h, new Tuple(exit_code, new Tuple(un9(ParserPrefs)(pprefs).prefColumns, unit)));
        };
      };
    };
  };
};
var helper = /* @__PURE__ */ function() {
  return abortOption(ShowHelpText.value)(fold2(modMonoid)([$$long(optionFieldsHasName)("help"), $$short(optionFieldsHasName)("h"), help("Show this help text"), hidden]));
}();
var getProgName = /* @__PURE__ */ mapFlipped8(argv)(function(args) {
  return fromMaybe("")(bind24(index(args)(1))(function(executablePath) {
    return last(split("/")(executablePath));
  }));
});
var getArgs = /* @__PURE__ */ mapFlipped8(argv)(/* @__PURE__ */ drop(2));
var exitWith = function(c) {
  return exit$prime(fromEnum8(c));
};
var exitSuccess = /* @__PURE__ */ function() {
  return exit$prime(fromEnum8(Success.value));
}();
var handleParseResult = function(v) {
  if (v instanceof Success2) {
    return pure113(v.value0);
  }
  ;
  if (v instanceof Failure) {
    return function __do() {
      var progn = getProgName();
      var v1 = renderFailure(v.value0)(progn);
      var stream2 = function() {
        if (v1.value1 instanceof Success) {
          return stdout;
        }
        ;
        return stderr;
      }();
      $$void6(writeString(stream2)(UTF8.value)(v1.value0 + "\n"))();
      return exitWith(v1.value1)();
    };
  }
  ;
  if (v instanceof CompletionInvoked) {
    return function __do() {
      var progn = getProgName();
      var msg = un9(CompletionResult)(v.value0).execCompletion(progn)();
      $$void6(writeString(stdout)(UTF8.value)(msg))();
      return exitSuccess();
    };
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Extra (line 110, column 1 - line 110, column 58): " + [v.constructor.name]);
};
var execParserPure = function(pprefs) {
  return function(pinfo) {
    return function(args) {
      var pinfo$prime = over7(ParserInfo)(function(i) {
        return {
          infoFailureCode: i.infoFailureCode,
          infoFooter: i.infoFooter,
          infoFullDesc: i.infoFullDesc,
          infoHeader: i.infoHeader,
          infoPolicy: i.infoPolicy,
          infoProgDesc: i.infoProgDesc,
          infoParser: alt16(map39(Left.create)(bashCompletionParser(pinfo)(pprefs)))(map39(Right.create)(i.infoParser))
        };
      })(pinfo);
      var p = runParserInfo3(pinfo$prime)(fromFoldable20(args));
      var v = runP2(p)(pprefs);
      if (v.value0 instanceof Right && v.value0.value0 instanceof Right) {
        return new Success2(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Right && v.value0.value0 instanceof Left) {
        return new CompletionInvoked(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Left) {
        return new Failure(parserFailure(pprefs)(pinfo)(v.value0.value0)(v.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Extra (line 144, column 3 - line 147, column 73): " + [v.constructor.name]);
    };
  };
};
var customExecParser = function(pprefs) {
  return function(pinfo) {
    return bind110(map43(execParserPure(pprefs)(pinfo))(getArgs))(handleParseResult);
  };
};

// output/Whine.Runner.Cli/index.js
var fold11 = /* @__PURE__ */ fold(foldableArray);
var fold15 = /* @__PURE__ */ fold11(modMonoid);
var $$long3 = /* @__PURE__ */ $$long(flagFieldsHasName);
var $$short2 = /* @__PURE__ */ $$short(flagFieldsHasName);
var optional4 = /* @__PURE__ */ optional3(parserAlt)(parserApplicative);
var long12 = /* @__PURE__ */ $$long(optionFieldsHasName);
var apply14 = /* @__PURE__ */ apply(parserApply);
var map40 = /* @__PURE__ */ map(parserFunctor);
var fromFoldable21 = /* @__PURE__ */ fromFoldable2(foldableList);
var append18 = /* @__PURE__ */ append(prefsModSemigroup);
var Short = /* @__PURE__ */ function() {
  function Short2() {
  }
  ;
  Short2.value = new Short2();
  return Short2;
}();
var Long = /* @__PURE__ */ function() {
  function Long2() {
  }
  ;
  Long2.value = new Long2();
  return Long2;
}();
var CheckOnSave = /* @__PURE__ */ function() {
  function CheckOnSave2() {
  }
  ;
  CheckOnSave2.value = new CheckOnSave2();
  return CheckOnSave2;
}();
var CheckOnChange = /* @__PURE__ */ function() {
  function CheckOnChange2() {
  }
  ;
  CheckOnChange2.value = new CheckOnChange2();
  return CheckOnChange2;
}();
var JustWhine = /* @__PURE__ */ function() {
  function JustWhine2(value0) {
    this.value0 = value0;
  }
  ;
  JustWhine2.create = function(value0) {
    return new JustWhine2(value0);
  };
  return JustWhine2;
}();
var LanguageServer = /* @__PURE__ */ function() {
  function LanguageServer2(value0) {
    this.value0 = value0;
  }
  ;
  LanguageServer2.create = function(value0) {
    return new LanguageServer2(value0);
  };
  return LanguageServer2;
}();
var versionFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold15([/* @__PURE__ */ $$long3("version"), /* @__PURE__ */ $$short2("v"), /* @__PURE__ */ help("Print Whine version")]));
var quietFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold15([/* @__PURE__ */ $$long3("quiet"), /* @__PURE__ */ $$short2("q"), /* @__PURE__ */ help("Print no output")]));
var outputFormatOption = /* @__PURE__ */ function() {
  var parseOutputFormat = eitherReader(function(s) {
    var $29 = s === "short";
    if ($29) {
      return new Right(Short.value);
    }
    ;
    var $30 = s === "long";
    if ($30) {
      return new Right(Long.value);
    }
    ;
    return new Left("Invalid output format: " + s);
  });
  return optional4(option2(parseOutputFormat)(fold15([long12("output"), $$short(optionFieldsHasName)("o"), help("Output format. Possible values are 'short' and 'long'. Default is 'long'.")])));
}();
var justWhineArgsParser = /* @__PURE__ */ apply14(/* @__PURE__ */ map40(function(v) {
  return function(v1) {
    return {
      globs: fromFoldable21(mapMaybe2(fromString4)(v)),
      outputFormat: fromMaybe(Long.value)(v1)
    };
  };
})(/* @__PURE__ */ many3(/* @__PURE__ */ strArgument(/* @__PURE__ */ fold15([/* @__PURE__ */ metavar(argumentFieldsHasMetavar)("GLOB"), /* @__PURE__ */ help("Glob patterns to match files to lint. When empty, all files are linted.")])))))(outputFormatOption);
var determineLogLevel = function(args) {
  if (args.debug) {
    return LogDebug.value;
  }
  ;
  if (args.quiet) {
    return LogError.value;
  }
  ;
  return LogInfo.value;
};
var debugFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold15([/* @__PURE__ */ $$long3("debug"), /* @__PURE__ */ help("Print debug output")]));
var checkWhenOption = /* @__PURE__ */ function() {
  var checkWhen = eitherReader(function(s) {
    var $35 = s === "save";
    if ($35) {
      return new Right(CheckOnSave.value);
    }
    ;
    var $36 = s === "change";
    if ($36) {
      return new Right(CheckOnChange.value);
    }
    ;
    return new Left("Invalid value: " + s);
  });
  return optional4(option2(checkWhen)(fold15([long12("check-on"), help(fold11(monoidString)(["When to check files for violations. Possible values are ", "'", "save", "' to check when a file is saved or ", "'", "change", "' to check on every change. ", "Default is '", "save", "'."]))])));
}();
var languageServerArgsParser = /* @__PURE__ */ apply14(/* @__PURE__ */ apply14(/* @__PURE__ */ apply14(/* @__PURE__ */ map40(function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        return {
          checkWhen: fromMaybe(CheckOnSave.value)(v3)
        };
      };
    };
  };
})(/* @__PURE__ */ $$switch(/* @__PURE__ */ $$long3("stdio"))))(/* @__PURE__ */ $$switch(/* @__PURE__ */ $$long3("node-ipc"))))(/* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ long12("socket")))))(checkWhenOption);
var commandParser = /* @__PURE__ */ function() {
  return subparser(command("language-server")(info3(map40(LanguageServer.create)(languageServerArgsParser))(progDesc("Start Whine in Language Server mode"))));
}();
var argsParser = /* @__PURE__ */ function() {
  return apply14(apply14(apply14(map40(function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return {
            command: v,
            version: v1,
            debug: v2,
            quiet: v3
          };
        };
      };
    };
  })(alt(parserAlt)(commandParser)(map40(JustWhine.create)(justWhineArgsParser))))(versionFlag))(debugFlag))(quietFlag);
}();
var parseCliArgs = function(dictMonadEffect) {
  return liftEffect(dictMonadEffect)(customExecParser(prefs(append18(showHelpOnError)(subparserInline)))(info3(apply14(helper)(argsParser))(progDesc("PureScript linter, extensible, with configurable rules, and one-off escape hatches"))));
};

// output/Whine.Print/index.js
var mapFlipped9 = /* @__PURE__ */ mapFlipped(functorMaybe);
var fold16 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var show8 = /* @__PURE__ */ show(showInt);
var bind25 = /* @__PURE__ */ bind(bindMaybe);
var bind111 = /* @__PURE__ */ bind(bindArray);
var pure29 = /* @__PURE__ */ pure(applicativeMaybe);
var printViolation = function(v) {
  return function(v1) {
    if (v1.muted) {
      return Nothing.value;
    }
    ;
    var locationText = fromMaybe(" ")(mapFlipped9(v1.source)(function(r) {
      return fold16([show8(r.start.line + 1 | 0), ":", show8(r.start.column + 1 | 0), ": "]);
    }));
    var sourceText = fromMaybe("")(bind25(v1.source)(function(loc) {
      return bind25(v1.file.lines)(function(lines2) {
        var maxLineNumWidth = length5(show8(loc.end.line + 1 | 0));
        var locLines = take((loc.end.line - loc.start.line | 0) + 1 | 0)(drop(loc.start.line)(lines2));
        var snippet = bind111(zip(locLines)(range2(loc.start.line)(loc.end.line)))(function(v2) {
          return ["  ", "  ", padStart$prime(maxLineNumWidth)(show8(v2.value1 + 1 | 0)), ": ", v2.value0, "\n"];
        });
        return pure29(fold16(cons("\n")(snippet)));
      });
    }));
    var text2 = function() {
      var sourceCode = withGraphics(foreground(BrightYellow.value))(sourceText);
      var ruleAndMessage = fold16([withGraphics(foreground(Red.value))(v1.rule), ": ", v1.message]);
      var fileLocation = fold16([withGraphics(foreground(Cyan.value))(v1.file.path), ":", locationText]);
      if (v.outputFormat instanceof Short) {
        return fileLocation + (" " + ruleAndMessage);
      }
      ;
      if (v.outputFormat instanceof Long) {
        return fileLocation + (" " + (ruleAndMessage + ("\n" + sourceCode)));
      }
      ;
      throw new Error("Failed pattern match at Whine.Print (line 19, column 7 - line 21, column 76): " + [v.outputFormat.constructor.name]);
    }();
    return new Just(text2);
  };
};

// output/Whine.Runner.PackageVersion/index.js
var bind26 = /* @__PURE__ */ bind(bindParserT);
var discard9 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var $$void7 = /* @__PURE__ */ $$void(functorParserT);
var pure30 = /* @__PURE__ */ pure(applicativeParserT);
var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);
var fold17 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var show9 = /* @__PURE__ */ show(showInt);
var ExactVersion = /* @__PURE__ */ function() {
  function ExactVersion2(value0) {
    this.value0 = value0;
  }
  ;
  ExactVersion2.create = function(value0) {
    return new ExactVersion2(value0);
  };
  return ExactVersion2;
}();
var VersionRange = /* @__PURE__ */ function() {
  function VersionRange2(value0) {
    this.value0 = value0;
  }
  ;
  VersionRange2.create = function(value0) {
    return new VersionRange2(value0);
  };
  return VersionRange2;
}();
var versionParser = /* @__PURE__ */ function() {
  var versionNumber = bind26(intDecimal)(function(major) {
    return discard9($$void7($$char2(".")))(function() {
      return bind26(intDecimal)(function(minor) {
        return discard9($$void7($$char2(".")))(function() {
          return bind26(intDecimal)(function(patch) {
            var $23 = major < 0 || (minor < 0 || patch < 0);
            if ($23) {
              return fail2("");
            }
            ;
            return pure30({
              major,
              minor,
              patch
            });
          });
        });
      });
    });
  });
  var range3 = discard9($$void7(string2(">=")))(function() {
    return bind26(versionNumber)(function(from3) {
      return discard9($$void7(string2("<")))(function() {
        return bind26(versionNumber)(function(to2) {
          return pure30(new VersionRange({
            from: from3,
            to: to2
          }));
        });
      });
    });
  });
  var exact = map(functorParserT)(ExactVersion.create)(versionNumber);
  return alt(altParserT)(exact)(range3);
}();
var parseVersion = function(v) {
  return lmap4($$const("Malformed package version"))(runParser(v)(versionParser));
};
var formatVersionNumber = function(v) {
  return fold17([show9(v.major), ".", show9(v.minor), ".", show9(v.patch)]);
};
var formatVersionRange = function(v) {
  return ">=" + (formatVersionNumber(v.from) + (" <" + formatVersionNumber(v.to)));
};
var formatVersion = function(v) {
  if (v instanceof ExactVersion) {
    return formatVersionNumber(v.value0);
  }
  ;
  if (v instanceof VersionRange) {
    return formatVersionRange(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Whine.Runner.PackageVersion (line 16, column 17 - line 18, column 41): " + [v.constructor.name]);
};

// output/Whine.Runner.Yaml/foreign.js
var import_yaml = __toESM(require_dist(), 1);
var parseYaml_ = (left, right, text2) => {
  try {
    return right(import_yaml.default.parse(text2));
  } catch (error5) {
    return left(error5.message);
  }
};
var stringify = import_yaml.default.stringify;

// output/Whine.Runner.Yaml/index.js
var parseYaml = /* @__PURE__ */ function() {
  return runFn3(parseYaml_)(Left.create)(Right.create);
}();

// output/Whine.Runner.Config/index.js
var map41 = /* @__PURE__ */ map(functorFn);
var fromFoldable22 = /* @__PURE__ */ fromFoldable5(ordString)(foldableArray);
var lookup10 = /* @__PURE__ */ lookup3(ordString);
var bind27 = /* @__PURE__ */ bind(bindMaybe);
var discard10 = /* @__PURE__ */ discard(discardUnit);
var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindMaybe);
var lmap5 = /* @__PURE__ */ lmap(bifunctorEither);
var mapFlipped10 = /* @__PURE__ */ mapFlipped(functorEither);
var bind112 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
var toUnfoldable12 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var pure31 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
var throwError5 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadIdentity));
var alt17 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var $$try7 = /* @__PURE__ */ $$try(monadErrorEffect);
var bind28 = /* @__PURE__ */ bind(bindEither);
var merge3 = /* @__PURE__ */ merge()();
var JustPackage = /* @__PURE__ */ function() {
  function JustPackage2() {
  }
  ;
  JustPackage2.value = new JustPackage2();
  return JustPackage2;
}();
var PackageVersion = /* @__PURE__ */ function() {
  function PackageVersion2(value0) {
    this.value0 = value0;
  }
  ;
  PackageVersion2.create = function(value0) {
    return new PackageVersion2(value0);
  };
  return PackageVersion2;
}();
var LocalPackage = /* @__PURE__ */ function() {
  function LocalPackage2(value0) {
    this.value0 = value0;
  }
  ;
  LocalPackage2.create = function(value0) {
    return new LocalPackage2(value0);
  };
  return LocalPackage2;
}();
var parseRuleConfigs = function(dictMonadReport) {
  var Monad0 = dictMonadReport.Monad0();
  var Bind1 = Monad0.Bind1();
  var Functor0 = Bind1.Apply0().Functor0();
  var map117 = map(Functor0);
  var Applicative0 = Monad0.Applicative0();
  var $$for2 = $$for(Applicative0)(traversableArray);
  var pure114 = pure(Applicative0);
  var discard15 = discard10(Bind1);
  var reportViolation2 = reportViolation(dictMonadReport);
  var bind32 = bind(Bind1);
  var mapFlipped15 = mapFlipped(Functor0);
  return function(factories) {
    return function(config2) {
      return map117(map41(fromFoldable22)(catMaybes))($$for2(factories)(function(v) {
        var ruleConfig = lookup10(v.value0)(config2);
        var ruleConfigAsMap = bind27(ruleConfig)(function() {
          var $131 = decode2(strMap(json));
          return function($132) {
            return hush($131($132));
          };
        }());
        var orFail = function(message2) {
          return function(v1) {
            if (v1 instanceof Right) {
              return pure114(new Just(v1.value0));
            }
            ;
            if (v1 instanceof Left) {
              return discard15(reportViolation2({
                rule: v.value0,
                source: Nothing.value,
                message: message2 + (": " + v1.value0)
              }))(function() {
                return pure114(Nothing.value);
              });
            }
            ;
            throw new Error("Failed pattern match at Whine.Runner.Config (line 83, column 28 - line 88, column 27): " + [v1.constructor.name]);
          };
        };
        var commonProp = function(name3) {
          return function(codec4) {
            var v1 = bindFlipped4(lookup10(name3))(ruleConfigAsMap);
            if (v1 instanceof Nothing) {
              return pure114(Nothing.value);
            }
            ;
            if (v1 instanceof Just) {
              return orFail("Malformed '" + (name3 + "'"))(lmap5(print3)(decode2(codec4)(v1.value0)));
            }
            ;
            throw new Error("Failed pattern match at Whine.Runner.Config (line 91, column 35 - line 95, column 103): " + [v1.constructor.name]);
          };
        };
        return bind32(commonProp("include")(array(nonEmptyString)))(function(include) {
          return bind32(commonProp("exclude")(array(nonEmptyString)))(function(exclude) {
            return bind32(mapFlipped15(commonProp("enabled")($$boolean))(fromMaybe(true)))(function(enabled) {
              if (enabled) {
                return orFail("Malformed config")(mapFlipped10(v.value1(fromMaybe($$null3)(ruleConfig)))(function(rule6) {
                  return new Tuple(v.value0, {
                    rule: rule6,
                    globs: {
                      include: fromMaybe([])(include),
                      exclude: fromMaybe([])(exclude)
                    }
                  });
                }));
              }
              ;
              return pure114(Nothing.value);
            });
          });
        });
      }));
    };
  };
};
var packagesCodec = /* @__PURE__ */ function() {
  var localPackageCodec = strMap(objectStrict(recordPropOptional2({
    reflectSymbol: function() {
      return "module";
    }
  })()(string)(recordProp2({
    reflectSymbol: function() {
      return "local";
    }
  })()(string)(record2))));
  var packageCodec = function() {
    var enc = function(v) {
      if (v.value1 instanceof JustPackage) {
        return encode(string)(v["value0"]["package"]);
      }
      ;
      if (v.value1 instanceof PackageVersion) {
        return encode(strMap(string))(singleton9(v["value0"]["package"])(formatVersion(v.value1.value0)));
      }
      ;
      if (v.value1 instanceof LocalPackage) {
        return encode(localPackageCodec)(singleton9(v["value0"]["package"])({
          local: v.value1.value0.path,
          module: v.value1.value0.module
        }));
      }
      ;
      throw new Error("Failed pattern match at Whine.Runner.Config (line 159, column 9 - line 159, column 74): " + [v.constructor.name]);
    };
    var dec = function(json2) {
      var withVersion = bind112(decode(strMap(string))(json2))(function(m) {
        var v = toUnfoldable12(m);
        if (v.length === 1) {
          var v1 = parseVersion(v[0].value1);
          if (v1 instanceof Right) {
            return pure31(new Tuple({
              "package": v[0].value0
            }, new PackageVersion(v1.value0)));
          }
          ;
          if (v1 instanceof Left) {
            return throwError5(basic(v1.value0));
          }
          ;
          throw new Error("Failed pattern match at Whine.Runner.Config (line 173, column 19 - line 175, column 67): " + [v1.constructor.name]);
        }
        ;
        return throwError5(basic("Malformed package specification"));
      });
      var localPackage = bind112(decode(localPackageCodec)(json2))(function(m) {
        var v = toUnfoldable12(m);
        if (v.length === 1) {
          return pure31(new Tuple({
            "package": v[0].value0
          }, new LocalPackage({
            path: v[0].value1.local,
            module: v[0].value1.module
          })));
        }
        ;
        return throwError5(basic("Malformed package specification"));
      });
      var justPackage = bind112(decode(string)(json2))(function($$package) {
        return pure31(new Tuple({
          "package": $$package
        }, JustPackage.value));
      });
      return alt17(justPackage)(alt17(withVersion)(localPackage));
    };
    return codec$prime(dec)(enc);
  }();
  return dimap(profunctorCodec(functorExceptT(functorIdentity)))(toUnfoldable12)(fromFoldable5(ordRecord()(ordRecordCons(ordRecordNil)()({
    reflectSymbol: function() {
      return "package";
    }
  })(ordString)))(foldableArray))(array(packageCodec));
}();
var defaultConfig = /* @__PURE__ */ function() {
  return {
    rulePackages: singleton9({
      "package": "whine-core"
    })(JustPackage.value),
    include: Nothing.value,
    exclude: Nothing.value,
    rules: Nothing.value
  };
}();
var configCodec = /* @__PURE__ */ objectStrict(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "rules";
  }
})()(/* @__PURE__ */ strMap(json))(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "exclude";
  }
})()(/* @__PURE__ */ array(nonEmptyString))(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "include";
  }
})()(/* @__PURE__ */ array(nonEmptyString))(/* @__PURE__ */ recordProp2({
  reflectSymbol: function() {
    return "rulePackages";
  }
})()(packagesCodec)(record2)))));
var readConfig = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var Bind1 = Monad0.Bind1();
  var bindWhineM3 = bindWhineM(Bind1);
  var bind32 = bind(bindWhineM3);
  var map117 = map(functorWhineM(Bind1.Apply0().Functor0()));
  var liftEffect3 = liftEffect(monadEffectWhineM(dictMonadEffect));
  var discard15 = discard10(bindWhineM3);
  var monadReportWhineM2 = monadReportWhineM(Monad0);
  var reportViolation2 = reportViolation(monadReportWhineM2);
  var pure114 = pure(applicativeWhineM(Monad0.Applicative0()));
  var mapViolations3 = mapViolations(Monad0);
  var parseRuleConfigs1 = parseRuleConfigs(monadReportWhineM2);
  return function(factories) {
    return function(configFile) {
      return bind32(map117(lmap5(message))(liftEffect3($$try7(readTextFile(UTF8.value)(configFile)))))(function(text2) {
        return bind32(function() {
          var v = bind28(bind28(text2)(parseYaml))(function() {
            var $133 = lmap5(print3);
            var $134 = decode2(configCodec);
            return function($135) {
              return $133($134($135));
            };
          }());
          if (v instanceof Left) {
            return discard15(reportViolation2({
              message: "Error reading config: " + v.value0,
              source: Nothing.value,
              file: {
                path: configFile,
                lines: Nothing.value
              },
              muted: false,
              rule: ""
            }))(function() {
              return pure114(defaultConfig);
            });
          }
          ;
          if (v instanceof Right) {
            return pure114(v.value0);
          }
          ;
          throw new Error("Failed pattern match at Whine.Runner.Config (line 120, column 13 - line 132, column 13): " + [v.constructor.name]);
        }())(function(config2) {
          return bind32(mapViolations3(merge3({
            file: {
              path: configFile,
              lines: Nothing.value
            },
            muted: false
          }))(parseRuleConfigs1(factories)(fromMaybe(empty4)(config2.rules))))(function(res) {
            return pure114({
              rules: res,
              files: {
                include: fromMaybe(mapMaybe(fromString4)(["src/**/*.purs", "test/**/*.purs"]))(config2.include),
                exclude: fromMaybe([])(config2.exclude)
              }
            });
          });
        });
      });
    };
  };
};

// output/Elmish.Foreign/foreign.js
function isObject(s) {
  return s instanceof Object;
}
function showForeign(x) {
  return x === null ? "<null>" : x === void 0 ? "<undefined>" : x instanceof Date ? x.toString() : typeof Blob !== "undefined" && x instanceof Blob ? "file[" + x.name + "]" : JSON.stringify(x);
}

// output/Elmish.Foreign/index.js
var fold18 = /* @__PURE__ */ fold2(monoidString);
var Valid = /* @__PURE__ */ function() {
  function Valid2() {
  }
  ;
  Valid2.value = new Valid2();
  return Valid2;
}();
var Invalid = /* @__PURE__ */ function() {
  function Invalid2(value0) {
    this.value0 = value0;
  }
  ;
  Invalid2.create = function(value0) {
    return new Invalid2(value0);
  };
  return Invalid2;
}();
var canReceiveFromJavaScriptR = {
  validateJsRecord: function(v) {
    return Valid.value;
  }
};
var validateJsRecord = function(dict) {
  return dict.validateJsRecord;
};
var canReceiveFromJavaScriptR1 = function() {
  return function(dictCanReceiveFromJavaScriptRecord) {
    var validateJsRecord1 = validateJsRecord(dictCanReceiveFromJavaScriptRecord);
    return {
      validateForeignType: function(v) {
        if (isObject(v)) {
          return validateJsRecord1(v);
        }
        ;
        if (otherwise) {
          return new Invalid({
            path: "",
            expected: "Object",
            got: v
          });
        }
        ;
        throw new Error("Failed pattern match at Elmish.Foreign (line 209, column 1 - line 212, column 69): " + [v.constructor.name]);
      }
    };
  };
};
var validateForeignType = function(dict) {
  return dict.validateForeignType;
};
var canReceiveFromJavaScriptR3 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function(dictCanReceiveFromJavaScript) {
    var validateForeignType1 = validateForeignType(dictCanReceiveFromJavaScript);
    return function(dictCanReceiveFromJavaScriptRecord) {
      var validateJsRecord1 = validateJsRecord(dictCanReceiveFromJavaScriptRecord);
      return {
        validateJsRecord: function(v) {
          var fieldName = reflectSymbol2($$Proxy.value);
          var head4 = unsafeGet(fieldName)(unsafeFromForeign(v));
          var validHead = validateForeignType1(head4);
          if (validHead instanceof Invalid) {
            return new Invalid({
              expected: validHead.value0.expected,
              got: validHead.value0.got,
              path: "." + (fieldName + validHead.value0.path)
            });
          }
          ;
          if (validHead instanceof Valid) {
            return validateJsRecord1(v);
          }
          ;
          throw new Error("Failed pattern match at Elmish.Foreign (line 235, column 9 - line 237, column 43): " + [validHead.constructor.name]);
        }
      };
    };
  };
};
var readForeign$prime = function(dictCanReceiveFromJavaScript) {
  var validateForeignType1 = validateForeignType(dictCanReceiveFromJavaScript);
  return function(v) {
    var v1 = validateForeignType1(v);
    if (v1 instanceof Valid) {
      return new Right(unsafeFromForeign(v));
    }
    ;
    if (v1 instanceof Invalid) {
      return new Left(fold18([v1.value0.path, function() {
        var $123 = v1.value0.path === "";
        if ($123) {
          return "Expected ";
        }
        ;
        return ": expected ";
      }(), v1.value0.expected, " but got: ", showForeign(v1.value0.got)]));
    }
    ;
    throw new Error("Failed pattern match at Elmish.Foreign (line 255, column 18 - line 263, column 6): " + [v1.constructor.name]);
  };
};

// output/Untagged.Castable/index.js
var cast = function() {
  return unsafeCoerce2;
};

// output/Vscode.Events/foreign.js
var unsafeOn2 = (event, handler, target) => target[`on${event}`](handler);

// output/Vscode.Events/index.js
var throwError6 = /* @__PURE__ */ throwError(monadThrowEffect);
var map44 = /* @__PURE__ */ map(functorEffect);
var EventHandle2 = function(x) {
  return x;
};
var on2 = function(dictMonadEffect) {
  var liftEffect3 = liftEffect(dictMonadEffect);
  return function(dictCanReceiveFromJavaScript) {
    var readForeign$prime2 = readForeign$prime(dictCanReceiveFromJavaScript);
    return function() {
      return function(v) {
        return function(f) {
          var $14 = runEffectFn3(unsafeOn2)(v)(mkEffectFn1(function() {
            var $16 = either(function($18) {
              return throwError6(error2($18));
            })(function() {
              var $19 = map44(unsafeToForeign);
              return function($20) {
                return $19(f($20));
              };
            }());
            return function($17) {
              return $16(readForeign$prime2($17));
            };
          }()));
          return function($15) {
            return liftEffect3($14($15));
          };
        };
      };
    };
  };
};
var eventHandle = function(dictCanReceiveFromJavaScript) {
  return function() {
    return EventHandle2;
  };
};

// output/Vscode.Server.Capabilities/index.js
var textDocumentSyncKind = {
  none: 0,
  full: 1,
  incremental: 2
};

// output/Vscode.Server.Connection/foreign.js
var import_node = __toESM(require_node3(), 1);
var createConnection_ = () => import_node.default.createConnection(import_node.default.ProposedFeatures.all);
var sendDiagnostics_ = (params) => (conn) => conn.sendDiagnostics(params);
var listen_ = (conn) => () => conn.listen();

// output/Control.Promise/foreign.js
function thenImpl(promise2) {
  return function(errCB) {
    return function(succCB) {
      return function() {
        promise2.then(succCB, errCB);
      };
    };
  };
}

// output/Control.Promise/index.js
var voidRight4 = /* @__PURE__ */ voidRight(functorEffect);
var mempty8 = /* @__PURE__ */ mempty(monoidCanceler);
var identity16 = /* @__PURE__ */ identity(categoryFn);
var alt18 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var unsafeReadTagged2 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
var map45 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var readString3 = /* @__PURE__ */ readString(monadIdentity);
var toAff$prime = function(customCoerce) {
  return function(p) {
    return makeAff(function(cb) {
      return voidRight4(mempty8)(thenImpl(p)(function($14) {
        return cb(Left.create(customCoerce($14)))();
      })(function($15) {
        return cb(Right.create($15))();
      }));
    });
  };
};
var coerce6 = function(fn) {
  return either(function(v) {
    return error2("Promise failed, couldn't extract JS Error or String");
  })(identity16)(runExcept(alt18(unsafeReadTagged2("Error")(fn))(map45(error2)(readString3(fn)))));
};
var toAff = /* @__PURE__ */ toAff$prime(coerce6);

// output/Vscode.Server.Connection/index.js
var sendDiagnostics = function(dictMonadAff) {
  var liftAff2 = liftAff(dictMonadAff);
  return function(args) {
    var $11 = sendDiagnostics_(args);
    return function($12) {
      return liftAff2(toAff($11($12)));
    };
  };
};
var listen2 = function(dictMonadEffect) {
  var $13 = liftEffect(dictMonadEffect);
  return function($14) {
    return $13(listen_($14));
  };
};
var initialize = /* @__PURE__ */ eventHandle(/* @__PURE__ */ canReceiveFromJavaScriptR1()(canReceiveFromJavaScriptR))()("Initialize");
var createConnection = function(dictMonadEffect) {
  return liftEffect(dictMonadEffect)(createConnection_);
};

// output/Vscode.Server.Diagnostic/index.js
var diagnosticSeverity = {
  error: 1,
  warning: 2,
  information: 3,
  hint: 4
};

// output/Vscode.Server.TextDocuments/foreign.js
var import_node2 = __toESM(require_node3(), 1);

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument = class _FullTextDocument {
  constructor(uri2, languageId, version2, content) {
    this._uri = uri2;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range3) {
    if (range3) {
      const start = this.offsetAt(range3.start);
      const end = this.offsetAt(range3.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version2) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range3 = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range3.start);
        const endOffset = this.offsetAt(range3.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range3.start.line, 0);
        const endLine = Math.max(range3.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version2;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line2 = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line2]);
    return { line: line2, character: offset - lineOffsets[line2] };
  }
  offsetAt(position2) {
    const lineOffsets = this.getLineOffsets();
    if (position2.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position2.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position2.line];
    if (position2.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position2.line + 1 < lineOffsets.length ? lineOffsets[position2.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position2.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create3(uri2, languageId, version2, content) {
    return new FullTextDocument(uri2, languageId, version2, content);
  }
  TextDocument2.create = create3;
  function update2(document, changes, version2) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version2);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update2;
  function applyEdits(document, edits) {
    const text2 = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text2.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text2.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare5) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare5);
  mergeSort(right, compare5);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare5(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text2, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text2.length; i++) {
    const ch = text2.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text2.length && text2.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char2) {
  return char2 === 13 || char2 === 10;
}
function getWellformedRange(range3) {
  const start = range3.start;
  const end = range3.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range3;
}
function getWellformedEdit(textEdit) {
  const range3 = getWellformedRange(textEdit.range);
  if (range3 !== textEdit.range) {
    return { newText: textEdit.newText, range: range3 };
  }
  return textEdit;
}

// output/Vscode.Server.TextDocuments/foreign.js
var create_ = () => new import_node2.default.TextDocuments(TextDocument);
var listen_2 = (docs, connection) => docs.listen(connection);
var isTextDocument = (d) => !!(d && d.uri && d.languageId && d.version);
var uri = (d) => d.uri;
var getText_ = (d) => d.getText();

// output/Vscode.Server.TextDocuments/index.js
var canReceiveFromJavaScriptT = {
  validateForeignType: function(x) {
    if (isTextDocument(x)) {
      return Valid.value;
    }
    ;
    if (otherwise) {
      return new Invalid({
        path: "",
        expected: "TextDocuments",
        got: x
      });
    }
    ;
    throw new Error("Failed pattern match at Vscode.Server.TextDocuments (line 27, column 1 - line 30, column 74): " + [x.constructor.name]);
  }
};
var eventHandle2 = /* @__PURE__ */ eventHandle(/* @__PURE__ */ canReceiveFromJavaScriptR1()(/* @__PURE__ */ canReceiveFromJavaScriptR3({
  reflectSymbol: function() {
    return "document";
  }
})(canReceiveFromJavaScriptT)(canReceiveFromJavaScriptR)))();
var listen3 = function(dictMonadEffect) {
  var liftEffect3 = liftEffect(dictMonadEffect);
  return function(d) {
    return function(c) {
      return liftEffect3(function() {
        return listen_2(d, c);
      });
    };
  };
};
var getText = function(dictMonadEffect) {
  var $17 = liftEffect(dictMonadEffect);
  var $18 = runEffectFn1(getText_);
  return function($19) {
    return $17($18($19));
  };
};
var didSave = /* @__PURE__ */ eventHandle2("DidSave");
var didOpen = /* @__PURE__ */ eventHandle2("DidOpen");
var didChangeContent = /* @__PURE__ */ eventHandle2("DidChangeContent");
var create = function(dictMonadEffect) {
  return liftEffect(dictMonadEffect)(create_);
};

// output/Whine.Runner.LanguageServer/index.js
var bindWhineM2 = /* @__PURE__ */ bindWhineM(bindAff);
var bind29 = /* @__PURE__ */ bind(bindWhineM2);
var ask2 = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskWhineM(monadAff));
var monadEffectWhineM2 = /* @__PURE__ */ monadEffectWhineM(monadEffectAff);
var createConnection2 = /* @__PURE__ */ createConnection(monadEffectWhineM2);
var discard11 = /* @__PURE__ */ discard(discardUnit)(bindWhineM2);
var on3 = /* @__PURE__ */ on2(monadEffectWhineM2);
var canReceiveFromJavaScriptR12 = /* @__PURE__ */ canReceiveFromJavaScriptR1();
var on1 = /* @__PURE__ */ on3(/* @__PURE__ */ canReceiveFromJavaScriptR12(canReceiveFromJavaScriptR))();
var pure33 = /* @__PURE__ */ pure(applicativeEffect);
var runWhineM2 = /* @__PURE__ */ runWhineM(monadEffectWhineM2);
var mapViolations2 = /* @__PURE__ */ mapViolations(/* @__PURE__ */ monadWhineM(monadAff));
var merge4 = /* @__PURE__ */ merge()();
var readConfig2 = /* @__PURE__ */ readConfig(monadEffectWhineM2);
var unliftWhineM2 = /* @__PURE__ */ unliftWhineM(monadEffectAff);
var mapFlipped11 = /* @__PURE__ */ mapFlipped(functorMaybe);
var logDebug2 = /* @__PURE__ */ logDebug(/* @__PURE__ */ monadLogWhineM(monadEffectAff)(refl))(loggableString);
var getText2 = /* @__PURE__ */ getText(monadEffectWhineM2);
var checkModule2 = /* @__PURE__ */ checkModule(monadEffectWhineM2);
var not6 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var fold19 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var show10 = /* @__PURE__ */ show(showInt);
var unless2 = /* @__PURE__ */ unless(/* @__PURE__ */ applicativeWhineM(applicativeAff));
var sendDiagnostics2 = /* @__PURE__ */ sendDiagnostics(/* @__PURE__ */ monadAffWhineM(monadAffAff));
var mapFlipped12 = /* @__PURE__ */ mapFlipped(functorArray);
var cast2 = /* @__PURE__ */ cast();
var create2 = /* @__PURE__ */ create(monadEffectWhineM2);
var on22 = /* @__PURE__ */ on3(/* @__PURE__ */ canReceiveFromJavaScriptR12(/* @__PURE__ */ canReceiveFromJavaScriptR3({
  reflectSymbol: function() {
    return "document";
  }
})(canReceiveFromJavaScriptT)(canReceiveFromJavaScriptR)))();
var listen4 = /* @__PURE__ */ listen3(monadEffectWhineM2);
var listen1 = /* @__PURE__ */ listen2(monadEffectWhineM2);
var startLanguageServer = function(v) {
  var vsCodePos = function(p) {
    return {
      line: p.line,
      character: p.column
    };
  };
  var firstLineRange = {
    start: {
      line: 0,
      character: 0
    },
    end: {
      line: 1,
      character: 0
    }
  };
  var checkEvent = function() {
    if (v.checkWhen instanceof CheckOnSave) {
      return didSave;
    }
    ;
    if (v.checkWhen instanceof CheckOnChange) {
      return didChangeContent;
    }
    ;
    throw new Error("Failed pattern match at Whine.Runner.LanguageServer (line 85, column 18 - line 87, column 44): " + [v.checkWhen.constructor.name]);
  }();
  return bind29(ask2)(function(env) {
    return bind29(createConnection2)(function(conn) {
      return discard11(on1(initialize)(function(v1) {
        return pure33({
          capabilities: {
            textDocumentSync: textDocumentSyncKind.incremental
          }
        });
      })(conn))(function() {
        return bind29(runWhineM2(env)(mapViolations2(merge4({
          muted: false
        }))(readConfig2(v.factories)(v.configFile))))(function(v1) {
          return bind29(unliftWhineM2(function(document) {
            var uri2 = uri(document);
            var path3 = fromMaybe("")(mapFlipped11(stripPrefix2("file://")(uri2))(relative(dirname(v.configFile))));
            var $62 = test2(v1.value0.files)(path3);
            if ($62) {
              return discard11(logDebug2("Checking file: URI=" + (uri(document) + (", path=" + path3))))(function() {
                return bind29(getText2(document))(function(text2) {
                  return bind29(runWhineM2(env)(checkModule2(v1.value0.rules)({
                    path: path3,
                    text: text2
                  })))(function(v2) {
                    var liveViolations = filter(not6(function(v3) {
                      return v3.muted;
                    }))(v2.value1);
                    return discard11(logDebug2(fold19(["Found violations in ", path3, ": ", show10(length(liveViolations)), " live, ", show10(length(v2.value1) - length(liveViolations) | 0), " muted"])))(function() {
                      return unless2($$null(liveViolations))(sendDiagnostics2({
                        uri: uri2,
                        diagnostics: mapFlipped12(liveViolations)(function(v3) {
                          return cast2({
                            range: fromMaybe(firstLineRange)(mapFlipped11(v3.source)(function(r) {
                              return {
                                start: vsCodePos(r.start),
                                end: vsCodePos(r.end)
                              };
                            })),
                            code: v3.rule,
                            source: "purescript-whine",
                            message: v3.message,
                            severity: diagnosticSeverity.information
                          });
                        })
                      })(conn));
                    });
                  });
                });
              });
            }
            ;
            return logDebug2("Skipping " + (path3 + " because it doesn't match globs in the config"));
          }))(function(checkDocument) {
            return bind29(create2)(function(docs) {
              return discard11(on22(didOpen)(function(v2) {
                return launchAff_(checkDocument(v2.document));
              })(docs))(function() {
                return discard11(on22(checkEvent)(function(v2) {
                  return launchAff_(checkDocument(v2.document));
                })(docs))(function() {
                  return discard11(listen4(docs)(conn))(function() {
                    return discard11(listen1(conn))(function() {
                      return logDebug2("Language Server started");
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Whine.Runner/index.js
var mapFlipped13 = /* @__PURE__ */ mapFlipped(functorMaybe);
var mapFlipped14 = /* @__PURE__ */ mapFlipped(functorEffect);
var traverse5 = /* @__PURE__ */ traverse(traversableArray)(applicativeEffect);
var map46 = /* @__PURE__ */ map(functorEffect);
var mapFlipped22 = /* @__PURE__ */ mapFlipped(functorArray);
var nub3 = /* @__PURE__ */ nub(ordString);
var append19 = /* @__PURE__ */ append(semigroupArray);
var map116 = /* @__PURE__ */ map(functorArray);
var bind113 = /* @__PURE__ */ bind(bindAff);
var parseCliArgs2 = /* @__PURE__ */ parseCliArgs(monadEffectAff);
var discard14 = /* @__PURE__ */ discard(discardUnit)(bindAff);
var unless3 = /* @__PURE__ */ unless(applicativeAff);
var traverse_2 = /* @__PURE__ */ traverse_(applicativeAff)(foldableArray);
var log5 = /* @__PURE__ */ log3(monadEffectAff);
var when4 = /* @__PURE__ */ when(applicativeAff);
var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
var $$void8 = /* @__PURE__ */ $$void(functorAff);
var runWhineM3 = /* @__PURE__ */ runWhineM(monadEffectAff);
var runWhine = function(dictMonadEffect) {
  var liftEffect1 = liftEffect(monadEffectWhineM(dictMonadEffect));
  var Monad0 = dictMonadEffect.Monad0();
  var Bind1 = Monad0.Bind1();
  var map213 = map(Bind1.Apply0().Functor0());
  var runWhineM1 = runWhineM(dictMonadEffect);
  var bind210 = bind(bindWhineM(Bind1));
  var readConfig3 = readConfig(dictMonadEffect);
  var traverse_1 = traverse_(applicativeWhineM(Monad0.Applicative0()))(foldableArray);
  var checkFile2 = checkFile(dictMonadEffect);
  return function(v) {
    var globs$prime = function(config2) {
      return fromMaybe(config2.files)(mapFlipped13(mapFlipped13(v.globs)(toArray))(function(v1) {
        return {
          include: v1,
          exclude: []
        };
      }));
    };
    var gatherFiles = function(globses) {
      return liftEffect1(function __do() {
        var globbed = glob2(globses)();
        var v1 = mapFlipped14(traverse5(function(f) {
          return map46(function(v12) {
            return new Tuple(f, v12);
          })(stat(f));
        })(globbed))(partition(function($62) {
          return isDirectory(snd($62));
        }))();
        var withinDirectories = glob2({
          include: mapMaybe(fromString4)(mapFlipped22(mapFlipped22(v1.yes)(fst))(function(v2) {
            return v2 + "/**/*.purs";
          })),
          exclude: []
        })();
        return nub3(append19(map116(fst)(v1.no))(withinDirectories));
      });
    };
    return map213(snd)(runWhineM1(v.env)(bind210(readConfig3(v.factories)(v.configFile))(function(config2) {
      return bind210(gatherFiles(globs$prime(config2)))(function(files) {
        return traverse_1(checkFile2(config2.rules))(files);
      });
    })));
  };
};
var runWhine1 = /* @__PURE__ */ runWhine(monadEffectAff);
var runWhineAndPrintResultsAndExit = function(factories) {
  return launchAff_(bind113(parseCliArgs2)(function(args) {
    var env = {
      logLevel: determineLogLevel(args)
    };
    if (args.command instanceof JustWhine) {
      return bind113(runWhine1({
        factories,
        globs: args.command.value0.globs,
        configFile: "whine.yaml",
        env
      }))(function(results) {
        var output = nub3(mapMaybe(printViolation(args.command.value0))(results));
        return discard14(unless3(args.quiet)(discard14(traverse_2(log5)(output))(function() {
          return when4($$null(output))(log5("No violations found."));
        })))(function() {
          return liftEffect2(exit$prime(function() {
            var $57 = $$null(output);
            if ($57) {
              return 0;
            }
            ;
            return 1;
          }()));
        });
      });
    }
    ;
    if (args.command instanceof LanguageServer) {
      return $$void8(runWhineM3(env)(startLanguageServer({
        factories,
        configFile: "whine.yaml",
        checkWhen: args.command.value0.checkWhen
      })));
    }
    ;
    throw new Error("Failed pattern match at Whine.Runner (line 29, column 3 - line 40, column 79): " + [args.command.constructor.name]);
  }));
};

// output/Whine.Bootstrap.WhineCoreMain/index.js
var main = /* @__PURE__ */ runWhineAndPrintResultsAndExit(/* @__PURE__ */ append(semigroupArray)(rules2)(rules));

// <stdin>
main();
/*! Bundled license information:

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
