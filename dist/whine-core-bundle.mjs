#!/usr/bin/env node
/* Generated by Spago v0.93.44 */import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));const __filename=new URL(import.meta.url).pathname
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod5) => function __require() {
  return mod5 || (0, cb[__getOwnPropNames(cb)[0]])((mod5 = { exports: {} }).exports, mod5), mod5.exports;
};
var __copyProps = (to2, from3, except3, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to2, key) && key !== except3)
        __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod5, isNodeMode, target) => (target = mod5 != null ? __create(__getProtoOf(mod5)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod5 || !mod5.__esModule ? __defProp(target, "default", { value: mod5, enumerable: true }) : target,
  mod5
));

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity21.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path2) {
      const ctrl = callVisitor(key, node, visitor, path2);
      if (identity21.isNode(ctrl) || identity21.isPair(ctrl)) {
        replaceNode(key, path2, ctrl);
        return visit_(key, ctrl, visitor, path2);
      }
      if (typeof ctrl !== "symbol") {
        if (identity21.isCollection(node)) {
          path2 = Object.freeze(path2.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path2);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity21.isPair(node)) {
          path2 = Object.freeze(path2.concat(node));
          const ck = visit_("key", node.key, visitor, path2);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path2);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity21.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path2) {
      const ctrl = await callVisitor(key, node, visitor, path2);
      if (identity21.isNode(ctrl) || identity21.isPair(ctrl)) {
        replaceNode(key, path2, ctrl);
        return visitAsync_(key, ctrl, visitor, path2);
      }
      if (typeof ctrl !== "symbol") {
        if (identity21.isCollection(node)) {
          path2 = Object.freeze(path2.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path2);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity21.isPair(node)) {
          path2 = Object.freeze(path2.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path2);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path2);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path2) {
      if (typeof visitor === "function")
        return visitor(key, node, path2);
      if (identity21.isMap(node))
        return visitor.Map?.(key, node, path2);
      if (identity21.isSeq(node))
        return visitor.Seq?.(key, node, path2);
      if (identity21.isPair(node))
        return visitor.Pair?.(key, node, path2);
      if (identity21.isScalar(node))
        return visitor.Scalar?.(key, node, path2);
      if (identity21.isAlias(node))
        return visitor.Alias?.(key, node, path2);
      return void 0;
    }
    function replaceNode(key, path2, node) {
      const parent = path2[path2.length - 1];
      if (identity21.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity21.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity21.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity21.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line2, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line2.trim().split(/[ \t]+/);
        const name3 = parts.shift();
        switch (name3) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name3}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source2, onError) {
        if (source2 === "!")
          return "!";
        if (source2[0] !== "!") {
          onError(`Not a valid tag: ${source2}`);
          return null;
        }
        if (source2[1] === "<") {
          const verbatim = source2.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
            return null;
          }
          if (source2[source2.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source2.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source2} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error5) {
            onError(String(error5));
            return null;
          }
        }
        if (handle === "!")
          return source2;
        onError(`Could not resolve tag: ${source2}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines2 = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity21.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity21.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines2.push(`%TAG ${handle} ${prefix}`);
        }
        return lines2.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name3 = `${prefix}${i}`;
        if (!exclude.has(name3))
          return name3;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source2) => {
          aliasObjects.push(source2);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source2 of aliasObjects) {
            const ref2 = sourceObjects.get(source2);
            if (typeof ref2 === "object" && ref2.anchor && (identity21.isScalar(ref2.node) || identity21.isCollection(ref2.node))) {
              ref2.node.anchor = ref2.anchor;
            } else {
              const error5 = new Error("Failed to resolve repeated object (this should not happen)");
              error5.source = source2;
              throw error5;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    function toJS(value3, arg, ctx) {
      if (Array.isArray(value3))
        return value3.map((v, i) => toJS(v, String(i), ctx));
      if (value3 && typeof value3.toJSON === "function") {
        if (!ctx || !identity21.hasAnchor(value3))
          return value3.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value3, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value3.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value3 === "bigint" && !ctx?.keep)
        return Number(value3);
      return value3;
    }
    exports.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity21 = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity21.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity21.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity21 = require_identity();
    var Node2 = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node2.NodeBase {
      constructor(source2) {
        super(identity21.ALIAS);
        this.source = source2;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source2 = this.resolve(doc);
        if (!source2) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source2);
        if (!data) {
          toJS.toJS(source2, null, ctx);
          data = anchors2.get(source2);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source2, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity21.isAlias(node)) {
        const source2 = node.resolve(doc);
        const anchor = anchors2 && source2 && anchors2.get(source2);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity21.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity21.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Node2 = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value3) => !value3 || typeof value3 !== "function" && typeof value3 !== "object";
    var Scalar = class extends Node2.NodeBase {
      constructor(value3) {
        super(identity21.SCALAR);
        this.value = value3;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value3, tagName, tags) {
      if (tagName) {
        const match2 = tags.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) ?? match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value3) && !t.format);
    }
    function createNode(value3, tagName, ctx) {
      if (identity21.isDocument(value3))
        value3 = value3.contents;
      if (identity21.isNode(value3))
        return value3;
      if (identity21.isPair(value3)) {
        const map44 = ctx.schema[identity21.MAP].createNode?.(ctx.schema, null, ctx);
        map44.items.push(value3);
        return map44;
      }
      if (value3 instanceof String || value3 instanceof Number || value3 instanceof Boolean || typeof BigInt !== "undefined" && value3 instanceof BigInt) {
        value3 = value3.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref2 = void 0;
      if (aliasDuplicateObjects && value3 && typeof value3 === "object") {
        ref2 = sourceObjects.get(value3);
        if (ref2) {
          if (!ref2.anchor)
            ref2.anchor = onAnchor(value3);
          return new Alias.Alias(ref2.anchor);
        } else {
          ref2 = { anchor: null, node: null };
          sourceObjects.set(value3, ref2);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value3, tagName, schema.tags);
      if (!tagObj) {
        if (value3 && typeof value3.toJSON === "function") {
          value3 = value3.toJSON();
        }
        if (!value3 || typeof value3 !== "object") {
          const node2 = new Scalar.Scalar(value3);
          if (ref2)
            ref2.node = node2;
          return node2;
        }
        tagObj = value3 instanceof Map ? schema[identity21.MAP] : Symbol.iterator in Object(value3) ? schema[identity21.SEQ] : schema[identity21.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value3, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value3, ctx) : new Scalar.Scalar(value3);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref2)
        ref2.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity21 = require_identity();
    var Node2 = require_Node();
    function collectionFromPath(schema, path2, value3) {
      let v = value3;
      for (let i = path2.length - 1; i >= 0; --i) {
        const k = path2[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && !!path2[Symbol.iterator]().next().done;
    var Collection = class extends Node2.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity21.isNode(it) || identity21.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path2, value3) {
        if (isEmptyPath(path2))
          this.add(value3);
        else {
          const [key, ...rest] = path2;
          const node = this.get(key, true);
          if (identity21.isCollection(node))
            node.addIn(rest, value3);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value3));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path2) {
        const [key, ...rest] = path2;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity21.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path2, keepScalar) {
        const [key, ...rest] = path2;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity21.isScalar(node) ? node.value : node;
        else
          return identity21.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity21.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity21.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path2) {
        const [key, ...rest] = path2;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity21.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path2, value3) {
        const [key, ...rest] = path2;
        if (rest.length === 0) {
          this.set(key, value3);
        } else {
          const node = this.get(key, true);
          if (identity21.isCollection(node))
            node.setIn(rest, value3);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value3));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent2) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent2 ? comment.replace(/^(?! *$)/gm, indent2) : comment;
    }
    var lineComment = (str2, indent2, comment) => str2.endsWith("\n") ? indentComment(comment, indent2) : comment.includes("\n") ? "\n" + indentComment(comment, indent2) : (str2.endsWith(" ") ? "" : " ") + comment;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text2, indent2, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text2;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent2.length);
      if (text2.length <= endStep)
        return text2;
      const folds = [];
      const escapedFolds = {};
      let end2 = lineWidth - indent2.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end2 = lineWidth - indentAtStart;
      }
      let split3 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode2 === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text2, i, indent2.length);
        if (i !== -1)
          end2 = i + endStep;
      }
      for (let ch; ch = text2[i += 1]; ) {
        if (mode2 === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text2[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode2 === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text2, i, indent2.length);
          end2 = i + indent2.length + endStep;
          split3 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next2 = text2[i + 1];
            if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
              split3 = i;
          }
          if (i >= end2) {
            if (split3) {
              folds.push(split3);
              end2 = split3 + endStep;
              split3 = void 0;
            } else if (mode2 === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text2[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text2;
              folds.push(j);
              escapedFolds[j] = true;
              end2 = j + endStep;
              split3 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text2;
      if (onFold)
        onFold();
      let res = text2.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold18 = folds[i2];
        const end3 = folds[i2 + 1] || text2.length;
        if (fold18 === 0)
          res = `
${indent2}${text2.slice(0, end3)}`;
        else {
          if (mode2 === FOLD_QUOTED && escapedFolds[fold18])
            res += `${text2[fold18]}\\`;
          res += `
${indent2}${text2.slice(fold18 + 1, end3)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text2, i, indent2) {
      let end2 = i;
      let start = i + 1;
      let ch = text2[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent2) {
          ch = text2[++i];
        } else {
          do {
            ch = text2[++i];
          } while (ch && ch !== "\n");
          end2 = i;
          start = i + 1;
          ch = text2[start];
        }
      }
      return end2;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value3, ctx) {
      const json2 = JSON.stringify(value3);
      if (ctx.options.doubleQuotedAsJSON)
        return json2;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent2 = ctx.indent || (containsDocumentMarker(value3) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str2 += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json2[i + 1]) {
            case "u":
              {
                str2 += json2.slice(start, i);
                const code2 = json2.substr(i + 2, 4);
                switch (code2) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code2.substr(0, 2) === "00")
                      str2 += "\\x" + code2.substr(2);
                    else
                      str2 += json2.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json2.slice(start, i) + "\n\n";
                while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent2;
                if (json2[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json2.slice(start) : json2;
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent2, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value3, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value3.includes("\n") || /[ \t]\n|\n[ \t]/.test(value3))
        return doubleQuotedString(value3, ctx);
      const indent2 = ctx.indent || (containsDocumentMarker(value3) ? "  " : "");
      const res = "'" + value3.replace(/'/g, "''").replace(/\n+/g, `$&
${indent2}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value3, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value3.includes('"');
        const hasSingle = value3.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value3, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value: value3 }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value3) || /^\s*$/.test(value3)) {
        return quotedString(value3, ctx);
      }
      const indent2 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value3) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value3, lineWidth, indent2.length);
      if (!value3)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value3.length; endStart > 0; --endStart) {
        const ch = value3[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end2 = value3.substring(endStart);
      const endNlPos = end2.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value3 === end2 || endNlPos !== end2.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end2) {
        value3 = value3.slice(0, -end2.length);
        if (end2[end2.length - 1] === "\n")
          end2 = end2.slice(0, -1);
        end2 = end2.replace(blockEndNewlines, `$&${indent2}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value3.length; ++startEnd) {
        const ch = value3[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value3.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value3 = value3.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent2}`);
      }
      const indentSize = indent2 ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal) {
        const foldedValue = value3.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent2}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end2}`, indent2, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent2}${body}`;
      }
      value3 = value3.replace(/\n+/g, `$&${indent2}`);
      return `|${header}
${indent2}${start}${value3}${end2}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value: value3 } = item;
      const { actualString, implicitKey, indent: indent2, indentStep, inFlow } = ctx;
      if (implicitKey && value3.includes("\n") || inFlow && /[[\]{},]/.test(value3)) {
        return quotedString(value3, ctx);
      }
      if (!value3 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value3)) {
        return implicitKey || inFlow || !value3.includes("\n") ? quotedString(value3, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value3.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value3)) {
        if (indent2 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent2 === indentStep) {
          return quotedString(value3, ctx);
        }
      }
      const str2 = value3.replace(/\n+/g, `$&
${indent2}`);
      if (actualString) {
        const test2 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str2);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test2) || compat?.some(test2))
          return quotedString(value3, ctx);
      }
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent2, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity21 = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) ?? match2[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity21.isScalar(item)) {
        obj = item.value;
        let match2 = tags.filter((t) => t.identify?.(obj));
        if (match2.length > 1) {
          const testMatch = match2.filter((t) => t.test);
          if (testMatch.length > 0)
            match2 = testMatch;
        }
        tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name3 = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name3} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity21.isScalar(node) || identity21.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify2(item, ctx, onComment, onChompKeep) {
      if (identity21.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity21.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity21.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity21.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return identity21.isScalar(node) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var stringify2 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value: value3 }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent2, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity21.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity21.isCollection(key) || !identity21.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value3 == null && !ctx.inFlow || identity21.isCollection(key) || (identity21.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent2 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str2 = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value3 == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
        }
      } else if (allNullValues && !simpleKeys || value3 == null && explicitKey) {
        str2 = `? ${str2}`;
        if (keyComment && !keyCommentDone) {
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        str2 = `? ${str2}
${indent2}:`;
      } else {
        str2 = `${str2}:`;
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity21.isNode(value3)) {
        vsb = !!value3.spaceBefore;
        vcb = value3.commentBefore;
        valueComment = value3.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value3 && typeof value3 === "object")
          value3 = doc.createNode(value3);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity21.isScalar(value3))
        ctx.indentAtStart = str2.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity21.isSeq(value3) && !value3.flow && !value3.tag && !value3.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify2.stringify(value3, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity21.isCollection(value3)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value3.flow ?? value3.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str2 += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str2;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    function debug3(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn3(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug3;
    exports.warn = warn3;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge2 = {
      identify: (value3) => value3 === MERGE_KEY || typeof value3 === "symbol" && value3.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge2.identify(key) || identity21.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge2.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge2.tag && tag.default);
    function addMergeToJSMap(ctx, map44, value3) {
      value3 = ctx && identity21.isAlias(value3) ? value3.resolve(ctx.doc) : value3;
      if (identity21.isSeq(value3))
        for (const it of value3.items)
          mergeValue(ctx, map44, it);
      else if (Array.isArray(value3))
        for (const it of value3)
          mergeValue(ctx, map44, it);
      else
        mergeValue(ctx, map44, value3);
    }
    function mergeValue(ctx, map44, value3) {
      const source2 = ctx && identity21.isAlias(value3) ? value3.resolve(ctx.doc) : value3;
      if (!identity21.isMap(source2))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source2.toJSON(null, ctx, Map);
      for (const [key, value4] of srcMap) {
        if (map44 instanceof Map) {
          if (!map44.has(key))
            map44.set(key, value4);
        } else if (map44 instanceof Set) {
          map44.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map44, key)) {
          Object.defineProperty(map44, key, {
            value: value4,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map44;
    }
    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge2;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log6 = require_log();
    var merge2 = require_merge();
    var stringify2 = require_stringify();
    var identity21 = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map44, { key, value: value3 }) {
      if (identity21.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map44, value3);
      else if (merge2.isMergeKey(ctx, key))
        merge2.addMergeToJSMap(ctx, map44, value3);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map44 instanceof Map) {
          map44.set(jsKey, toJS.toJS(value3, jsKey, ctx));
        } else if (map44 instanceof Set) {
          map44.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value3, stringKey, ctx);
          if (stringKey in map44)
            Object.defineProperty(map44, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map44[stringKey] = jsValue;
        }
      }
      return map44;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity21.isNode(key) && ctx?.doc) {
        const strCtx = stringify2.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log6.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity21 = require_identity();
    function createPair(key, value3, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value3, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value3 = null) {
        Object.defineProperty(this, identity21.NODE_TYPE, { value: identity21.PAIR });
        this.key = key;
        this.value = value3;
      }
      clone(schema) {
        let { key, value: value3 } = this;
        if (identity21.isNode(key))
          key = key.clone(schema);
        if (identity21.isNode(value3))
          value3 = value3.clone(schema);
        return new _Pair(key, value3);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var stringify2 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify3(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent2, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines2 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity21.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines2.push("");
          addCommentBefore(ctx, lines2, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity21.isPair(item)) {
          const ik = identity21.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines2.push("");
            addCommentBefore(ctx, lines2, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str3 = stringify2.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str3 += stringifyComment.lineComment(str3, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines2.push(blockItemPrefix + str3);
      }
      let str2;
      if (lines2.length === 0) {
        str2 = flowChars.start + flowChars.end;
      } else {
        str2 = lines2[0];
        for (let i = 1; i < lines2.length; ++i) {
          const line2 = lines2[i];
          str2 += line2 ? `
${indent2}${line2}` : "\n";
        }
      }
      if (comment) {
        str2 += "\n" + stringifyComment.indentComment(commentString(comment), indent2);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str2;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent: indent2, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines2 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity21.isNode(item)) {
          if (item.spaceBefore)
            lines2.push("");
          addCommentBefore(ctx, lines2, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity21.isPair(item)) {
          const ik = identity21.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines2.push("");
            addCommentBefore(ctx, lines2, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity21.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str2 = stringify2.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str2 += ",";
        if (comment)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment));
        if (!reqNewline && (lines2.length > linesAtValue || str2.includes("\n")))
          reqNewline = true;
        lines2.push(str2);
        linesAtValue = lines2.length;
      }
      const { start, end: end2 } = flowChars;
      if (lines2.length === 0) {
        return start + end2;
      } else {
        if (!reqNewline) {
          const len = lines2.reduce((sum2, line2) => sum2 + line2.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str2 = start;
          for (const line2 of lines2)
            str2 += line2 ? `
${indentStep}${indent2}${line2}` : "\n";
          return `${str2}
${indent2}${end2}`;
        } else {
          return `${start}${fcPadding}${lines2.join(" ")}${fcPadding}${end2}`;
        }
      }
    }
    function addCommentBefore({ indent: indent2, options: { commentString } }, lines2, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent2);
        lines2.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity21 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity21.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity21.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity21.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity21.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map44 = new this(schema);
        const add2 = (key, value3) => {
          if (typeof replacer === "function")
            value3 = replacer.call(obj, key, value3);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value3 !== void 0 || keepUndefined)
            map44.items.push(Pair.createPair(key, value3, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value3] of obj)
            add2(key, value3);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add2(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map44.items.sort(schema.sortMapEntries);
        }
        return map44;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity21.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity21.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity21.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value3) {
        this.add(new Pair.Pair(key, value3), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map44 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map44);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map44, item);
        return map44;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity21.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var YAMLMap = require_YAMLMap();
    var map44 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map45, onError) {
        if (!identity21.isMap(map45))
          onError("Expected a mapping for this tag");
        return map45;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map44;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity21.SEQ, schema);
        this.items = [];
      }
      add(value3) {
        this.items.push(value3);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity21.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value3) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity21.isScalar(prev) && Scalar.isScalarValue(value3))
          prev.value = value3;
        else
          this.items[idx] = value3;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity21.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity21.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string4 = {
      identify: (value3) => typeof value3 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string4;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value3) => value3 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source: source2 }, ctx) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value3) => typeof value3 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar.Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source: source2, value: value3 }, ctx) {
        if (source2 && boolTag.test.test(source2)) {
          const sv = source2[0] === "t" || source2[0] === "T";
          if (value3 === sv)
            return source2;
        }
        return value3 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value: value3 }) {
      if (typeof value3 === "bigint")
        return String(value3);
      const num = typeof value3 === "number" ? value3 : Number(value3);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value3);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node.minFractionDigits = str2.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value3) => typeof value3 === "bigint" || Number.isInteger(value3);
    var intResolve = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value: value3 } = node;
      if (intIdentify(value3) && value3 >= 0)
        return prefix + value3.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value3) => intIdentify(value3) && value3 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value3) => intIdentify(value3) && value3 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map44 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string4 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map44.map,
      seq.seq,
      string4.string,
      _null2.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map44 = require_map();
    var seq = require_seq();
    function intIdentify(value3) {
      return typeof value3 === "bigint" || Number.isInteger(value3);
    }
    var stringifyJSON = ({ value: value3 }) => JSON.stringify(value3);
    var jsonScalars = [
      {
        identify: (value3) => typeof value3 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value3) => value3 == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value3) => typeof value3 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value3 }) => intIdentify(value3) ? value3.toString() : JSON.stringify(value3)
      },
      {
        identify: (value3) => typeof value3 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    var schema = [map44.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value3) => value3 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value: value3 }, ctx, onComment, onChompKeep) {
        const buf = value3;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str2 = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str2.length / lineWidth);
          const lines2 = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines2[i] = str2.substr(o, lineWidth);
          }
          str2 = lines2.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity21.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity21.isPair(item))
            continue;
          else if (identity21.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity21.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value3;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value3 = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys4 = Object.keys(it);
            if (keys4.length === 1) {
              key = keys4[0];
              value3 = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys4.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value3, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map44 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map44);
        for (const pair of this.items) {
          let key, value3;
          if (identity21.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value3 = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map44.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map44.set(key, value3);
        }
        return map44;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value3) => value3 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity21.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value: value3, source: source2 }, ctx) {
      const boolObj = value3 ? trueTag : falseTag;
      if (source2 && boolObj.test.test(source2))
        return source2;
      return value3 ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value3) => value3 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value3) => value3 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f = str2.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value3) => typeof value3 === "bigint" || Number.isInteger(value3);
    function intResolve(str2, offset, radix, { intAsBigInt }) {
      const sign2 = str2[0];
      if (sign2 === "-" || sign2 === "+")
        offset += 1;
      str2 = str2.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign2 === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign2 === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value: value3 } = node;
      if (intIdentify(value3)) {
        const str2 = value3.toString(radix);
        return value3 < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity21.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity21.isPair(pair) ? identity21.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value3) {
        if (typeof value3 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value3}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value3) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value3) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value3 of iterable) {
            if (typeof replacer === "function")
              value3 = replacer.call(iterable, value3, value3);
            set2.items.push(Pair.createPair(value3, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value3) => value3 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map44, onError) {
        if (identity21.isMap(map44)) {
          if (map44.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map44);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map44;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str2, asBigInt) {
      const sign2 = str2[0];
      const parts = sign2 === "-" || sign2 === "+" ? str2.substring(1) : str2;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign2 === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value: value3 } = node;
      let num = (n) => n;
      if (typeof value3 === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value3) || !isFinite(value3))
        return stringifyNumber.stringifyNumber(node);
      let sign2 = "";
      if (value3 < 0) {
        sign2 = "-";
        value3 *= num(-1);
      }
      const _60 = num(60);
      const parts = [value3 % _60];
      if (value3 < 60) {
        parts.unshift(0);
      } else {
        value3 = (value3 - parts[0]) / _60;
        parts.unshift(value3 % _60);
        if (value3 >= 60) {
          value3 = (value3 - parts[0]) / _60;
          parts.unshift(value3);
        }
      }
      return sign2 + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value3) => typeof value3 === "bigint" || Number.isInteger(value3),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value3) => typeof value3 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value3) => value3 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match2 = str2.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month2, day2, hour2, minute2, second2] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date2 = Date.UTC(year2, month2 - 1, day2, hour2 || 0, minute2 || 0, second2 || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date2 -= 6e4 * d;
        }
        return new Date(date2);
      },
      stringify: ({ value: value3 }) => value3.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map44 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string4 = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map44.map,
      seq.seq,
      string4.string,
      _null2.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge2.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map44 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string4 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map44.map, seq.seq, string4.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map44.map,
      merge: merge2.merge,
      null: _null2.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge2.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge2.merge) ? schemaTags.concat(merge2.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys4 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys4} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge2.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys4 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys4}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var map44 = require_map();
    var seq = require_seq();
    var string4 = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge2);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity21.MAP, { value: map44.map });
        Object.defineProperty(this, identity21.SCALAR, { value: string4.string });
        Object.defineProperty(this, identity21.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var stringify2 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines2 = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines2.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines2.push("---");
      const ctx = stringify2.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines2.length !== 1)
          lines2.unshift("");
        const cs = commentString(doc.commentBefore);
        lines2.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity21.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines2.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines2.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines2[lines2.length - 1] === "---") {
          lines2[lines2.length - 1] = `--- ${body}`;
        } else
          lines2.push(body);
      } else {
        lines2.push(stringify2.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines2.push("...");
            lines2.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines2.push(`... ${cs}`);
          }
        } else {
          lines2.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines2[lines2.length - 1] !== "")
            lines2.push("");
          lines2.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines2.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity21 = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value3, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity21.NODE_TYPE, { value: identity21.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value3 === void 0 ? null : this.createNode(value3, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity21.NODE_TYPE]: { value: identity21.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity21.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value3) {
        if (assertCollection(this.contents))
          this.contents.add(value3);
      }
      /** Adds a value to the document. */
      addIn(path2, value3) {
        if (assertCollection(this.contents))
          this.contents.addIn(path2, value3);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name3) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name3 || prev.has(name3) ? anchors.findNewAnchor(name3 || "a", prev) : name3;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value3, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value3 = replacer.call({ "": value3 }, "", value3);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value3, tag, ctx);
        if (flow && identity21.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value3, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value3, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path2) {
        if (Collection.isEmptyPath(path2)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path2) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity21.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path2, keepScalar) {
        if (Collection.isEmptyPath(path2))
          return !keepScalar && identity21.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity21.isCollection(this.contents) ? this.contents.getIn(path2, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity21.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path2) {
        if (Collection.isEmptyPath(path2))
          return this.contents !== void 0;
        return identity21.isCollection(this.contents) ? this.contents.hasIn(path2) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value3) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value3);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value3);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path2, value3) {
        if (Collection.isEmptyPath(path2)) {
          this.contents = value3;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path2), value3);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path2, value3);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new directives.Directives({ version: version2 });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json2,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity21.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name3, pos, code2, message3) {
        super();
        this.name = name3;
        this.code = code2;
        this.message = message3;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code2, message3) {
        super("YAMLParseError", pos, code2, message3);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code2, message3) {
        super("YAMLWarning", pos, code2, message3);
      }
    };
    var prettifyError = (src, lc) => (error5) => {
      if (error5.pos[0] === -1)
        return;
      error5.linePos = error5.pos.map((pos) => lc.linePos(pos));
      const { line: line2, col } = error5.linePos[0];
      error5.message += ` at line ${line2}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end2 = error5.linePos[1];
        if (end2 && end2.line === line2 && end2.col > col) {
          count = Math.max(1, Math.min(end2.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error5.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next2?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            if (start === null)
              start = token.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last3 = tokens[tokens.length - 1];
      const end2 = last3 ? last3.offset + last3.source.length : offset;
      if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
        onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next2?.type === "block-map" || next2?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end: end2,
        start: start ?? end2
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent2, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end2 = fc.end[0];
        if (end2.indent === indent2 && (end2.source === "]" || end2.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end2, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity21.isScalar(a) && identity21.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map44 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep2, value: value3 } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep2) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map44.comment)
                map44.comment += "\n" + keyProps.comment;
              else
                map44.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map44.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep2 ?? [], {
          indicator: "map-value-ind",
          next: value3,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value3?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value3 ? composeNode(ctx, value3, valueProps, onError) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value3, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map44.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map44.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map44.range = [bm.offset, offset, commentEnd ?? offset];
      return map44;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value: value3 } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value3,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value3) {
            if (value3 && value3.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value3 ? composeNode(ctx, value3, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value3, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end2, offset, reqSpace, onError) {
      let comment = "";
      if (end2) {
        let hasSpace = false;
        let sep2 = "";
        for (const token of end2) {
          const { source: source2, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source2.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep2 + cb;
              sep2 = "";
              break;
            }
            case "newline":
              if (comment)
                sep2 += source2;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source2.length;
        }
      }
      return { comment, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep2, value: value3 } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep2 && !value3) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity21.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep2 && !props.found) {
          const valueNode = value3 ? composeNode(ctx, value3, props, onError) : composeEmptyNode(ctx, props.end, sep2, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value3))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep2 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value3,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep2)
                for (const st of sep2) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value3) {
            if ("source" in value3 && value3.source && value3.source[0] === ":")
              onError(value3, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value3 ? composeNode(ctx, value3, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value3))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map44 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map44.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map44.items.push(pair);
          } else {
            const map44 = new YAMLMap.YAMLMap(ctx.schema);
            map44.flow = true;
            map44.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map44.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map44);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name3 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name3} must end with a ${expectedEnd}` : `${name3} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end2 = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end2.comment) {
          if (coll.comment)
            coll.comment += "\n" + end2.comment;
          else
            coll.comment = end2.comment;
        }
        coll.range = [fc.offset, cePos, end2.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message3 = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message3);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity21.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines2 = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines2.length;
      for (let i = lines2.length - 1; i >= 0; --i) {
        const content = lines2[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value4 = header.chomp === "+" && lines2.length > 0 ? "\n".repeat(Math.max(1, lines2.length - 1)) : "";
        let end3 = start + header.length;
        if (scalar.source)
          end3 += scalar.source.length;
        return { value: value4, type, comment: header.comment, range: [start, end3, end3] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent2, content] = lines2[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent2.length > trimIndent)
            trimIndent = indent2.length;
        } else {
          if (indent2.length < trimIndent) {
            const message3 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent2.length, "MISSING_CHAR", message3);
          }
          if (header.indent === 0)
            trimIndent = indent2.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message3 = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message3);
          }
          break;
        }
        offset += indent2.length + content.length + 1;
      }
      for (let i = lines2.length - 1; i >= chompStart; --i) {
        if (lines2[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value3 = "";
      let sep2 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value3 += lines2[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent2, content] = lines2[i];
        offset += indent2.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent2.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message3 = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message3);
          indent2 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value3 += sep2 + indent2.slice(trimIndent) + content;
          sep2 = "\n";
        } else if (indent2.length > trimIndent || content[0] === "	") {
          if (sep2 === " ")
            sep2 = "\n";
          else if (!prevMoreIndented && sep2 === "\n")
            sep2 = "\n\n";
          value3 += sep2 + indent2.slice(trimIndent) + content;
          sep2 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep2 === "\n")
            value3 += "\n";
          else
            sep2 = "\n";
        } else {
          value3 += sep2 + content;
          sep2 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines2.length; ++i)
            value3 += "\n" + lines2[i][0].slice(trimIndent);
          if (value3[value3.length - 1] !== "\n")
            value3 += "\n";
          break;
        default:
          value3 += "\n";
      }
      const end2 = start + header.length + scalar.source.length;
      return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source: source2 } = props[0];
      const mode2 = source2[0];
      let indent2 = 0;
      let chomp = "";
      let error5 = -1;
      for (let i = 1; i < source2.length; ++i) {
        const ch = source2[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent2 && n)
            indent2 = n;
          else if (error5 === -1)
            error5 = offset + i;
        }
      }
      if (error5 !== -1)
        onError(error5, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
      let hasSpace = false;
      let comment = "";
      let length8 = source2.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length8 += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message3 = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message3);
            }
            length8 += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length8 += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message3 = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message3);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length8 += ts.length;
          }
        }
      }
      return { mode: mode2, indent: indent2, chomp, comment, length: length8 };
    }
    function splitLines(source2) {
      const split3 = source2.split(/\n( *)/);
      const first = split3[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines2 = [line0];
      for (let i = 1; i < split3.length; i += 2)
        lines2.push([split3[i], split3[i + 1]]);
      return lines2;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source: source2, end: end2 } = scalar;
      let _type;
      let value3;
      const _onError = (rel, code2, msg) => onError(offset + rel, code2, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value3 = plainValue(source2, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value3 = singleQuotedValue(source2, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value3 = doubleQuotedValue(source2, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source2.length, offset + source2.length]
          };
      }
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end2, valueEnd, strict, onError);
      return {
        value: value3,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source2, onError) {
      let badChar = "";
      switch (source2[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source2[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source2[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source2);
    }
    function singleQuotedValue(source2, onError) {
      if (source2[source2.length - 1] !== "'" || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source2) {
      let first, line2;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match2 = first.exec(source2);
      if (!match2)
        return source2;
      let res = match2[1];
      let sep2 = " ";
      let pos = first.lastIndex;
      line2.lastIndex = pos;
      while (match2 = line2.exec(source2)) {
        if (match2[1] === "") {
          if (sep2 === "\n")
            res += sep2;
          else
            sep2 = "\n";
        } else {
          res += sep2 + match2[1];
          sep2 = " ";
        }
        pos = line2.lastIndex;
      }
      const last3 = /[ \t]*(.*)/sy;
      last3.lastIndex = pos;
      match2 = last3.exec(source2);
      return res + sep2 + (match2?.[1] ?? "");
    }
    function doubleQuotedValue(source2, onError) {
      let res = "";
      for (let i = 1; i < source2.length - 1; ++i) {
        const ch = source2[i];
        if (ch === "\r" && source2[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold: fold18, offset } = foldNewline(source2, i);
          res += fold18;
          i = offset;
        } else if (ch === "\\") {
          let next2 = source2[++i];
          const cc = escapeCodes[next2];
          if (cc)
            res += cc;
          else if (next2 === "\n") {
            next2 = source2[i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "\r" && source2[i + 1] === "\n") {
            next2 = source2[++i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "x" || next2 === "u" || next2 === "U") {
            const length8 = { x: 2, u: 4, U: 8 }[next2];
            res += parseCharCode(source2, i + 1, length8, onError);
            i += length8;
          } else {
            const raw = source2.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next2 = source2[i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source2[++i + 1];
          if (next2 !== "\n" && !(next2 === "\r" && source2[i + 2] === "\n"))
            res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source2[source2.length - 1] !== '"' || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source2, offset) {
      let fold18 = "";
      let ch = source2[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source2[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold18 += "\n";
        offset += 1;
        ch = source2[offset + 1];
      }
      if (!fold18)
        fold18 = " ";
      return { fold: fold18, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source2, offset, length8, onError) {
      const cc = source2.substr(offset, length8);
      const ok = cc.length === length8 && /^[0-9a-fA-F]+$/.test(cc);
      const code2 = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code2)) {
        const raw = source2.substr(offset - 2, length8 + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code2);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity21 = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value: value3, type, comment, range: range3 } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity21.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value3, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value3, token, onError);
      else
        tag = ctx.schema[identity21.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value3, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity21.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error5) {
        const msg = error5 instanceof Error ? error5.message : String(error5);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value3);
      }
      scalar.range = range3;
      scalar.source = value3;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value3, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity21.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value3))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity21.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value3, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value3)) || schema[identity21.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value3)) ?? schema[identity21.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity21 = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message3 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message3);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity21.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end: end2 }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end2;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source: source2, end: end2 }, onError) {
      const alias = new Alias.Alias(source2.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end2, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value: value3, end: end2 }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value3 ?? end2?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value3 && (value3.type === "block-map" || value3.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value3 ? composeNode.composeNode(ctx, value3, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end2, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var identity21 = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source: source2 } = src;
      return [offset, offset + (typeof source2 === "string" ? source2.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source2 = prelude[i];
        switch (source2[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source2, code2, message3, warning) => {
          const pos = getErrorPos(source2);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code2, message3));
          else
            this.errors.push(new errors.YAMLParseError(pos, code2, message3));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity21.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity21.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message3, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message3, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error5 = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error5);
            else
              this.doc.errors.push(error5);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end2 = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end2.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
            }
            this.doc.range[2] = end2.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code2, message3) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code2, message3);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code2, message3);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value3, context) {
      const { implicitKey = false, indent: indent2, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source2 = stringifyString.stringifyString({ type, value: value3 }, {
        implicitKey,
        indent: indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end2 = context.end ?? [
        { type: "newline", offset: -1, indent: indent2, source: "\n" }
      ];
      switch (source2[0]) {
        case "|":
        case ">": {
          const he = source2.indexOf("\n");
          const head4 = source2.substring(0, he);
          const body = source2.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent2, source: head4 }
          ];
          if (!addEndtoBlockProps(props, end2))
            props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
          return { type: "block-scalar", offset, indent: indent2, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent2, source: source2, end: end2 };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent2, source: source2, end: end2 };
        default:
          return { type: "scalar", offset, indent: indent2, source: source2, end: end2 };
      }
    }
    function setScalarValue(token, value3, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent2 = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent2 === "number")
        indent2 += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source2 = stringifyString.stringifyString({ type, value: value3 }, {
        implicitKey: implicitKey || indent2 === null,
        indent: indent2 !== null && indent2 > 0 ? " ".repeat(indent2) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source2[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source2);
          break;
        case '"':
          setFlowScalarValue(token, source2, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source2, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source2, "scalar");
      }
    }
    function setBlockScalarValue(token, source2) {
      const he = source2.indexOf("\n");
      const head4 = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head4;
        token.source = body;
      } else {
        const { offset } = token;
        const indent2 = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent2, source: head4 }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent2, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent: indent2, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end2) {
      if (end2)
        for (const st of end2)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source2, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source2;
          break;
        case "block-scalar": {
          const end2 = token.props.slice(1);
          let oa = source2.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end2)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source: source2, end: end2 });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source2.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source: source2, end: [nl] });
          break;
        }
        default: {
          const indent2 = "indent" in token ? token.indent : -1;
          const end2 = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent: indent2, source: source2, end: end2 });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep2, value: value3 }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep2)
        for (const st of sep2)
          res += st.source;
      if (value3)
        res += stringifyToken(value3);
      return res;
    }
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path2) => {
      let item = cst;
      for (const [field, index5] of path2) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index5];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path2) => {
      const parent = visit.itemAtPath(cst, path2.slice(0, -1));
      const field = path2[path2.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path2, item, visitor) {
      let ctrl = visitor(item, path2);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path2.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path2);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path2) : ctrl;
    }
    exports.visit = visit;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source2) {
      switch (source2) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source2[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty4(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source2, incomplete = false) {
        if (source2) {
          if (typeof source2 !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source2 : source2;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next2 = this.next ?? "stream";
        while (next2 && (incomplete || this.hasChars(1)))
          next2 = yield* this.parseNext(next2);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent2 = 0;
          while (ch === " ")
            ch = this.buffer[++indent2 + offset];
          if (ch === "\r") {
            const next2 = this.buffer[indent2 + offset + 1];
            if (next2 === "\n" || !next2 && !this.atEnd)
              return offset + indent2 + 1;
          }
          return ch === "\n" || indent2 >= this.indentNext || !ch && !this.atEnd ? offset + indent2 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty4(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end2 = this.lineEndPos;
        if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
          end2 = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end2;
        }
        if (end2 === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end2 - 1] === "\r")
          end2 -= 1;
        return this.buffer.substring(this.pos, end2);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state2) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state2;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next2) {
        switch (next2) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line2 = this.getLine();
        if (line2 === null)
          return this.setNext("stream");
        if (line2[0] === cst.BOM) {
          yield* this.pushCount(1);
          line2 = line2.substring(1);
        }
        if (line2[0] === "%") {
          let dirEnd = line2.length;
          let cs = line2.indexOf("#");
          while (cs !== -1) {
            const ch = line2[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line2.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line2[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line2.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line2.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty4(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty4(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty4(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line2[n]) {
          case "#":
            yield* this.pushCount(line2.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line2.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent2 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent2 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("flow");
        if (indent2 !== -1 && indent2 < this.indentNext && line2[0] !== "#" || indent2 === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty4(line2[3])) {
          const atFlowEndMarker = indent2 === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line2[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line2[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line2.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next2 = this.charAt(1);
            if (this.flowKey || isEmpty4(next2) || next2 === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end2 = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end2 !== -1 && this.buffer[end2 + 1] === "'")
            end2 = this.buffer.indexOf("'", end2 + 2);
        } else {
          while (end2 !== -1) {
            let n = 0;
            while (this.buffer[end2 - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end2 = this.buffer.indexOf('"', end2 + 1);
          }
        }
        const qb = this.buffer.substring(0, end2);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end2 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end2 === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end2 = this.buffer.length;
        }
        yield* this.pushToIndex(end2 + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty4(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent2 = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent2 += 1;
              break;
            case "\n":
              nl = i2;
              indent2 = 0;
              break;
            case "\r": {
              const next2 = this.buffer[i2 + 1];
              if (!next2 && !this.atEnd)
                return this.setNext("block-scalar");
              if (next2 === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent2 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent2;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent2 > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end2 = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next2 = this.buffer[i + 1];
            if (isEmpty4(next2) || inFlow && flowIndicatorChars.has(next2))
              break;
            end2 = i;
          } else if (isEmpty4(ch)) {
            let next2 = this.buffer[i + 1];
            if (ch === "\r") {
              if (next2 === "\n") {
                i += 1;
                ch = "\n";
                next2 = this.buffer[i + 1];
              } else
                end2 = i;
            }
            if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end2 = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end2 + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty4(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty4(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test2) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test2(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source2, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source2, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source2) {
        this.source = source2;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source2));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source2.length;
          return;
        }
        const type = cst.tokenType(source2);
        if (!type) {
          const message3 = `Not a YAML token: ${source2}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message3, source: source2 });
          this.offset += source2.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source2.length);
              break;
            case "space":
              if (this.atNewLine && source2[0] === " ")
                this.indent += source2.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source2.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source2.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top3 = this.peek(1);
        if (this.type === "doc-end" && (!top3 || top3.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top3)
          return yield* this.stream();
        switch (top3.type) {
          case "document":
            return yield* this.document(top3);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top3);
          case "block-scalar":
            return yield* this.blockScalar(top3);
          case "block-map":
            return yield* this.blockMap(top3);
          case "block-seq":
            return yield* this.blockSequence(top3);
          case "flow-collection":
            return yield* this.flowCollection(top3);
          case "doc-end":
            return yield* this.documentEnd(top3);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error5) {
        const token = error5 ?? this.stack.pop();
        if (!token) {
          const message3 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message3 };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top3 = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top3 ? top3.indent : 0;
          } else if (token.type === "flow-collection" && top3.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top3.type) {
            case "document":
              top3.value = token;
              break;
            case "block-scalar":
              top3.props.push(token);
              break;
            case "block-map": {
              const it = top3.items[top3.items.length - 1];
              if (it.value) {
                top3.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top3.items[top3.items.length - 1];
              if (it.value)
                top3.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top3.items[top3.items.length - 1];
              if (!it || it.value)
                top3.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top3.type === "document" || top3.type === "block-map" || top3.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last3 = token.items[token.items.length - 1];
            if (last3 && !last3.sep && !last3.value && last3.start.length > 0 && findNonEmptyIndex(last3.start) === -1 && (token.indent === 0 || last3.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top3.type === "document")
                top3.end = last3.start;
              else
                top3.items.push({ start: last3.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map44 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map44;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map44) {
        const it = map44.items[map44.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end2 = "end" in it.value ? it.value.end : void 0;
              const last3 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
              if (last3?.type === "comment")
                end2?.push(this.sourceToken);
              else
                map44.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map44.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map44.indent)) {
                const prev = map44.items[map44.items.length - 2];
                const end2 = prev?.value?.end;
                if (Array.isArray(end2)) {
                  Array.prototype.push.apply(end2, it.start);
                  end2.push(this.sourceToken);
                  map44.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map44.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map44.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map44.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map44.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map44.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map44.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map44.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map44.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map44);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map44.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end2 = "end" in it.value ? it.value.end : void 0;
              const last3 = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
              if (last3?.type === "comment")
                end2?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end2 = prev?.value?.end;
                if (Array.isArray(end2)) {
                  Array.prototype.push.apply(end2, it.start);
                  end2.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top3;
          do {
            yield* this.pop();
            top3 = this.peek(1);
          } while (top3 && top3.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map44 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map44;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent2) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent2)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log6 = require_log();
    var identity21 = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source2)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source2), true, source2.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
      }
      return doc;
    }
    function parse5(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log6.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify2(value3, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent2 = Math.round(options);
        options = indent2 < 1 ? void 0 : indent2 > 8 ? { indent: 8 } : { indent: indent2 };
      }
      if (value3 === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity21.isDocument(value3) && !_replacer)
        return value3.toString(options);
      return new Document.Document(value3, _replacer, options).toString(options);
    }
    exports.parse = parse5;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify2;
  }
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity21 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity21.isAlias;
    exports.isCollection = identity21.isCollection;
    exports.isDocument = identity21.isDocument;
    exports.isMap = identity21.isMap;
    exports.isNode = identity21.isNode;
    exports.isPair = identity21.isPair;
    exports.isScalar = identity21.isScalar;
    exports.isSeq = identity21.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// output/Data.Array/foreign.js
var rangeImpl = function(start, end2) {
  var step2 = start > end2 ? -1 : 1;
  var result = new Array(step2 * (end2 - start) + 1);
  var i = start, n = 0;
  while (i !== end2) {
    result[n++] = i;
    i += step2;
  }
  result[n] = i;
  return result;
};
var replicateFill = function(count, value3) {
  if (count < 1) {
    return [];
  }
  var result = new Array(count);
  return result.fill(value3);
};
var replicatePolyfill = function(count, value3) {
  var result = [];
  var n = 0;
  for (var i = 0; i < count; i++) {
    result[n++] = value3;
  }
  return result;
};
var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var fromFoldableImpl = /* @__PURE__ */ function() {
  function Cons4(head4, tail2) {
    this.head = head4;
    this.tail = tail2;
  }
  var emptyList = {};
  function curryCons(head4) {
    return function(tail2) {
      return new Cons4(head4, tail2);
    };
  }
  function listToArray(list) {
    var result = [];
    var count = 0;
    var xs = list;
    while (xs !== emptyList) {
      result[count++] = xs.head;
      xs = xs.tail;
    }
    return result;
  }
  return function(foldr9, xs) {
    return listToArray(foldr9(curryCons)(emptyList)(xs));
  };
}();
var length = function(xs) {
  return xs.length;
};
var unconsImpl = function(empty10, next2, xs) {
  return xs.length === 0 ? empty10({}) : next2(xs[0])(xs.slice(1));
};
var indexImpl = function(just, nothing, xs, i) {
  return i < 0 || i >= xs.length ? nothing : just(xs[i]);
};
var findIndexImpl = function(just, nothing, f, xs) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (f(xs[i])) return just(i);
  }
  return nothing;
};
var reverse = function(l) {
  return l.slice().reverse();
};
var filterImpl = function(f, xs) {
  return xs.filter(f);
};
var sortByImpl = /* @__PURE__ */ function() {
  function mergeFromTo(compare7, fromOrdering, xs1, xs2, from3, to2) {
    var mid;
    var i;
    var j;
    var k;
    var x;
    var y;
    var c;
    mid = from3 + (to2 - from3 >> 1);
    if (mid - from3 > 1) mergeFromTo(compare7, fromOrdering, xs2, xs1, from3, mid);
    if (to2 - mid > 1) mergeFromTo(compare7, fromOrdering, xs2, xs1, mid, to2);
    i = from3;
    j = mid;
    k = from3;
    while (i < mid && j < to2) {
      x = xs2[i];
      y = xs2[j];
      c = fromOrdering(compare7(x)(y));
      if (c > 0) {
        xs1[k++] = y;
        ++j;
      } else {
        xs1[k++] = x;
        ++i;
      }
    }
    while (i < mid) {
      xs1[k++] = xs2[i++];
    }
    while (j < to2) {
      xs1[k++] = xs2[j++];
    }
  }
  return function(compare7, fromOrdering, xs) {
    var out;
    if (xs.length < 2) return xs;
    out = xs.slice(0);
    mergeFromTo(compare7, fromOrdering, out, xs.slice(0), 0, xs.length);
    return out;
  };
}();
var sliceImpl = function(s, e, l) {
  return l.slice(s, e);
};
var anyImpl = function(p, xs) {
  var len = xs.length;
  for (var i = 0; i < len; i++) {
    if (p(xs[i])) return true;
  }
  return false;
};
var unsafeIndexImpl = function(xs, n) {
  return xs[n];
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};
var compose = function(dict) {
  return dict.compose;
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var on = function(f) {
  return function(g) {
    return function(x) {
      return function(y) {
        return f(g(x))(g(y));
      };
    };
  };
};
var flip = function(f) {
  return function(b) {
    return function(a) {
      return f(a)(b);
    };
  };
};
var $$const = function(a) {
  return function(v) {
    return a;
  };
};
var applyN = function(f) {
  var go = function($copy_n) {
    return function($copy_acc) {
      var $tco_var_n = $copy_n;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(n, acc) {
        if (n <= 0) {
          $tco_done = true;
          return acc;
        }
        ;
        if (otherwise) {
          $tco_var_n = n - 1 | 0;
          $copy_acc = f(acc);
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Function (line 107, column 3 - line 109, column 37): " + [n.constructor.name, acc.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_n, $copy_acc);
      }
      ;
      return $tco_result;
    };
  };
  return go;
};
var applyFlipped = function(x) {
  return function(f) {
    return f(x);
  };
};

// output/Data.Unit/foreign.js
var unit = void 0;

// output/Type.Proxy/index.js
var $$Proxy = /* @__PURE__ */ function() {
  function $$Proxy2() {
  }
  ;
  $$Proxy2.value = new $$Proxy2();
  return $$Proxy2;
}();

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var mapFlipped = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return function(fa) {
    return function(f) {
      return map118(f)(fa);
    };
  };
};
var $$void = function(dictFunctor) {
  return map(dictFunctor)($$const(unit));
};
var voidLeft = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return function(f) {
    return function(x) {
      return map118($$const(x))(f);
    };
  };
};
var voidRight = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return function(x) {
    return map118($$const(x));
  };
};
var functorFn = {
  map: /* @__PURE__ */ compose(semigroupoidFn)
};
var functorArray = {
  map: arrayMap
};

// output/Data.Semigroup/foreign.js
var concatString = function(s1) {
  return function(s2) {
    return s1 + s2;
  };
};
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0) return ys;
    if (ys.length === 0) return xs;
    return xs.concat(ys);
  };
};

// output/Data.Symbol/index.js
var reflectSymbol = function(dict) {
  return dict.reflectSymbol;
};

// output/Record.Unsafe/foreign.js
var unsafeGet = function(label) {
  return function(rec) {
    return rec[label];
  };
};
var unsafeSet = function(label) {
  return function(value3) {
    return function(rec) {
      var copy = {};
      for (var key in rec) {
        if ({}.hasOwnProperty.call(rec, key)) {
          copy[key] = rec[key];
        }
      }
      copy[label] = value3;
      return copy;
    };
  };
};

// output/Data.Semigroup/index.js
var semigroupUnit = {
  append: function(v) {
    return function(v1) {
      return unit;
    };
  }
};
var semigroupString = {
  append: concatString
};
var semigroupRecordNil = {
  appendRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  }
};
var semigroupArray = {
  append: concatArray
};
var appendRecord = function(dict) {
  return dict.appendRecord;
};
var semigroupRecord = function() {
  return function(dictSemigroupRecord) {
    return {
      append: appendRecord(dictSemigroupRecord)($$Proxy.value)
    };
  };
};
var append = function(dict) {
  return dict.append;
};
var semigroupRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictSemigroupRecord) {
      var appendRecord1 = appendRecord(dictSemigroupRecord);
      return function(dictSemigroup) {
        var append110 = append(dictSemigroup);
        return {
          appendRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail2 = appendRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert10 = unsafeSet(key);
                var get3 = unsafeGet(key);
                return insert10(append110(get3(ra))(get3(rb)))(tail2);
              };
            };
          }
        };
      };
    };
  };
};

// output/Control.Alt/index.js
var altArray = {
  alt: /* @__PURE__ */ append(semigroupArray),
  Functor0: function() {
    return functorArray;
  }
};
var alt = function(dict) {
  return dict.alt;
};

// output/Control.Apply/foreign.js
var arrayApply = function(fs) {
  return function(xs) {
    var l = fs.length;
    var k = xs.length;
    var result = new Array(l * k);
    var n = 0;
    for (var i = 0; i < l; i++) {
      var f = fs[i];
      for (var j = 0; j < k; j++) {
        result[n++] = f(xs[j]);
      }
    }
    return result;
  };
};

// output/Control.Apply/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var applyArray = {
  apply: arrayApply,
  Functor0: function() {
    return functorArray;
  }
};
var apply = function(dict) {
  return dict.apply;
};
var applyFirst = function(dictApply) {
  var apply14 = apply(dictApply);
  var map44 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply14(map44($$const)(a))(b);
    };
  };
};
var applySecond = function(dictApply) {
  var apply14 = apply(dictApply);
  var map44 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply14(map44($$const(identity2))(a))(b);
    };
  };
};
var lift2 = function(dictApply) {
  var apply14 = apply(dictApply);
  var map44 = map(dictApply.Functor0());
  return function(f) {
    return function(a) {
      return function(b) {
        return apply14(map44(f)(a))(b);
      };
    };
  };
};

// output/Control.Applicative/index.js
var pure = function(dict) {
  return dict.pure;
};
var unless = function(dictApplicative) {
  var pure118 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (!v) {
        return v1;
      }
      ;
      if (v) {
        return pure118(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var when = function(dictApplicative) {
  var pure118 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return pure118(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var liftA1 = function(dictApplicative) {
  var apply11 = apply(dictApplicative.Apply0());
  var pure118 = pure(dictApplicative);
  return function(f) {
    return function(a) {
      return apply11(pure118(f))(a);
    };
  };
};
var applicativeArray = {
  pure: function(x) {
    return [x];
  },
  Apply0: function() {
    return applyArray;
  }
};

// output/Control.Bind/foreign.js
var arrayBind = function(arr) {
  return function(f) {
    var result = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      Array.prototype.push.apply(result, f(arr[i]));
    }
    return result;
  };
};

// output/Control.Bind/index.js
var identity3 = /* @__PURE__ */ identity(categoryFn);
var discard = function(dict) {
  return dict.discard;
};
var bindArray = {
  bind: arrayBind,
  Apply0: function() {
    return applyArray;
  }
};
var bind = function(dict) {
  return dict.bind;
};
var bindFlipped = function(dictBind) {
  return flip(bind(dictBind));
};
var composeKleisliFlipped = function(dictBind) {
  var bindFlipped12 = bindFlipped(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bindFlipped12(f)(g(a));
      };
    };
  };
};
var composeKleisli = function(dictBind) {
  var bind114 = bind(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bind114(f(a))(g);
      };
    };
  };
};
var discardUnit = {
  discard: function(dictBind) {
    return bind(dictBind);
  }
};
var ifM = function(dictBind) {
  var bind114 = bind(dictBind);
  return function(cond) {
    return function(t) {
      return function(f) {
        return bind114(cond)(function(cond$prime) {
          if (cond$prime) {
            return t;
          }
          ;
          return f;
        });
      };
    };
  };
};
var join = function(dictBind) {
  var bind114 = bind(dictBind);
  return function(m) {
    return bind114(m)(identity3);
  };
};

// output/Control.Monad/index.js
var whenM = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var when9 = when(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind30(mb)(function(b) {
        return when9(b)(m);
      });
    };
  };
};
var unlessM = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var unless6 = unless(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind30(mb)(function(b) {
        return unless6(b)(m);
      });
    };
  };
};
var liftM1 = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure35 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind30(a)(function(a$prime) {
        return pure35(f(a$prime));
      });
    };
  };
};
var ap = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure35 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind30(f)(function(f$prime) {
        return bind30(a)(function(a$prime) {
          return pure35(f$prime(a$prime));
        });
      });
    };
  };
};

// output/Data.Bounded/foreign.js
var topInt = 2147483647;
var bottomInt = -2147483648;
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq27) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq27 : gt;
        };
      };
    };
  };
};
var ordIntImpl = unsafeCompareImpl;
var ordNumberImpl = unsafeCompareImpl;
var ordStringImpl = unsafeCompareImpl;
var ordCharImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqBooleanImpl = refEq;
var eqIntImpl = refEq;
var eqNumberImpl = refEq;
var eqCharImpl = refEq;
var eqStringImpl = refEq;

// output/Data.Eq/index.js
var eqString = {
  eq: eqStringImpl
};
var eqRowNil = {
  eqRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return true;
      };
    };
  }
};
var eqRecord = function(dict) {
  return dict.eqRecord;
};
var eqRec = function() {
  return function(dictEqRecord) {
    return {
      eq: eqRecord(dictEqRecord)($$Proxy.value)
    };
  };
};
var eqNumber = {
  eq: eqNumberImpl
};
var eqInt = {
  eq: eqIntImpl
};
var eqChar = {
  eq: eqCharImpl
};
var eqBoolean = {
  eq: eqBooleanImpl
};
var eq = function(dict) {
  return dict.eq;
};
var eq2 = /* @__PURE__ */ eq(eqBoolean);
var eqRowCons = function(dictEqRecord) {
  var eqRecord1 = eqRecord(dictEqRecord);
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return function(dictEq) {
        var eq33 = eq(dictEq);
        return {
          eqRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail2 = eqRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var get3 = unsafeGet(key);
                return eq33(get3(ra))(get3(rb)) && tail2;
              };
            };
          }
        };
      };
    };
  };
};
var notEq = function(dictEq) {
  var eq33 = eq(dictEq);
  return function(x) {
    return function(y) {
      return eq2(eq33(x)(y))(false);
    };
  };
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
}();
var GT = /* @__PURE__ */ function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
}();
var EQ = /* @__PURE__ */ function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
}();
var eqOrdering = {
  eq: function(v) {
    return function(v1) {
      if (v instanceof LT && v1 instanceof LT) {
        return true;
      }
      ;
      if (v instanceof GT && v1 instanceof GT) {
        return true;
      }
      ;
      if (v instanceof EQ && v1 instanceof EQ) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};

// output/Data.Semiring/index.js
var zero = function(dict) {
  return dict.zero;
};
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};
var one = function(dict) {
  return dict.one;
};

// output/Data.Ring/index.js
var sub = function(dict) {
  return dict.sub;
};
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};
var negate = function(dictRing) {
  var sub1 = sub(dictRing);
  var zero2 = zero(dictRing.Semiring0());
  return function(a) {
    return sub1(zero2)(a);
  };
};

// output/Data.Ord/index.js
var eqRec2 = /* @__PURE__ */ eqRec();
var notEq2 = /* @__PURE__ */ notEq(eqOrdering);
var ordString = /* @__PURE__ */ function() {
  return {
    compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqString;
    }
  };
}();
var ordRecordNil = {
  compareRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return EQ.value;
      };
    };
  },
  EqRecord0: function() {
    return eqRowNil;
  }
};
var ordNumber = /* @__PURE__ */ function() {
  return {
    compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqNumber;
    }
  };
}();
var ordInt = /* @__PURE__ */ function() {
  return {
    compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqInt;
    }
  };
}();
var ordChar = /* @__PURE__ */ function() {
  return {
    compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqChar;
    }
  };
}();
var compareRecord = function(dict) {
  return dict.compareRecord;
};
var ordRecord = function() {
  return function(dictOrdRecord) {
    var eqRec1 = eqRec2(dictOrdRecord.EqRecord0());
    return {
      compare: compareRecord(dictOrdRecord)($$Proxy.value),
      Eq0: function() {
        return eqRec1;
      }
    };
  };
};
var compare = function(dict) {
  return dict.compare;
};
var comparing = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(f) {
    return function(x) {
      return function(y) {
        return compare33(f(x))(f(y));
      };
    };
  };
};
var greaterThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof GT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var greaterThanOrEq = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return false;
      }
      ;
      return true;
    };
  };
};
var lessThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var max = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return y;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return x;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): " + [v.constructor.name]);
    };
  };
};
var min = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return x;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return y;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v.constructor.name]);
    };
  };
};
var ordRecordCons = function(dictOrdRecord) {
  var compareRecord1 = compareRecord(dictOrdRecord);
  var eqRowCons2 = eqRowCons(dictOrdRecord.EqRecord0())();
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      var eqRowCons1 = eqRowCons2(dictIsSymbol);
      return function(dictOrd) {
        var compare33 = compare(dictOrd);
        var eqRowCons22 = eqRowCons1(dictOrd.Eq0());
        return {
          compareRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var key = reflectSymbol2($$Proxy.value);
                var left = compare33(unsafeGet(key)(ra))(unsafeGet(key)(rb));
                var $95 = notEq2(left)(EQ.value);
                if ($95) {
                  return left;
                }
                ;
                return compareRecord1($$Proxy.value)(ra)(rb);
              };
            };
          },
          EqRecord0: function() {
            return eqRowCons22;
          }
        };
      };
    };
  };
};
var abs = function(dictOrd) {
  var greaterThanOrEq1 = greaterThanOrEq(dictOrd);
  return function(dictRing) {
    var zero2 = zero(dictRing.Semiring0());
    var negate1 = negate(dictRing);
    return function(x) {
      var $99 = greaterThanOrEq1(x)(zero2);
      if ($99) {
        return x;
      }
      ;
      return negate1(x);
    };
  };
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedInt = {
  top: topInt,
  bottom: bottomInt,
  Ord0: function() {
    return ordInt;
  }
};
var boundedChar = {
  top: topChar,
  bottom: bottomChar,
  Ord0: function() {
    return ordChar;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Show/foreign.js
var showIntImpl = function(n) {
  return n.toString();
};
var showNumberImpl = function(n) {
  var str2 = n.toString();
  return isNaN(str2 + ".0") ? str2 : str2 + ".0";
};
var showCharImpl = function(c) {
  var code2 = c.charCodeAt(0);
  if (code2 < 32 || code2 === 127) {
    switch (c) {
      case "\x07":
        return "'\\a'";
      case "\b":
        return "'\\b'";
      case "\f":
        return "'\\f'";
      case "\n":
        return "'\\n'";
      case "\r":
        return "'\\r'";
      case "	":
        return "'\\t'";
      case "\v":
        return "'\\v'";
    }
    return "'\\" + code2.toString(10) + "'";
  }
  return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
};
var showStringImpl = function(s) {
  var l = s.length;
  return '"' + s.replace(
    /[\0-\x1F\x7F"\\]/g,
    // eslint-disable-line no-control-regex
    function(c, i) {
      switch (c) {
        case '"':
        case "\\":
          return "\\" + c;
        case "\x07":
          return "\\a";
        case "\b":
          return "\\b";
        case "\f":
          return "\\f";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "	":
          return "\\t";
        case "\v":
          return "\\v";
      }
      var k = i + 1;
      var empty10 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
      return "\\" + c.charCodeAt(0).toString(10) + empty10;
    }
  ) + '"';
};

// output/Data.Show/index.js
var showString = {
  show: showStringImpl
};
var showNumber = {
  show: showNumberImpl
};
var showInt = {
  show: showIntImpl
};
var showChar = {
  show: showCharImpl
};
var show = function(dict) {
  return dict.show;
};

// output/Data.Maybe/index.js
var identity4 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
}();
var Just = /* @__PURE__ */ function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
}();
var semigroupMaybe = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return v1;
        }
        ;
        if (v1 instanceof Nothing) {
          return v;
        }
        ;
        if (v instanceof Just && v1 instanceof Just) {
          return new Just(append110(v.value0)(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 182, column 1 - line 185, column 43): " + [v.constructor.name, v1.constructor.name]);
      };
    }
  };
};
var monoidMaybe = function(dictSemigroup) {
  var semigroupMaybe1 = semigroupMaybe(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupMaybe1;
    }
  };
};
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));
var functorMaybe = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      ;
      return Nothing.value;
    };
  }
};
var map2 = /* @__PURE__ */ map(functorMaybe);
var fromMaybe = function(a) {
  return maybe(a)(identity4);
};
var fromJust = function() {
  return function(v) {
    if (v instanceof Just) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
  };
};
var eqMaybe = function(dictEq) {
  var eq27 = eq(dictEq);
  return {
    eq: function(x) {
      return function(y) {
        if (x instanceof Nothing && y instanceof Nothing) {
          return true;
        }
        ;
        if (x instanceof Just && y instanceof Just) {
          return eq27(x.value0)(y.value0);
        }
        ;
        return false;
      };
    }
  };
};
var applyMaybe = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return map2(v.value0)(v1);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var bindMaybe = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v1(v.value0);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyMaybe;
  }
};
var applicativeMaybe = /* @__PURE__ */ function() {
  return {
    pure: Just.create,
    Apply0: function() {
      return applyMaybe;
    }
  };
}();
var altMaybe = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Nothing) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var plusMaybe = /* @__PURE__ */ function() {
  return {
    empty: Nothing.value,
    Alt0: function() {
      return altMaybe;
    }
  };
}();
var alternativeMaybe = {
  Applicative0: function() {
    return applicativeMaybe;
  },
  Plus1: function() {
    return plusMaybe;
  }
};

// output/Data.Either/index.js
var Left = /* @__PURE__ */ function() {
  function Left2(value0) {
    this.value0 = value0;
  }
  ;
  Left2.create = function(value0) {
    return new Left2(value0);
  };
  return Left2;
}();
var Right = /* @__PURE__ */ function() {
  function Right2(value0) {
    this.value0 = value0;
  }
  ;
  Right2.create = function(value0) {
    return new Right2(value0);
  };
  return Right2;
}();
var functorEither = {
  map: function(f) {
    return function(m) {
      if (m instanceof Left) {
        return new Left(m.value0);
      }
      ;
      if (m instanceof Right) {
        return new Right(f(m.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map3 = /* @__PURE__ */ map(functorEither);
var either = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Left) {
        return v(v2.value0);
      }
      ;
      if (v2 instanceof Right) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var hush = /* @__PURE__ */ function() {
  return either($$const(Nothing.value))(Just.create);
}();
var applyEither = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return new Left(v.value0);
      }
      ;
      if (v instanceof Right) {
        return map3(v.value0)(v1);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorEither;
  }
};
var bindEither = {
  bind: /* @__PURE__ */ either(function(e) {
    return function(v) {
      return new Left(e);
    };
  })(function(a) {
    return function(f) {
      return f(a);
    };
  }),
  Apply0: function() {
    return applyEither;
  }
};

// output/Data.Identity/index.js
var Identity = function(x) {
  return x;
};
var functorIdentity = {
  map: function(f) {
    return function(m) {
      return f(m);
    };
  }
};
var applyIdentity = {
  apply: function(v) {
    return function(v1) {
      return v(v1);
    };
  },
  Functor0: function() {
    return functorIdentity;
  }
};
var bindIdentity = {
  bind: function(v) {
    return function(f) {
      return f(v);
    };
  },
  Apply0: function() {
    return applyIdentity;
  }
};
var applicativeIdentity = {
  pure: Identity,
  Apply0: function() {
    return applyIdentity;
  }
};
var monadIdentity = {
  Applicative0: function() {
    return applicativeIdentity;
  },
  Bind1: function() {
    return bindIdentity;
  }
};

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0) return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0) return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};
var div = function(dict) {
  return dict.div;
};

// output/Data.Monoid/index.js
var semigroupRecord2 = /* @__PURE__ */ semigroupRecord();
var monoidUnit = {
  mempty: unit,
  Semigroup0: function() {
    return semigroupUnit;
  }
};
var monoidString = {
  mempty: "",
  Semigroup0: function() {
    return semigroupString;
  }
};
var monoidRecordNil = {
  memptyRecord: function(v) {
    return {};
  },
  SemigroupRecord0: function() {
    return semigroupRecordNil;
  }
};
var monoidArray = {
  mempty: [],
  Semigroup0: function() {
    return semigroupArray;
  }
};
var memptyRecord = function(dict) {
  return dict.memptyRecord;
};
var monoidRecord = function() {
  return function(dictMonoidRecord) {
    var semigroupRecord1 = semigroupRecord2(dictMonoidRecord.SemigroupRecord0());
    return {
      mempty: memptyRecord(dictMonoidRecord)($$Proxy.value),
      Semigroup0: function() {
        return semigroupRecord1;
      }
    };
  };
};
var mempty = function(dict) {
  return dict.mempty;
};
var monoidRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  var semigroupRecordCons2 = semigroupRecordCons(dictIsSymbol)();
  return function(dictMonoid) {
    var mempty15 = mempty(dictMonoid);
    var Semigroup0 = dictMonoid.Semigroup0();
    return function() {
      return function(dictMonoidRecord) {
        var memptyRecord1 = memptyRecord(dictMonoidRecord);
        var semigroupRecordCons1 = semigroupRecordCons2(dictMonoidRecord.SemigroupRecord0())(Semigroup0);
        return {
          memptyRecord: function(v) {
            var tail2 = memptyRecord1($$Proxy.value);
            var key = reflectSymbol2($$Proxy.value);
            var insert10 = unsafeSet(key);
            return insert10(mempty15)(tail2);
          },
          SemigroupRecord0: function() {
            return semigroupRecordCons1;
          }
        };
      };
    };
  };
};
var guard = function(dictMonoid) {
  var mempty15 = mempty(dictMonoid);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return mempty15;
      }
      ;
      throw new Error("Failed pattern match at Data.Monoid (line 96, column 1 - line 96, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};

// output/Effect/foreign.js
var pureE = function(a) {
  return function() {
    return a;
  };
};
var bindE = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};

// output/Effect/index.js
var $runtime_lazy = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var monadEffect = {
  Applicative0: function() {
    return applicativeEffect;
  },
  Bind1: function() {
    return bindEffect;
  }
};
var bindEffect = {
  bind: bindE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var applicativeEffect = {
  pure: pureE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
  return {
    map: liftA1(applicativeEffect)
  };
});
var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
  return {
    apply: ap(monadEffect),
    Functor0: function() {
      return $lazy_functorEffect(0);
    }
  };
});
var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);
var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);
var lift22 = /* @__PURE__ */ lift2(applyEffect);
var semigroupEffect = function(dictSemigroup) {
  return {
    append: lift22(append(dictSemigroup))
  };
};
var monoidEffect = function(dictMonoid) {
  var semigroupEffect1 = semigroupEffect(dictMonoid.Semigroup0());
  return {
    mempty: pureE(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupEffect1;
    }
  };
};

// output/Effect.Ref/foreign.js
var _new = function(val) {
  return function() {
    return { value: val };
  };
};
var read = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write = function(val) {
  return function(ref2) {
    return function() {
      ref2.value = val;
    };
  };
};

// output/Effect.Ref/index.js
var $$void2 = /* @__PURE__ */ $$void(functorEffect);
var $$new = _new;
var modify$prime = modifyImpl;
var modify = function(f) {
  return modify$prime(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var modify_ = function(f) {
  return function(s) {
    return $$void2(modify(f)(s));
  };
};

// output/Control.Monad.Rec.Class/index.js
var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEffect);
var map4 = /* @__PURE__ */ map(functorEffect);
var Loop = /* @__PURE__ */ function() {
  function Loop2(value0) {
    this.value0 = value0;
  }
  ;
  Loop2.create = function(value0) {
    return new Loop2(value0);
  };
  return Loop2;
}();
var Done = /* @__PURE__ */ function() {
  function Done2(value0) {
    this.value0 = value0;
  }
  ;
  Done2.create = function(value0) {
    return new Done2(value0);
  };
  return Done2;
}();
var tailRecM = function(dict) {
  return dict.tailRecM;
};
var tailRec = function(f) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Loop) {
        $copy_v = f(v.value0);
        return;
      }
      ;
      if (v instanceof Done) {
        $tco_done = true;
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 103, column 3 - line 103, column 25): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return function($85) {
    return go(f($85));
  };
};
var monadRecIdentity = {
  tailRecM: function(f) {
    var runIdentity = function(v) {
      return v;
    };
    var $86 = tailRec(function($88) {
      return runIdentity(f($88));
    });
    return function($87) {
      return Identity($86($87));
    };
  },
  Monad0: function() {
    return monadIdentity;
  }
};
var monadRecEffect = {
  tailRecM: function(f) {
    return function(a) {
      var fromDone = function(v) {
        if (v instanceof Done) {
          return v.value0;
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 137, column 30 - line 137, column 44): " + [v.constructor.name]);
      };
      return function __do3() {
        var r = bindFlipped2($$new)(f(a))();
        (function() {
          while (!function __do4() {
            var v = read(r)();
            if (v instanceof Loop) {
              var e = f(v.value0)();
              write(e)(r)();
              return false;
            }
            ;
            if (v instanceof Done) {
              return true;
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 128, column 22 - line 133, column 28): " + [v.constructor.name]);
          }()) {
          }
          ;
          return {};
        })();
        return map4(fromDone)(read(r))();
      };
    };
  },
  Monad0: function() {
    return monadEffect;
  }
};
var bifunctorStep = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Loop) {
          return new Loop(v(v2.value0));
        }
        ;
        if (v2 instanceof Done) {
          return new Done(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 33, column 1 - line 35, column 34): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Control.Monad.ST.Internal/foreign.js
var map_ = function(f) {
  return function(a) {
    return function() {
      return f(a());
    };
  };
};
var pure_ = function(a) {
  return function() {
    return a;
  };
};
var bind_ = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};
function newSTRef(val) {
  return function() {
    return { value: val };
  };
}
var read2 = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl2 = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write2 = function(a) {
  return function(ref2) {
    return function() {
      return ref2.value = a;
    };
  };
};

// output/Control.Monad.ST.Internal/index.js
var $runtime_lazy2 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var modify$prime2 = modifyImpl2;
var modify2 = function(f) {
  return modify$prime2(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var functorST = {
  map: map_
};
var monadST = {
  Applicative0: function() {
    return applicativeST;
  },
  Bind1: function() {
    return bindST;
  }
};
var bindST = {
  bind: bind_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var applicativeST = {
  pure: pure_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2("applyST", "Control.Monad.ST.Internal", function() {
  return {
    apply: ap(monadST),
    Functor0: function() {
      return functorST;
    }
  };
});

// output/Data.Array.ST/foreign.js
function newSTArray() {
  return [];
}
function unsafeFreezeThawImpl(xs) {
  return xs;
}
var unsafeFreezeImpl = unsafeFreezeThawImpl;
function copyImpl(xs) {
  return xs.slice();
}
var thawImpl = copyImpl;
var pushImpl = function(a, xs) {
  return xs.push(a);
};

// output/Control.Monad.ST.Uncurried/foreign.js
var runSTFn1 = function runSTFn12(fn) {
  return function(a) {
    return function() {
      return fn(a);
    };
  };
};
var runSTFn2 = function runSTFn22(fn) {
  return function(a) {
    return function(b) {
      return function() {
        return fn(a, b);
      };
    };
  };
};

// output/Data.Array.ST/index.js
var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);
var thaw = /* @__PURE__ */ runSTFn1(thawImpl);
var withArray = function(f) {
  return function(xs) {
    return function __do3() {
      var result = thaw(xs)();
      f(result)();
      return unsafeFreeze(result)();
    };
  };
};
var push = /* @__PURE__ */ runSTFn2(pushImpl);

// output/Data.HeytingAlgebra/foreign.js
var boolConj = function(b1) {
  return function(b2) {
    return b1 && b2;
  };
};
var boolDisj = function(b1) {
  return function(b2) {
    return b1 || b2;
  };
};
var boolNot = function(b) {
  return !b;
};

// output/Data.HeytingAlgebra/index.js
var tt = function(dict) {
  return dict.tt;
};
var not = function(dict) {
  return dict.not;
};
var implies = function(dict) {
  return dict.implies;
};
var ff = function(dict) {
  return dict.ff;
};
var disj = function(dict) {
  return dict.disj;
};
var heytingAlgebraBoolean = {
  ff: false,
  tt: true,
  implies: function(a) {
    return function(b) {
      return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
    };
  },
  conj: boolConj,
  disj: boolDisj,
  not: boolNot
};
var conj = function(dict) {
  return dict.conj;
};
var heytingAlgebraFunction = function(dictHeytingAlgebra) {
  var ff1 = ff(dictHeytingAlgebra);
  var tt1 = tt(dictHeytingAlgebra);
  var implies1 = implies(dictHeytingAlgebra);
  var conj1 = conj(dictHeytingAlgebra);
  var disj1 = disj(dictHeytingAlgebra);
  var not1 = not(dictHeytingAlgebra);
  return {
    ff: function(v) {
      return ff1;
    },
    tt: function(v) {
      return tt1;
    },
    implies: function(f) {
      return function(g) {
        return function(a) {
          return implies1(f(a))(g(a));
        };
      };
    },
    conj: function(f) {
      return function(g) {
        return function(a) {
          return conj1(f(a))(g(a));
        };
      };
    },
    disj: function(f) {
      return function(g) {
        return function(a) {
          return disj1(f(a))(g(a));
        };
      };
    },
    not: function(f) {
      return function(a) {
        return not1(f(a));
      };
    }
  };
};

// output/Data.Array.ST.Iterator/index.js
var map5 = /* @__PURE__ */ map(functorST);
var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);
var $$void3 = /* @__PURE__ */ $$void(functorST);
var Iterator = /* @__PURE__ */ function() {
  function Iterator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Iterator2.create = function(value0) {
    return function(value12) {
      return new Iterator2(value0, value12);
    };
  };
  return Iterator2;
}();
var peek = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    return v.value0(i);
  };
};
var next = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    modify2(function(v1) {
      return v1 + 1 | 0;
    })(v.value1)();
    return v.value0(i);
  };
};
var pushWhile = function(p) {
  return function(iter) {
    return function(array2) {
      return function __do3() {
        var $$break = newSTRef(false)();
        while (map5(not2)(read2($$break))()) {
          (function __do4() {
            var mx = peek(iter)();
            if (mx instanceof Just && p(mx.value0)) {
              push(mx.value0)(array2)();
              return $$void3(next(iter))();
            }
            ;
            return $$void3(write2(true)($$break))();
          })();
        }
        ;
        return {};
      };
    };
  };
};
var iterator = function(f) {
  return map5(Iterator.create(f))(newSTRef(0));
};
var iterate = function(iter) {
  return function(f) {
    return function __do3() {
      var $$break = newSTRef(false)();
      while (map5(not2)(read2($$break))()) {
        (function __do4() {
          var mx = next(iter)();
          if (mx instanceof Just) {
            return f(mx.value0)();
          }
          ;
          if (mx instanceof Nothing) {
            return $$void3(write2(true)($$break))();
          }
          ;
          throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [mx.constructor.name]);
        })();
      }
      ;
      return {};
    };
  };
};

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init3) {
    return function(xs) {
      var acc = init3;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init3) {
    return function(xs) {
      var acc = init3;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Control.Plus/index.js
var plusArray = {
  empty: [],
  Alt0: function() {
    return altArray;
  }
};
var empty = function(dict) {
  return dict.empty;
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ function() {
  function Tuple2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value12) {
      return new Tuple2(value0, value12);
    };
  };
  return Tuple2;
}();
var uncurry = function(f) {
  return function(v) {
    return f(v.value0)(v.value1);
  };
};
var snd = function(v) {
  return v.value1;
};
var semigroupTuple = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return function(dictSemigroup1) {
    var append22 = append(dictSemigroup1);
    return {
      append: function(v) {
        return function(v1) {
          return new Tuple(append110(v.value0)(v1.value0), append22(v.value1)(v1.value1));
        };
      }
    };
  };
};
var monoidTuple = function(dictMonoid) {
  var mempty11 = mempty(dictMonoid);
  var semigroupTuple1 = semigroupTuple(dictMonoid.Semigroup0());
  return function(dictMonoid1) {
    var semigroupTuple2 = semigroupTuple1(dictMonoid1.Semigroup0());
    return {
      mempty: new Tuple(mempty11, mempty(dictMonoid1)),
      Semigroup0: function() {
        return semigroupTuple2;
      }
    };
  };
};
var functorTuple = {
  map: function(f) {
    return function(m) {
      return new Tuple(m.value0, f(m.value1));
    };
  }
};
var fst = function(v) {
  return v.value0;
};
var curry = function(f) {
  return function(a) {
    return function(b) {
      return f(new Tuple(a, b));
    };
  };
};
var applyTuple = function(dictSemigroup) {
  var append110 = append(dictSemigroup);
  return {
    apply: function(v) {
      return function(v1) {
        return new Tuple(append110(v.value0)(v1.value0), v.value1(v1.value1));
      };
    },
    Functor0: function() {
      return functorTuple;
    }
  };
};
var applicativeTuple = function(dictMonoid) {
  var applyTuple1 = applyTuple(dictMonoid.Semigroup0());
  return {
    pure: Tuple.create(mempty(dictMonoid)),
    Apply0: function() {
      return applyTuple1;
    }
  };
};

// output/Data.Bifunctor/index.js
var identity5 = /* @__PURE__ */ identity(categoryFn);
var bimap = function(dict) {
  return dict.bimap;
};
var lmap = function(dictBifunctor) {
  var bimap1 = bimap(dictBifunctor);
  return function(f) {
    return bimap1(f)(identity5);
  };
};
var bifunctorEither = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return new Left(v(v2.value0));
        }
        ;
        if (v2 instanceof Right) {
          return new Right(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Data.Maybe.First/index.js
var semigroupFirst = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v;
      }
      ;
      return v1;
    };
  }
};
var monoidFirst = /* @__PURE__ */ function() {
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupFirst;
    }
  };
}();

// output/Data.Monoid.Disj/index.js
var Disj = function(x) {
  return x;
};
var semigroupDisj = function(dictHeytingAlgebra) {
  var disj2 = disj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return disj2(v)(v1);
      };
    }
  };
};
var monoidDisj = function(dictHeytingAlgebra) {
  var semigroupDisj1 = semigroupDisj(dictHeytingAlgebra);
  return {
    mempty: ff(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupDisj1;
    }
  };
};

// output/Unsafe.Coerce/foreign.js
var unsafeCoerce2 = function(x) {
  return x;
};

// output/Safe.Coerce/index.js
var coerce = function() {
  return unsafeCoerce2;
};

// output/Data.Newtype/index.js
var coerce2 = /* @__PURE__ */ coerce();
var wrap = function() {
  return coerce2;
};
var wrap1 = /* @__PURE__ */ wrap();
var unwrap = function() {
  return coerce2;
};
var unwrap1 = /* @__PURE__ */ unwrap();
var un = function() {
  return function(v) {
    return unwrap1;
  };
};
var over = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var alaF = function() {
  return function() {
    return function() {
      return function() {
        return function(v) {
          return coerce2;
        };
      };
    };
  };
};
var ala = function() {
  return function() {
    return function() {
      return function(v) {
        return function(f) {
          return coerce2(f(wrap1));
        };
      };
    };
  };
};

// output/Data.Foldable/index.js
var identity6 = /* @__PURE__ */ identity(categoryFn);
var eq12 = /* @__PURE__ */ eq(eqOrdering);
var unwrap2 = /* @__PURE__ */ unwrap();
var alaF2 = /* @__PURE__ */ alaF()()()();
var foldr = function(dict) {
  return dict.foldr;
};
var oneOf = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    return foldr22(alt(dictPlus.Alt0()))(empty(dictPlus));
  };
};
var oneOfMap = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    var alt19 = alt(dictPlus.Alt0());
    var empty10 = empty(dictPlus);
    return function(f) {
      return foldr22(function($453) {
        return alt19(f($453));
      })(empty10);
    };
  };
};
var traverse_ = function(dictApplicative) {
  var applySecond3 = applySecond(dictApplicative.Apply0());
  var pure35 = pure(dictApplicative);
  return function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(f) {
      return foldr22(function($454) {
        return applySecond3(f($454));
      })(pure35(unit));
    };
  };
};
var for_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return flip(traverse_1(dictFoldable));
  };
};
var sequence_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return traverse_1(dictFoldable)(identity6);
  };
};
var foldl = function(dict) {
  return dict.foldl;
};
var intercalate = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictMonoid) {
    var append20 = append(dictMonoid.Semigroup0());
    var mempty11 = mempty(dictMonoid);
    return function(sep2) {
      return function(xs) {
        var go = function(v) {
          return function(v1) {
            if (v.init) {
              return {
                init: false,
                acc: v1
              };
            }
            ;
            return {
              init: false,
              acc: append20(v.acc)(append20(sep2)(v1))
            };
          };
        };
        return foldl22(go)({
          init: true,
          acc: mempty11
        })(xs).acc;
      };
    };
  };
};
var maximumBy = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(cmp) {
    var max$prime = function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return new Just(v1);
        }
        ;
        if (v instanceof Just) {
          return new Just(function() {
            var $303 = eq12(cmp(v.value0)(v1))(GT.value);
            if ($303) {
              return v.value0;
            }
            ;
            return v1;
          }());
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
    return foldl22(max$prime)(Nothing.value);
  };
};
var foldableTuple = {
  foldr: function(f) {
    return function(z) {
      return function(v) {
        return f(v.value1)(z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      return function(v) {
        return f(z)(v.value1);
      };
    };
  },
  foldMap: function(dictMonoid) {
    return function(f) {
      return function(v) {
        return f(v.value1);
      };
    };
  }
};
var foldableMaybe = {
  foldr: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldl: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v1)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty11 = mempty(dictMonoid);
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return mempty11;
        }
        ;
        if (v1 instanceof Just) {
          return v(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  }
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append20 = append(dictMonoid.Semigroup0());
    var mempty11 = mempty(dictMonoid);
    return function(f) {
      return foldr22(function(x) {
        return function(acc) {
          return append20(f(x))(acc);
        };
      })(mempty11);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};
var foldMap = function(dict) {
  return dict.foldMap;
};
var lookup = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable)(monoidFirst);
  return function(dictEq) {
    var eq27 = eq(dictEq);
    return function(a) {
      var $460 = foldMap22(function(v) {
        var $444 = eq27(a)(v.value0);
        if ($444) {
          return new Just(v.value1);
        }
        ;
        return Nothing.value;
      });
      return function($461) {
        return unwrap2($460($461));
      };
    };
  };
};
var fold = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable);
  return function(dictMonoid) {
    return foldMap22(dictMonoid)(identity6);
  };
};
var any = function(dictFoldable) {
  var foldMap22 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Disj)(foldMap22(monoidDisj(dictHeytingAlgebra)));
  };
};
var elem = function(dictFoldable) {
  var any1 = any(dictFoldable)(heytingAlgebraBoolean);
  return function(dictEq) {
    var $462 = eq(dictEq);
    return function($463) {
      return any1($462($463));
    };
  };
};

// output/Data.Function.Uncurried/foreign.js
var mkFn5 = function(fn) {
  return function(a, b, c, d, e) {
    return fn(a)(b)(c)(d)(e);
  };
};
var runFn2 = function(fn) {
  return function(a) {
    return function(b) {
      return fn(a, b);
    };
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.FunctorWithIndex/foreign.js
var mapWithIndexArray = function(f) {
  return function(xs) {
    var l = xs.length;
    var result = Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(i)(xs[i]);
    }
    return result;
  };
};

// output/Data.FunctorWithIndex/index.js
var mapWithIndex = function(dict) {
  return dict.mapWithIndex;
};
var functorWithIndexArray = {
  mapWithIndex: mapWithIndexArray,
  Functor0: function() {
    return functorArray;
  }
};

// output/Data.Traversable/foreign.js
var traverseArrayImpl = /* @__PURE__ */ function() {
  function array1(a) {
    return [a];
  }
  function array2(a) {
    return function(b) {
      return [a, b];
    };
  }
  function array3(a) {
    return function(b) {
      return function(c) {
        return [a, b, c];
      };
    };
  }
  function concat22(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }
  return function(apply11) {
    return function(map44) {
      return function(pure35) {
        return function(f) {
          return function(array4) {
            function go(bot, top3) {
              switch (top3 - bot) {
                case 0:
                  return pure35([]);
                case 1:
                  return map44(array1)(f(array4[bot]));
                case 2:
                  return apply11(map44(array2)(f(array4[bot])))(f(array4[bot + 1]));
                case 3:
                  return apply11(apply11(map44(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                default:
                  var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                  return apply11(map44(concat22)(go(bot, pivot)))(go(pivot, top3));
              }
            }
            return go(0, array4.length);
          };
        };
      };
    };
  };
}();

// output/Data.Traversable/index.js
var identity7 = /* @__PURE__ */ identity(categoryFn);
var traverse = function(dict) {
  return dict.traverse;
};
var traversableTuple = {
  traverse: function(dictApplicative) {
    var map44 = map(dictApplicative.Apply0().Functor0());
    return function(f) {
      return function(v) {
        return map44(Tuple.create(v.value0))(f(v.value1));
      };
    };
  },
  sequence: function(dictApplicative) {
    var map44 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return map44(Tuple.create(v.value0))(v.value1);
    };
  },
  Functor0: function() {
    return functorTuple;
  },
  Foldable1: function() {
    return foldableTuple;
  }
};
var traversableMaybe = {
  traverse: function(dictApplicative) {
    var pure35 = pure(dictApplicative);
    var map44 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return pure35(Nothing.value);
        }
        ;
        if (v1 instanceof Just) {
          return map44(Just.create)(v(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  sequence: function(dictApplicative) {
    var pure35 = pure(dictApplicative);
    var map44 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      if (v instanceof Nothing) {
        return pure35(Nothing.value);
      }
      ;
      if (v instanceof Just) {
        return map44(Just.create)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  },
  Foldable1: function() {
    return foldableMaybe;
  }
};
var sequenceDefault = function(dictTraversable) {
  var traverse22 = traverse(dictTraversable);
  return function(dictApplicative) {
    return traverse22(dictApplicative)(identity7);
  };
};
var traversableArray = {
  traverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
  },
  sequence: function(dictApplicative) {
    return sequenceDefault(traversableArray)(dictApplicative);
  },
  Functor0: function() {
    return functorArray;
  },
  Foldable1: function() {
    return foldableArray;
  }
};
var sequence = function(dict) {
  return dict.sequence;
};
var $$for = function(dictApplicative) {
  return function(dictTraversable) {
    var traverse22 = traverse(dictTraversable)(dictApplicative);
    return function(x) {
      return function(f) {
        return traverse22(f)(x);
      };
    };
  };
};

// output/Data.Unfoldable/foreign.js
var unfoldrArrayImpl = function(isNothing2) {
  return function(fromJust10) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value3 = b;
            while (true) {
              var maybe2 = f(value3);
              if (isNothing2(maybe2)) return result;
              var tuple = fromJust10(maybe2);
              result.push(fst2(tuple));
              value3 = snd2(tuple);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/foreign.js
var unfoldr1ArrayImpl = function(isNothing2) {
  return function(fromJust10) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value3 = b;
            while (true) {
              var tuple = f(value3);
              result.push(fst2(tuple));
              var maybe2 = snd2(tuple);
              if (isNothing2(maybe2)) return result;
              value3 = fromJust10(maybe2);
            }
          };
        };
      };
    };
  };
};

// output/Data.Ord.Min/index.js
var Min = function(x) {
  return x;
};
var semigroupMin = function(dictOrd) {
  var min5 = min(dictOrd);
  return {
    append: function(v) {
      return function(v1) {
        return min5(v)(v1);
      };
    }
  };
};

// output/Data.Semigroup.Foldable/index.js
var ala2 = /* @__PURE__ */ ala()()();
var foldMap1 = function(dict) {
  return dict.foldMap1;
};
var minimum2 = function(dictOrd) {
  var semigroupMin2 = semigroupMin(dictOrd);
  return function(dictFoldable1) {
    return ala2(Min)(foldMap1(dictFoldable1)(semigroupMin2));
  };
};

// output/Data.Unfoldable1/index.js
var fromJust2 = /* @__PURE__ */ fromJust();
var unfoldable1Array = {
  unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
};

// output/Data.Unfoldable/index.js
var fromJust3 = /* @__PURE__ */ fromJust();
var unfoldr = function(dict) {
  return dict.unfoldr;
};
var unfoldableArray = {
  unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
  Unfoldable10: function() {
    return unfoldable1Array;
  }
};

// output/Data.Array/index.js
var $$void4 = /* @__PURE__ */ $$void(functorST);
var intercalate1 = /* @__PURE__ */ intercalate(foldableArray);
var apply2 = /* @__PURE__ */ apply(applyMaybe);
var map6 = /* @__PURE__ */ map(functorMaybe);
var fold1 = /* @__PURE__ */ fold(foldableArray);
var append2 = /* @__PURE__ */ append(semigroupArray);
var unsafeIndex = function() {
  return runFn2(unsafeIndexImpl);
};
var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();
var uncons = /* @__PURE__ */ function() {
  return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {
    return function(xs) {
      return new Just({
        head: x,
        tail: xs
      });
    };
  });
}();
var sortBy = function(comp) {
  return runFn3(sortByImpl)(comp)(function(v) {
    if (v instanceof GT) {
      return 1;
    }
    ;
    if (v instanceof EQ) {
      return 0;
    }
    ;
    if (v instanceof LT) {
      return -1 | 0;
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 897, column 38 - line 900, column 11): " + [v.constructor.name]);
  });
};
var sort = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(xs) {
    return sortBy(compare7)(xs);
  };
};
var snoc = function(xs) {
  return function(x) {
    return withArray(push(x))(xs)();
  };
};
var slice = /* @__PURE__ */ runFn3(sliceImpl);
var singleton2 = function(a) {
  return [a];
};
var replicate = /* @__PURE__ */ runFn2(replicateImpl);
var range2 = /* @__PURE__ */ runFn2(rangeImpl);
var $$null = function(xs) {
  return length(xs) === 0;
};
var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var intercalate2 = function(dictMonoid) {
  return intercalate1(dictMonoid);
};
var init = function(xs) {
  if ($$null(xs)) {
    return Nothing.value;
  }
  ;
  if (otherwise) {
    return new Just(slice(0)(length(xs) - 1 | 0)(xs));
  }
  ;
  throw new Error("Failed pattern match at Data.Array (line 351, column 1 - line 351, column 45): " + [xs.constructor.name]);
};
var index = /* @__PURE__ */ function() {
  return runFn4(indexImpl)(Just.create)(Nothing.value);
}();
var last = function(xs) {
  return index(xs)(length(xs) - 1 | 0);
};
var unsnoc = function(xs) {
  return apply2(map6(function(v) {
    return function(v1) {
      return {
        init: v,
        last: v1
      };
    };
  })(init(xs)))(last(xs));
};
var head = function(xs) {
  return index(xs)(0);
};
var groupBy = function(op) {
  return function(xs) {
    return function __do3() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function(x) {
        return $$void4(function __do4() {
          var sub1 = newSTArray();
          push(x)(sub1)();
          pushWhile(op(x))(iter)(sub1)();
          var grp = unsafeFreeze(sub1)();
          return push(grp)(result)();
        });
      })();
      return unsafeFreeze(result)();
    }();
  };
};
var fromFoldable = function(dictFoldable) {
  return runFn2(fromFoldableImpl)(foldr(dictFoldable));
};
var foldr2 = /* @__PURE__ */ foldr(foldableArray);
var foldl2 = /* @__PURE__ */ foldl(foldableArray);
var fold2 = function(dictMonoid) {
  return fold1(dictMonoid);
};
var findIndex = /* @__PURE__ */ function() {
  return runFn4(findIndexImpl)(Just.create)(Nothing.value);
}();
var find2 = function(f) {
  return function(xs) {
    return map6(unsafeIndex1(xs))(findIndex(f)(xs));
  };
};
var filter = /* @__PURE__ */ runFn2(filterImpl);
var elemIndex = function(dictEq) {
  var eq27 = eq(dictEq);
  return function(x) {
    return findIndex(function(v) {
      return eq27(v)(x);
    });
  };
};
var elem2 = function(dictEq) {
  var elemIndex1 = elemIndex(dictEq);
  return function(a) {
    return function(arr) {
      return isJust(elemIndex1(a)(arr));
    };
  };
};
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};
var cons = function(x) {
  return function(xs) {
    return append2([x])(xs);
  };
};
var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
var mapMaybe = function(f) {
  return concatMap(function() {
    var $189 = maybe([])(singleton2);
    return function($190) {
      return $189(f($190));
    };
  }());
};
var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));
var any2 = /* @__PURE__ */ runFn2(anyImpl);

// output/Data.String.Common/foreign.js
var replaceAll = function(s1) {
  return function(s2) {
    return function(s3) {
      return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
    };
  };
};
var split = function(sep2) {
  return function(s) {
    return s.split(sep2);
  };
};
var toLower = function(s) {
  return s.toLowerCase();
};
var toUpper = function(s) {
  return s.toUpperCase();
};
var joinWith = function(s) {
  return function(xs) {
    return xs.join(s);
  };
};

// output/Data.String.Common/index.js
var $$null2 = function(s) {
  return s === "";
};

// output/JSON/foreign.js
var coerce3 = (x) => x;
var fromString = coerce3;
var fromJArray = coerce3;
var fromJObject = coerce3;

// output/Data.Int/foreign.js
var fromNumberImpl = function(just) {
  return function(nothing) {
    return function(n) {
      return (n | 0) === n ? just(n) : nothing;
    };
  };
};
var toNumber = function(n) {
  return n;
};
var fromStringAsImpl = function(just) {
  return function(nothing) {
    return function(radix) {
      var digits;
      if (radix < 11) {
        digits = "[0-" + (radix - 1).toString() + "]";
      } else if (radix === 11) {
        digits = "[0-9a]";
      } else {
        digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
      }
      var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");
      return function(s) {
        if (pattern.test(s)) {
          var i = parseInt(s, radix);
          return (i | 0) === i ? just(i) : nothing;
        } else {
          return nothing;
        }
      };
    };
  };
};

// output/Data.Number/foreign.js
var infinity = Infinity;
var isFiniteImpl = isFinite;
var floor = Math.floor;
var round = Math.round;

// output/Data.Int/index.js
var top2 = /* @__PURE__ */ top(boundedInt);
var bottom2 = /* @__PURE__ */ bottom(boundedInt);
var fromStringAs = /* @__PURE__ */ function() {
  return fromStringAsImpl(Just.create)(Nothing.value);
}();
var fromString2 = /* @__PURE__ */ fromStringAs(10);
var fromNumber = /* @__PURE__ */ function() {
  return fromNumberImpl(Just.create)(Nothing.value);
}();
var unsafeClamp = function(x) {
  if (!isFiniteImpl(x)) {
    return 0;
  }
  ;
  if (x >= toNumber(top2)) {
    return top2;
  }
  ;
  if (x <= toNumber(bottom2)) {
    return bottom2;
  }
  ;
  if (otherwise) {
    return fromMaybe(0)(fromNumber(x));
  }
  ;
  throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
};
var round2 = function($37) {
  return unsafeClamp(round($37));
};
var floor2 = function($39) {
  return unsafeClamp(floor($39));
};

// output/JSON.Internal/foreign.js
var toString = Object.prototype.toString;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var _parse = (left, right, s) => {
  try {
    return right(JSON.parse(s));
  } catch (e) {
    return left(e.message);
  }
};
var _case = (isNull3, isBool, isNum, isStr, isArr, isObj, j) => {
  if (j == null) return isNull3(null);
  const ty = typeof j;
  if (ty === "boolean") return isBool(j);
  if (ty === "number") return isNum(j);
  if (ty === "string") return isStr(j);
  if (toString.call(j) === "[object Array]") return isArr(j);
  return isObj(j);
};
var toArray = (js) => js;
var fromArray = (js) => js;
var _fromEntries = (fst2, snd2, entries2) => {
  const result = {};
  for (var i = 0; i < entries2.length; i++) {
    result[fst2(entries2[i])] = snd2(entries2[i]);
  }
  return result;
};
var _entries = (tuple, obj) => Object.entries(obj).map(([k, v]) => tuple(k)(v));
var _lookup = (nothing, just, key, obj) => hasOwnProperty2.call(obj, key) ? just(obj[key]) : nothing;

// output/JSON/index.js
var parse = function(j) {
  return _parse(Left.create, Right.create, j);
};
var fromArray2 = function(js) {
  return fromJArray(fromArray(js));
};
var fail = function(v) {
  return Nothing.value;
};
var toJArray = function(json2) {
  return _case(fail, fail, fail, fail, Just.create, fail, json2);
};
var toJObject = function(json2) {
  return _case(fail, fail, fail, fail, fail, Just.create, json2);
};
var toString2 = function(json2) {
  return _case(fail, fail, fail, Just.create, fail, fail, json2);
};

// output/Data.FoldableWithIndex/index.js
var foldr8 = /* @__PURE__ */ foldr(foldableArray);
var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var foldl8 = /* @__PURE__ */ foldl(foldableArray);
var foldrWithIndex = function(dict) {
  return dict.foldrWithIndex;
};
var foldlWithIndex = function(dict) {
  return dict.foldlWithIndex;
};
var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {
  var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
  return function(dictMonoid) {
    var append20 = append(dictMonoid.Semigroup0());
    var mempty11 = mempty(dictMonoid);
    return function(f) {
      return foldrWithIndex1(function(i) {
        return function(x) {
          return function(acc) {
            return append20(f(i)(x))(acc);
          };
        };
      })(mempty11);
    };
  };
};
var foldableWithIndexArray = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $291 = foldr8(function(v) {
        return function(y) {
          return f(v.value0)(v.value1)(y);
        };
      })(z);
      var $292 = mapWithIndex3(Tuple.create);
      return function($293) {
        return $291($292($293));
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $294 = foldl8(function(y) {
        return function(v) {
          return f(v.value0)(y)(v.value1);
        };
      })(z);
      var $295 = mapWithIndex3(Tuple.create);
      return function($296) {
        return $294($295($296));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
  },
  Foldable0: function() {
    return foldableArray;
  }
};
var findMapWithIndex = function(dictFoldableWithIndex) {
  var foldlWithIndex1 = foldlWithIndex(dictFoldableWithIndex);
  return function(f) {
    var go = function(v) {
      return function(v1) {
        return function(v2) {
          if (v1 instanceof Nothing) {
            return f(v)(v2);
          }
          ;
          return v1;
        };
      };
    };
    return foldlWithIndex1(go)(Nothing.value);
  };
};

// output/JSON.Object/index.js
var lookup2 = function(k) {
  return function(obj) {
    return _lookup(Nothing.value, Just.create, k, obj);
  };
};
var keys = function(obj) {
  return _entries(function(k) {
    return function(v) {
      return k;
    };
  }, obj);
};
var fromEntries = function(kvs) {
  return _fromEntries(fst, snd, kvs);
};
var fromFoldable2 = function(dictFoldable) {
  var fromFoldable110 = fromFoldable(dictFoldable);
  return function(kvs) {
    return fromEntries(fromFoldable110(kvs));
  };
};
var fromFoldableWithIndex = function(dictFoldableWithIndex) {
  var foldrWithIndex2 = foldrWithIndex(dictFoldableWithIndex);
  return function(kvs) {
    return fromEntries(foldrWithIndex2(function(k) {
      return function(v) {
        return cons(new Tuple(k, v));
      };
    })([])(kvs));
  };
};
var entries = function(obj) {
  return _entries(Tuple.create, obj);
};

// output/JSON.Path/index.js
var show1 = /* @__PURE__ */ show(showInt);
var Tip = /* @__PURE__ */ function() {
  function Tip2() {
  }
  ;
  Tip2.value = new Tip2();
  return Tip2;
}();
var AtKey = /* @__PURE__ */ function() {
  function AtKey2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtKey2.create = function(value0) {
    return function(value12) {
      return new AtKey2(value0, value12);
    };
  };
  return AtKey2;
}();
var AtIndex = /* @__PURE__ */ function() {
  function AtIndex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtIndex2.create = function(value0) {
    return function(value12) {
      return new AtIndex2(value0, value12);
    };
  };
  return AtIndex2;
}();
var eqPath = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Tip && y instanceof Tip) {
        return true;
      }
      ;
      if (x instanceof AtKey && y instanceof AtKey) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      if (x instanceof AtIndex && y instanceof AtIndex) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      return false;
    };
  }
};
var stripPrefix = function($copy_v) {
  return function($copy_v1) {
    var $tco_var_v = $copy_v;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v, v1) {
      if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof Tip) {
        $tco_done = true;
        return new Just(v1);
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_v, $copy_v1);
    }
    ;
    return $tco_result;
  };
};
var print2 = function(path2) {
  var go = function(p) {
    if (p instanceof Tip) {
      return "";
    }
    ;
    if (p instanceof AtKey) {
      return "." + (p.value0 + go(p.value1));
    }
    ;
    if (p instanceof AtIndex) {
      return "[" + (show1(p.value0) + ("]" + go(p.value1)));
    }
    ;
    throw new Error("Failed pattern match at JSON.Path (line 41, column 10 - line 44, column 56): " + [p.constructor.name]);
  };
  return "$" + go(path2);
};
var findCommonPrefix = function(v) {
  return function(v1) {
    if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
      return new AtKey(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
      return new AtIndex(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    return Tip.value;
  };
};

// output/Codec.JSON.DecodeError/index.js
var append1 = /* @__PURE__ */ append(semigroupArray);
var eq13 = /* @__PURE__ */ eq(eqPath);
var over2 = /* @__PURE__ */ over()();
var map7 = /* @__PURE__ */ map(functorArray);
var DecodeError = function(x) {
  return x;
};
var semigroupDecodeError = {
  append: function(v) {
    return function(v1) {
      return {
        path: findCommonPrefix(v.path)(v1.path),
        message: "Failed to decode alternatives",
        causes: append1(function() {
          var $50 = v.message === "Failed to decode alternatives";
          if ($50) {
            return v.causes;
          }
          ;
          return [v];
        }())(function() {
          var $51 = v1.message === "Failed to decode alternatives";
          if ($51) {
            return v1.causes;
          }
          ;
          return [v1];
        }())
      };
    };
  }
};
var withPath = function(f) {
  return over2(DecodeError)(function(err) {
    return {
      message: err.message,
      path: f(err.path),
      causes: map7(withPath(f))(err.causes)
    };
  });
};
var withContext = function(message3) {
  return over2(DecodeError)(function(err) {
    return {
      path: err.path,
      message: message3,
      causes: [err]
    };
  });
};
var print3 = function(v) {
  var pathPart = function() {
    var $61 = eq13(v.path)(Tip.value);
    if ($61) {
      return "";
    }
    ;
    return print2(v.path) + ": ";
  }();
  var causes = map7(function(e) {
    return replaceAll("\n")(function() {
      var $62 = length(v.causes) === 1;
      if ($62) {
        return "\n  ";
      }
      ;
      return "\n    ";
    }())(print3(withPath(function(p) {
      return fromMaybe(p)(stripPrefix(v.path)(p));
    })(e)));
  })(v.causes);
  var details = function() {
    var v1 = length(v.causes);
    if (v1 === 0) {
      return "";
    }
    ;
    if (v1 === 1) {
      return ":\n  " + joinWith("\n  ")(causes);
    }
    ;
    return ":\n  - " + joinWith("\n  - ")(causes);
  }();
  return pathPart + (v.message + details);
};
var error = function(path2) {
  return function(message3) {
    return {
      path: path2,
      message: message3,
      causes: []
    };
  };
};
var noValueFound = function(path2) {
  return error(path2)("No value found");
};
var basic = /* @__PURE__ */ function() {
  return error(Tip.value);
}();

// output/Effect.Exception/foreign.js
function error2(msg) {
  return new Error(msg);
}
function message(e) {
  return e.message;
}
function throwException(e) {
  return function() {
    throw e;
  };
}
function catchException(c) {
  return function(t) {
    return function() {
      try {
        return t();
      } catch (e) {
        if (e instanceof Error || Object.prototype.toString.call(e) === "[object Error]") {
          return c(e)();
        } else {
          return c(new Error(e.toString()))();
        }
      }
    };
  };
}

// output/Effect.Exception/index.js
var pure2 = /* @__PURE__ */ pure(applicativeEffect);
var map8 = /* @__PURE__ */ map(functorEffect);
var $$try = function(action) {
  return catchException(function($3) {
    return pure2(Left.create($3));
  })(map8(Right.create)(action));
};
var $$throw = function($4) {
  return throwException(error2($4));
};

// output/Control.Monad.Error.Class/index.js
var throwError = function(dict) {
  return dict.throwError;
};
var catchError = function(dict) {
  return dict.catchError;
};
var $$try2 = function(dictMonadError) {
  var catchError1 = catchError(dictMonadError);
  var Monad0 = dictMonadError.MonadThrow0().Monad0();
  var map44 = map(Monad0.Bind1().Apply0().Functor0());
  var pure35 = pure(Monad0.Applicative0());
  return function(a) {
    return catchError1(map44(Right.create)(a))(function($52) {
      return pure35(Left.create($52));
    });
  };
};

// output/Control.Monad.Reader.Class/index.js
var ask = function(dict) {
  return dict.ask;
};
var asks = function(dictMonadAsk) {
  var map44 = map(dictMonadAsk.Monad0().Bind1().Apply0().Functor0());
  var ask1 = ask(dictMonadAsk);
  return function(f) {
    return map44(f)(ask1);
  };
};

// output/Control.Monad.State.Class/index.js
var state = function(dict) {
  return dict.state;
};
var put = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(s) {
    return state1(function(v) {
      return new Tuple(unit, s);
    });
  };
};
var modify_2 = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(f) {
    return state1(function(s) {
      return new Tuple(unit, f(s));
    });
  };
};
var get = function(dictMonadState) {
  return state(dictMonadState)(function(s) {
    return new Tuple(s, s);
  });
};

// output/Control.Monad.Trans.Class/index.js
var lift = function(dict) {
  return dict.lift;
};

// output/Effect.Class/index.js
var liftEffect = function(dict) {
  return dict.liftEffect;
};

// output/Control.Monad.Except.Trans/index.js
var map9 = /* @__PURE__ */ map(functorEither);
var ExceptT = function(x) {
  return x;
};
var withExceptT = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return function(f) {
    return function(v) {
      var mapLeft = function(v1) {
        return function(v2) {
          if (v2 instanceof Right) {
            return new Right(v2.value0);
          }
          ;
          if (v2 instanceof Left) {
            return new Left(v1(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 43, column 3 - line 43, column 32): " + [v1.constructor.name, v2.constructor.name]);
        };
      };
      return map118(mapLeft(f))(v);
    };
  };
};
var runExceptT = function(v) {
  return v;
};
var monadTransExceptT = {
  lift: function(dictMonad) {
    var bind30 = bind(dictMonad.Bind1());
    var pure35 = pure(dictMonad.Applicative0());
    return function(m) {
      return bind30(m)(function(a) {
        return pure35(new Right(a));
      });
    };
  }
};
var mapExceptT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorExceptT = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return {
    map: function(f) {
      return mapExceptT(map118(map9(f)));
    }
  };
};
var except = function(dictApplicative) {
  var $191 = pure(dictApplicative);
  return function($192) {
    return ExceptT($191($192));
  };
};
var monadExceptT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeExceptT(dictMonad);
    },
    Bind1: function() {
      return bindExceptT(dictMonad);
    }
  };
};
var bindExceptT = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  var pure35 = pure(dictMonad.Applicative0());
  return {
    bind: function(v) {
      return function(k) {
        return bind30(v)(either(function($193) {
          return pure35(Left.create($193));
        })(function(a) {
          var v1 = k(a);
          return v1;
        }));
      };
    },
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var applyExceptT = function(dictMonad) {
  var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadExceptT(dictMonad)),
    Functor0: function() {
      return functorExceptT1;
    }
  };
};
var applicativeExceptT = function(dictMonad) {
  return {
    pure: function() {
      var $194 = pure(dictMonad.Applicative0());
      return function($195) {
        return ExceptT($194(Right.create($195)));
      };
    }(),
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var monadThrowExceptT = function(dictMonad) {
  var monadExceptT1 = monadExceptT(dictMonad);
  return {
    throwError: function() {
      var $204 = pure(dictMonad.Applicative0());
      return function($205) {
        return ExceptT($204(Left.create($205)));
      };
    }(),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var altExceptT = function(dictSemigroup) {
  var append20 = append(dictSemigroup);
  return function(dictMonad) {
    var Bind1 = dictMonad.Bind1();
    var bind30 = bind(Bind1);
    var pure35 = pure(dictMonad.Applicative0());
    var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
    return {
      alt: function(v) {
        return function(v1) {
          return bind30(v)(function(rm3) {
            if (rm3 instanceof Right) {
              return pure35(new Right(rm3.value0));
            }
            ;
            if (rm3 instanceof Left) {
              return bind30(v1)(function(rn) {
                if (rn instanceof Right) {
                  return pure35(new Right(rn.value0));
                }
                ;
                if (rn instanceof Left) {
                  return pure35(new Left(append20(rm3.value0)(rn.value0)));
                }
                ;
                throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 87, column 9 - line 89, column 49): " + [rn.constructor.name]);
              });
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 83, column 5 - line 89, column 49): " + [rm3.constructor.name]);
          });
        };
      },
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
};

// output/Control.Monad.Except/index.js
var unwrap3 = /* @__PURE__ */ unwrap();
var withExcept = /* @__PURE__ */ withExceptT(functorIdentity);
var runExcept = function($3) {
  return unwrap3(runExceptT($3));
};

// output/Data.Codec/index.js
var map10 = /* @__PURE__ */ map(functorTuple);
var Codec = /* @__PURE__ */ function() {
  function Codec2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Codec2.create = function(value0) {
    return function(value12) {
      return new Codec2(value0, value12);
    };
  };
  return Codec2;
}();
var profunctorCodec = function(dictFunctor) {
  var map118 = map(dictFunctor);
  return {
    dimap: function(f) {
      return function(g) {
        return function(v) {
          return new Codec(function() {
            var $91 = map118(g);
            return function($92) {
              return $91(v.value0($92));
            };
          }(), function() {
            var $93 = map10(g);
            return function($94) {
              return $93(v.value1(f($94)));
            };
          }());
        };
      };
    }
  };
};
var encode = function(v) {
  return function($100) {
    return fst(v.value1($100));
  };
};
var decode = function(v) {
  return v.value0;
};
var codec$prime = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};
var codec = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};

// output/Data.TraversableWithIndex/index.js
var traverseWithIndexDefault = function(dictTraversableWithIndex) {
  var sequence3 = sequence(dictTraversableWithIndex.Traversable2());
  var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());
  return function(dictApplicative) {
    var sequence12 = sequence3(dictApplicative);
    return function(f) {
      var $174 = mapWithIndex4(f);
      return function($175) {
        return sequence12($174($175));
      };
    };
  };
};
var traverseWithIndex = function(dict) {
  return dict.traverseWithIndex;
};
var traversableWithIndexArray = {
  traverseWithIndex: function(dictApplicative) {
    return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
  },
  FunctorWithIndex0: function() {
    return functorWithIndexArray;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexArray;
  },
  Traversable2: function() {
    return traversableArray;
  }
};

// output/Data.NonEmpty/index.js
var NonEmpty = /* @__PURE__ */ function() {
  function NonEmpty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  NonEmpty2.create = function(value0) {
    return function(value12) {
      return new NonEmpty2(value0, value12);
    };
  };
  return NonEmpty2;
}();
var foldableNonEmpty = function(dictFoldable) {
  var foldMap5 = foldMap(dictFoldable);
  var foldl3 = foldl(dictFoldable);
  var foldr9 = foldr(dictFoldable);
  return {
    foldMap: function(dictMonoid) {
      var append110 = append(dictMonoid.Semigroup0());
      var foldMap13 = foldMap5(dictMonoid);
      return function(f) {
        return function(v) {
          return append110(f(v.value0))(foldMap13(f)(v.value1));
        };
      };
    },
    foldl: function(f) {
      return function(b) {
        return function(v) {
          return foldl3(f)(f(b)(v.value0))(v.value1);
        };
      };
    },
    foldr: function(f) {
      return function(b) {
        return function(v) {
          return f(v.value0)(foldr9(f)(b)(v.value1));
        };
      };
    }
  };
};
var foldable1NonEmpty = function(dictFoldable) {
  var foldl3 = foldl(dictFoldable);
  var foldr9 = foldr(dictFoldable);
  var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);
  return {
    foldMap1: function(dictSemigroup) {
      var append110 = append(dictSemigroup);
      return function(f) {
        return function(v) {
          return foldl3(function(s) {
            return function(a1) {
              return append110(s)(f(a1));
            };
          })(f(v.value0))(v.value1);
        };
      };
    },
    foldr1: function(f) {
      return function(v) {
        return maybe(v.value0)(f(v.value0))(foldr9(function(a1) {
          var $250 = maybe(a1)(f(a1));
          return function($251) {
            return Just.create($250($251));
          };
        })(Nothing.value)(v.value1));
      };
    },
    foldl1: function(f) {
      return function(v) {
        return foldl3(f)(v.value0)(v.value1);
      };
    },
    Foldable0: function() {
      return foldableNonEmpty1;
    }
  };
};

// output/Data.List.Types/index.js
var Nil = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var foldableList = {
  foldr: function(f) {
    return function(b) {
      var rev = function() {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 instanceof Nil) {
                $tco_done = true;
                return v;
              }
              ;
              if (v1 instanceof Cons) {
                $tco_var_v = new Cons(v1.value0, v);
                $copy_v1 = v1.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(Nil.value);
      }();
      var $284 = foldl(foldableList)(flip(f))(b);
      return function($285) {
        return $284(rev($285));
      };
    };
  },
  foldl: function(f) {
    var go = function($copy_b) {
      return function($copy_v) {
        var $tco_var_b = $copy_b;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(b, v) {
          if (v instanceof Nil) {
            $tco_done1 = true;
            return b;
          }
          ;
          if (v instanceof Cons) {
            $tco_var_b = f(b)(v.value0);
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_b, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append22 = append(dictMonoid.Semigroup0());
    var mempty11 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList)(function(acc) {
        var $286 = append22(acc);
        return function($287) {
          return $286(f($287));
        };
      })(mempty11);
    };
  }
};
var foldr3 = /* @__PURE__ */ foldr(foldableList);
var semigroupList = {
  append: function(xs) {
    return function(ys) {
      return foldr3(Cons.create)(ys)(xs);
    };
  }
};
var monoidList = /* @__PURE__ */ function() {
  return {
    mempty: Nil.value,
    Semigroup0: function() {
      return semigroupList;
    }
  };
}();

// output/Data.String.CodePoints/foreign.js
var hasArrayFrom = typeof Array.from === "function";
var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
var hasCodePointAt = typeof String.prototype.codePointAt === "function";
var _unsafeCodePointAt0 = function(fallback) {
  return hasCodePointAt ? function(str2) {
    return str2.codePointAt(0);
  } : fallback;
};
var _codePointAt = function(fallback) {
  return function(Just2) {
    return function(Nothing2) {
      return function(unsafeCodePointAt02) {
        return function(index5) {
          return function(str2) {
            var length8 = str2.length;
            if (index5 < 0 || index5 >= length8) return Nothing2;
            if (hasStringIterator) {
              var iter = str2[Symbol.iterator]();
              for (var i = index5; ; --i) {
                var o = iter.next();
                if (o.done) return Nothing2;
                if (i === 0) return Just2(unsafeCodePointAt02(o.value));
              }
            }
            return fallback(index5)(str2);
          };
        };
      };
    };
  };
};
var _singleton = function(fallback) {
  return hasFromCodePoint ? String.fromCodePoint : fallback;
};
var _take = function(fallback) {
  return function(n) {
    if (hasStringIterator) {
      return function(str2) {
        var accum = "";
        var iter = str2[Symbol.iterator]();
        for (var i = 0; i < n; ++i) {
          var o = iter.next();
          if (o.done) return accum;
          accum += o.value;
        }
        return accum;
      };
    }
    return fallback(n);
  };
};
var _toCodePointArray = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasArrayFrom) {
      return function(str2) {
        return Array.from(str2, unsafeCodePointAt02);
      };
    }
    return fallback;
  };
};

// output/Data.Enum/foreign.js
function toCharCode(c) {
  return c.charCodeAt(0);
}
function fromCharCode(c) {
  return String.fromCharCode(c);
}

// output/Control.Alternative/index.js
var guard2 = function(dictAlternative) {
  var pure35 = pure(dictAlternative.Applicative0());
  var empty10 = empty(dictAlternative.Plus1());
  return function(v) {
    if (v) {
      return pure35(unit);
    }
    ;
    if (!v) {
      return empty10;
    }
    ;
    throw new Error("Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): " + [v.constructor.name]);
  };
};
var alternativeArray = {
  Applicative0: function() {
    return applicativeArray;
  },
  Plus1: function() {
    return plusArray;
  }
};

// output/Data.Enum/index.js
var bottom1 = /* @__PURE__ */ bottom(boundedChar);
var top1 = /* @__PURE__ */ top(boundedChar);
var toEnum = function(dict) {
  return dict.toEnum;
};
var fromEnum = function(dict) {
  return dict.fromEnum;
};
var toEnumWithDefaults = function(dictBoundedEnum) {
  var toEnum1 = toEnum(dictBoundedEnum);
  var fromEnum12 = fromEnum(dictBoundedEnum);
  var bottom22 = bottom(dictBoundedEnum.Bounded0());
  return function(low) {
    return function(high) {
      return function(x) {
        var v = toEnum1(x);
        if (v instanceof Just) {
          return v.value0;
        }
        ;
        if (v instanceof Nothing) {
          var $140 = x < fromEnum12(bottom22);
          if ($140) {
            return low;
          }
          ;
          return high;
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v.constructor.name]);
      };
    };
  };
};
var defaultSucc = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) + 1 | 0);
    };
  };
};
var defaultPred = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) - 1 | 0);
    };
  };
};
var charToEnum = function(v) {
  if (v >= toCharCode(bottom1) && v <= toCharCode(top1)) {
    return new Just(fromCharCode(v));
  }
  ;
  return Nothing.value;
};
var enumChar = {
  succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
  pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
  Ord0: function() {
    return ordChar;
  }
};
var boundedEnumChar = /* @__PURE__ */ function() {
  return {
    cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
    toEnum: charToEnum,
    fromEnum: toCharCode,
    Bounded0: function() {
      return boundedChar;
    },
    Enum1: function() {
      return enumChar;
    }
  };
}();

// output/Data.String.CodeUnits/foreign.js
var fromCharArray = function(a) {
  return a.join("");
};
var toCharArray = function(s) {
  return s.split("");
};
var singleton5 = function(c) {
  return c;
};
var length3 = function(s) {
  return s.length;
};
var _indexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.indexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var take = function(n) {
  return function(s) {
    return s.substr(0, n);
  };
};
var drop2 = function(n) {
  return function(s) {
    return s.substring(n);
  };
};
var slice2 = function(b) {
  return function(e) {
    return function(s) {
      return s.slice(b, e);
    };
  };
};
var splitAt = function(i) {
  return function(s) {
    return { before: s.substring(0, i), after: s.substring(i) };
  };
};

// output/Data.String.Unsafe/foreign.js
var charAt = function(i) {
  return function(s) {
    if (i >= 0 && i < s.length) return s.charAt(i);
    throw new Error("Data.String.Unsafe.charAt: Invalid index.");
  };
};

// output/Data.String.CodeUnits/index.js
var stripSuffix = function(v) {
  return function(str2) {
    var v1 = splitAt(length3(str2) - length3(v) | 0)(str2);
    var $14 = v1.after === v;
    if ($14) {
      return new Just(v1.before);
    }
    ;
    return Nothing.value;
  };
};
var stripPrefix2 = function(v) {
  return function(str2) {
    var v1 = splitAt(length3(v))(str2);
    var $20 = v1.before === v;
    if ($20) {
      return new Just(v1.after);
    }
    ;
    return Nothing.value;
  };
};
var indexOf = /* @__PURE__ */ function() {
  return _indexOf(Just.create)(Nothing.value);
}();

// output/Data.String.CodePoints/index.js
var $runtime_lazy3 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var map11 = /* @__PURE__ */ map(functorMaybe);
var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
var div2 = /* @__PURE__ */ div(euclideanRingInt);
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var compare2 = /* @__PURE__ */ compare(ordInt);
var unsurrogate = function(lead) {
  return function(trail) {
    return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
  };
};
var isTrail = function(cu) {
  return 56320 <= cu && cu <= 57343;
};
var isLead = function(cu) {
  return 55296 <= cu && cu <= 56319;
};
var uncons2 = function(s) {
  var v = length3(s);
  if (v === 0) {
    return Nothing.value;
  }
  ;
  if (v === 1) {
    return new Just({
      head: fromEnum2(charAt(0)(s)),
      tail: ""
    });
  }
  ;
  var cu1 = fromEnum2(charAt(1)(s));
  var cu0 = fromEnum2(charAt(0)(s));
  var $43 = isLead(cu0) && isTrail(cu1);
  if ($43) {
    return new Just({
      head: unsurrogate(cu0)(cu1),
      tail: drop2(2)(s)
    });
  }
  ;
  return new Just({
    head: cu0,
    tail: drop2(1)(s)
  });
};
var unconsButWithTuple = function(s) {
  return map11(function(v) {
    return new Tuple(v.head, v.tail);
  })(uncons2(s));
};
var toCodePointArrayFallback = function(s) {
  return unfoldr2(unconsButWithTuple)(s);
};
var unsafeCodePointAt0Fallback = function(s) {
  var cu0 = fromEnum2(charAt(0)(s));
  var $47 = isLead(cu0) && length3(s) > 1;
  if ($47) {
    var cu1 = fromEnum2(charAt(1)(s));
    var $48 = isTrail(cu1);
    if ($48) {
      return unsurrogate(cu0)(cu1);
    }
    ;
    return cu0;
  }
  ;
  return cu0;
};
var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
var length4 = function($74) {
  return length(toCodePointArray($74));
};
var indexOf2 = function(p) {
  return function(s) {
    return map11(function(i) {
      return length4(take(i)(s));
    })(indexOf(p)(s));
  };
};
var fromCharCode2 = /* @__PURE__ */ function() {
  var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
  return function($76) {
    return singleton5($75($76));
  };
}();
var singletonFallback = function(v) {
  if (v <= 65535) {
    return fromCharCode2(v);
  }
  ;
  var lead = div2(v - 65536 | 0)(1024) + 55296 | 0;
  var trail = mod2(v - 65536 | 0)(1024) + 56320 | 0;
  return fromCharCode2(lead) + fromCharCode2(trail);
};
var singleton6 = /* @__PURE__ */ _singleton(singletonFallback);
var takeFallback = function(v) {
  return function(v1) {
    if (v < 1) {
      return "";
    }
    ;
    var v2 = uncons2(v1);
    if (v2 instanceof Just) {
      return singleton6(v2.value0.head) + takeFallback(v - 1 | 0)(v2.value0.tail);
    }
    ;
    return v1;
  };
};
var take2 = /* @__PURE__ */ _take(takeFallback);
var eqCodePoint = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordCodePoint = {
  compare: function(x) {
    return function(y) {
      return compare2(x)(y);
    };
  },
  Eq0: function() {
    return eqCodePoint;
  }
};
var drop3 = function(n) {
  return function(s) {
    return drop2(length3(take2(n)(s)))(s);
  };
};
var codePointAtFallback = function($copy_n) {
  return function($copy_s) {
    var $tco_var_n = $copy_n;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(n, s) {
      var v = uncons2(s);
      if (v instanceof Just) {
        var $66 = n === 0;
        if ($66) {
          $tco_done = true;
          return new Just(v.value0.head);
        }
        ;
        $tco_var_n = n - 1 | 0;
        $copy_s = v.value0.tail;
        return;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_n, $copy_s);
    }
    ;
    return $tco_result;
  };
};
var codePointAt = function(v) {
  return function(v1) {
    if (v < 0) {
      return Nothing.value;
    }
    ;
    if (v === 0 && v1 === "") {
      return Nothing.value;
    }
    ;
    if (v === 0) {
      return new Just(unsafeCodePointAt0(v1));
    }
    ;
    return _codePointAt(codePointAtFallback)(Just.create)(Nothing.value)(unsafeCodePointAt0)(v)(v1);
  };
};
var boundedCodePoint = {
  bottom: 0,
  top: 1114111,
  Ord0: function() {
    return ordCodePoint;
  }
};
var boundedEnumCodePoint = /* @__PURE__ */ function() {
  return {
    cardinality: 1114111 + 1 | 0,
    fromEnum: function(v) {
      return v;
    },
    toEnum: function(n) {
      if (n >= 0 && n <= 1114111) {
        return new Just(n);
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.String.CodePoints (line 63, column 1 - line 68, column 26): " + [n.constructor.name]);
    },
    Bounded0: function() {
      return boundedCodePoint;
    },
    Enum1: function() {
      return $lazy_enumCodePoint(0);
    }
  };
}();
var $lazy_enumCodePoint = /* @__PURE__ */ $runtime_lazy3("enumCodePoint", "Data.String.CodePoints", function() {
  return {
    succ: defaultSucc(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    pred: defaultPred(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    Ord0: function() {
      return ordCodePoint;
    }
  };
});

// output/Data.Codec.JSON/index.js
var applicativeExceptT2 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var pure3 = /* @__PURE__ */ pure(applicativeExceptT2);
var except2 = /* @__PURE__ */ except(applicativeIdentity);
var bindExceptT2 = /* @__PURE__ */ bindExceptT(monadIdentity);
var bindFlipped1 = /* @__PURE__ */ bindFlipped(bindExceptT2);
var fromFoldable1 = /* @__PURE__ */ fromFoldable2(foldableList);
var bind2 = /* @__PURE__ */ bind(bindExceptT2);
var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeExceptT2);
var map1 = /* @__PURE__ */ map(functorArray);
var record = /* @__PURE__ */ function() {
  return new Codec($$const(pure3({})), pure(applicativeTuple(monoidList)));
}();
var jsonPrimCodec = function(ty) {
  return function(f) {
    return codec$prime(function(j) {
      return except2(function() {
        var v = f(j);
        if (v instanceof Just) {
          return new Right(v.value0);
        }
        ;
        if (v instanceof Nothing) {
          return new Left({
            path: Tip.value,
            message: "Expected value of type " + ty,
            causes: []
          });
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 81, column 12 - line 89, column 10): " + [v.constructor.name]);
      }());
    });
  };
};
var string = /* @__PURE__ */ jsonPrimCodec("String")(toString2)(fromString);
var json = /* @__PURE__ */ codec$prime(pure3)(/* @__PURE__ */ identity(categoryFn));
var jobject = /* @__PURE__ */ jsonPrimCodec("Object")(toJObject)(fromJObject);
var jarray = /* @__PURE__ */ jsonPrimCodec("Array")(toJArray)(fromJArray);
var encode2 = encode;
var object = function(codec2) {
  return codec$prime(function(j) {
    return bindFlipped1(decode(codec2))(decode(jobject)(j));
  })(function(a) {
    return encode2(jobject)(fromFoldable1(encode2(codec2)(a)));
  });
};
var decode2 = function(codec2) {
  return function(j) {
    return runExcept(decode(codec2)(j));
  };
};
var prismaticCodec = function(name3) {
  return function(f) {
    return function(g) {
      return function(codec2) {
        return codec$prime(function(j) {
          return except2(function() {
            var v = decode2(codec2)(j);
            if (v instanceof Left) {
              return new Left(withContext("Could not decode " + name3)(v.value0));
            }
            ;
            if (v instanceof Right) {
              var v1 = f(v.value0);
              if (v1 instanceof Just) {
                return new Right(v1.value0);
              }
              ;
              if (v1 instanceof Nothing) {
                return new Left(basic("Could not decode " + (name3 + ", unexpected value found")));
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON (line 424, column 13 - line 428, column 95): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Data.Codec.JSON (line 420, column 18 - line 428, column 95): " + [v.constructor.name]);
          }());
        })(function(b) {
          return encode2(codec2)(g(b));
        });
      };
    };
  };
};
var recordProp = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var enc$prime = function(key2) {
          return function(val) {
            return new Cons(new Tuple(key2, encode(codecA)(unsafeGet(key2)(val))), encode(codecR)(val));
          };
        };
        var dec$prime = function(key2) {
          return function(obj) {
            return bind2(decode(codecR)(obj))(function(r) {
              return bind2(except2(function() {
                var v = lookup2(key2)(obj);
                if (v instanceof Just) {
                  var v1 = decode2(codecA)(v.value0);
                  if (v1 instanceof Left) {
                    return new Left(withPath(AtKey.create(key2))(v1.value0));
                  }
                  ;
                  return v1;
                }
                ;
                if (v instanceof Nothing) {
                  return new Left(noValueFound(new AtKey(key2, Tip.value)));
                }
                ;
                throw new Error("Failed pattern match at Data.Codec.JSON (line 279, column 16 - line 285, column 56): " + [v.constructor.name]);
              }()))(function(a) {
                return pure3(unsafeSet(key2)(a)(r));
              });
            });
          };
        };
        var key = reflectSymbol2($$Proxy.value);
        return codec(dec$prime(key))(enc$prime(key));
      };
    };
  };
};
var array = function(codec2) {
  return codec$prime(function(j) {
    return bind2(decode(jarray)(j))(function(arr) {
      return traverseWithIndex2(function(ix) {
        return function(a) {
          return except2(function() {
            var v = decode2(codec2)(a);
            if (v instanceof Left) {
              return new Left(withPath(AtIndex.create(ix))(v.value0));
            }
            ;
            return v;
          }());
        };
      })(toArray(arr));
    });
  })(function(a) {
    return fromArray2(map1(encode2(codec2))(a));
  });
};

// output/Data.Map.Internal/index.js
var $runtime_lazy4 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var Leaf = /* @__PURE__ */ function() {
  function Leaf3() {
  }
  ;
  Leaf3.value = new Leaf3();
  return Leaf3;
}();
var Node = /* @__PURE__ */ function() {
  function Node2(value0, value12, value22, value3, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  Node2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return function(value4) {
            return function(value5) {
              return new Node2(value0, value12, value22, value3, value4, value5);
            };
          };
        };
      };
    };
  };
  return Node2;
}();
var IterLeaf = /* @__PURE__ */ function() {
  function IterLeaf2() {
  }
  ;
  IterLeaf2.value = new IterLeaf2();
  return IterLeaf2;
}();
var IterEmit = /* @__PURE__ */ function() {
  function IterEmit2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  IterEmit2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new IterEmit2(value0, value12, value22);
      };
    };
  };
  return IterEmit2;
}();
var IterNode = /* @__PURE__ */ function() {
  function IterNode2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  IterNode2.create = function(value0) {
    return function(value12) {
      return new IterNode2(value0, value12);
    };
  };
  return IterNode2;
}();
var Split = /* @__PURE__ */ function() {
  function Split2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Split2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Split2(value0, value12, value22);
      };
    };
  };
  return Split2;
}();
var SplitLast = /* @__PURE__ */ function() {
  function SplitLast2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SplitLast2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SplitLast2(value0, value12, value22);
      };
    };
  };
  return SplitLast2;
}();
var unsafeNode = function(k, v, l, r) {
  if (l instanceof Leaf) {
    if (r instanceof Leaf) {
      return new Node(1, 1, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 702, column 5 - line 706, column 39): " + [r.constructor.name]);
  }
  ;
  if (l instanceof Node) {
    if (r instanceof Leaf) {
      return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + function() {
        var $280 = l.value0 > r.value0;
        if ($280) {
          return l.value0;
        }
        ;
        return r.value0;
      }() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 708, column 5 - line 712, column 68): " + [r.constructor.name]);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 700, column 32 - line 712, column 68): " + [l.constructor.name]);
};
var toMapIter = /* @__PURE__ */ function() {
  return flip(IterNode.create)(IterLeaf.value);
}();
var stepWith = function(f) {
  return function(next2) {
    return function(done) {
      var go = function($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
          if (v instanceof IterLeaf) {
            $tco_done = true;
            return done(unit);
          }
          ;
          if (v instanceof IterEmit) {
            $tco_done = true;
            return next2(v.value0, v.value1, v.value2);
          }
          ;
          if (v instanceof IterNode) {
            $copy_v = f(v.value1)(v.value0);
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 940, column 8 - line 946, column 20): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_v);
        }
        ;
        return $tco_result;
      };
      return go;
    };
  };
};
var size = function(v) {
  if (v instanceof Leaf) {
    return 0;
  }
  ;
  if (v instanceof Node) {
    return v.value1;
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 618, column 8 - line 620, column 24): " + [v.constructor.name]);
};
var singleton7 = function(k) {
  return function(v) {
    return new Node(1, 1, k, v, Leaf.value, Leaf.value);
  };
};
var unsafeBalancedNode = /* @__PURE__ */ function() {
  var height = function(v) {
    if (v instanceof Leaf) {
      return 0;
    }
    ;
    if (v instanceof Node) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 757, column 12 - line 759, column 26): " + [v.constructor.name]);
  };
  var rotateLeft = function(k, v, l, rk, rv, rl, rr) {
    if (rl instanceof Node && rl.value0 > height(rr)) {
      return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));
    }
    ;
    return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);
  };
  var rotateRight = function(k, v, lk, lv, ll, lr, r) {
    if (lr instanceof Node && height(ll) <= lr.value0) {
      return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));
    }
    ;
    return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));
  };
  return function(k, v, l, r) {
    if (l instanceof Leaf) {
      if (r instanceof Leaf) {
        return singleton7(k)(v);
      }
      ;
      if (r instanceof Node && r.value0 > 1) {
        return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    if (l instanceof Node) {
      if (r instanceof Node) {
        if (r.value0 > (l.value0 + 1 | 0)) {
          return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
        }
        ;
        if (l.value0 > (r.value0 + 1 | 0)) {
          return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
        }
        ;
      }
      ;
      if (r instanceof Leaf && l.value0 > 1) {
        return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 717, column 40 - line 738, column 34): " + [l.constructor.name]);
  };
}();
var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy4("unsafeSplit", "Data.Map.Internal", function() {
  return function(comp, k, m) {
    if (m instanceof Leaf) {
      return new Split(Nothing.value, Leaf.value, Leaf.value);
    }
    ;
    if (m instanceof Node) {
      var v = comp(k)(m.value2);
      if (v instanceof LT) {
        var v1 = $lazy_unsafeSplit(793)(comp, k, m.value4);
        return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));
      }
      ;
      if (v instanceof GT) {
        var v1 = $lazy_unsafeSplit(796)(comp, k, m.value5);
        return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);
      }
      ;
      if (v instanceof EQ) {
        return new Split(new Just(m.value3), m.value4, m.value5);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 791, column 5 - line 799, column 30): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 787, column 34 - line 799, column 30): " + [m.constructor.name]);
  };
});
var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(786);
var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy4("unsafeSplitLast", "Data.Map.Internal", function() {
  return function(k, v, l, r) {
    if (r instanceof Leaf) {
      return new SplitLast(k, v, l);
    }
    ;
    if (r instanceof Node) {
      var v1 = $lazy_unsafeSplitLast(779)(r.value2, r.value3, r.value4, r.value5);
      return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 776, column 37 - line 780, column 57): " + [r.constructor.name]);
  };
});
var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(775);
var unsafeJoinNodes = function(v, v1) {
  if (v instanceof Leaf) {
    return v1;
  }
  ;
  if (v instanceof Node) {
    var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);
    return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 764, column 25 - line 768, column 38): " + [v.constructor.name, v1.constructor.name]);
};
var $lazy_unsafeDifference = /* @__PURE__ */ $runtime_lazy4("unsafeDifference", "Data.Map.Internal", function() {
  return function(comp, l, r) {
    if (l instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeDifference(841)(comp, v.value1, r.value4);
      var r$prime = $lazy_unsafeDifference(842)(comp, v.value2, r.value5);
      return unsafeJoinNodes(l$prime, r$prime);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 836, column 39 - line 843, column 33): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeDifference = /* @__PURE__ */ $lazy_unsafeDifference(835);
var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy4("unsafeUnionWith", "Data.Map.Internal", function() {
  return function(comp, app, l, r) {
    if (l instanceof Leaf) {
      return r;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeUnionWith(809)(comp, app, v.value1, r.value4);
      var r$prime = $lazy_unsafeUnionWith(810)(comp, app, v.value2, r.value5);
      if (v.value0 instanceof Just) {
        return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);
      }
      ;
      if (v.value0 instanceof Nothing) {
        return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 811, column 5 - line 815, column 46): " + [v.value0.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 804, column 42 - line 815, column 46): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(803);
var unionWith = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(app) {
    return function(m1) {
      return function(m2) {
        return unsafeUnionWith(compare7, app, m1, m2);
      };
    };
  };
};
var union = function(dictOrd) {
  return unionWith(dictOrd)($$const);
};
var member = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return false;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare7(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 459, column 7 - line 462, column 19): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 456, column 8 - line 462, column 19): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var lookup3 = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare7(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value3);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 283, column 7 - line 286, column 22): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 280, column 8 - line 286, column 22): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var iterMapL = /* @__PURE__ */ function() {
  var go = function($copy_iter) {
    return function($copy_v) {
      var $tco_var_iter = $copy_iter;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(iter, v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return iter;
        }
        ;
        if (v instanceof Node) {
          if (v.value5 instanceof Leaf) {
            $tco_var_iter = new IterEmit(v.value2, v.value3, iter);
            $copy_v = v.value4;
            return;
          }
          ;
          $tco_var_iter = new IterEmit(v.value2, v.value3, new IterNode(v.value5, iter));
          $copy_v = v.value4;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 951, column 13 - line 958, column 48): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_iter, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
}();
var stepAscCps = /* @__PURE__ */ stepWith(iterMapL);
var stepUnfoldr = /* @__PURE__ */ function() {
  var step2 = function(k, v, next2) {
    return new Just(new Tuple(new Tuple(k, v), next2));
  };
  return stepAscCps(step2)(function(v) {
    return Nothing.value;
  });
}();
var toUnfoldable2 = function(dictUnfoldable) {
  var $784 = unfoldr(dictUnfoldable)(stepUnfoldr);
  return function($785) {
    return $784(toMapIter($785));
  };
};
var isEmpty = function(v) {
  if (v instanceof Leaf) {
    return true;
  }
  ;
  return false;
};
var insert = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(k) {
    return function(v) {
      var go = function(v1) {
        if (v1 instanceof Leaf) {
          return singleton7(k)(v);
        }
        ;
        if (v1 instanceof Node) {
          var v2 = compare7(k)(v1.value2);
          if (v2 instanceof LT) {
            return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
          }
          ;
          if (v2 instanceof GT) {
            return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
          }
          ;
          if (v2 instanceof EQ) {
            return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 471, column 7 - line 474, column 35): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 8 - line 474, column 35): " + [v1.constructor.name]);
      };
      return go;
    };
  };
};
var functorMap = {
  map: function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        return new Node(v.value0, v.value1, v.value2, f(v.value3), go(v.value4), go(v.value5));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 147, column 10 - line 150, column 39): " + [v.constructor.name]);
    };
    return go;
  }
};
var foldableMap = {
  foldr: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(172)(m$prime.value4, f(m$prime.value3)($lazy_go(172)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 169, column 26 - line 172, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(169);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(178)(f($lazy_go(178)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 175, column 26 - line 178, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(175);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty11 = mempty(dictMonoid);
    var append110 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty11;
        }
        ;
        if (v instanceof Node) {
          return append110(go(v.value4))(append110(f(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 181, column 10 - line 184, column 28): " + [v.constructor.name]);
      };
      return go;
    };
  }
};
var foldableWithIndexMap = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(192)(m$prime.value4, f(m$prime.value2)(m$prime.value3)($lazy_go(192)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 189, column 26 - line 192, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(189);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(198)(f(m$prime.value2)($lazy_go(198)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 195, column 26 - line 198, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(195);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    var mempty11 = mempty(dictMonoid);
    var append110 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty11;
        }
        ;
        if (v instanceof Node) {
          return append110(go(v.value4))(append110(f(v.value2)(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 201, column 10 - line 204, column 30): " + [v.constructor.name]);
      };
      return go;
    };
  },
  Foldable0: function() {
    return foldableMap;
  }
};
var keys2 = /* @__PURE__ */ function() {
  return foldrWithIndex(foldableWithIndexMap)(function(k) {
    return function(v) {
      return function(acc) {
        return new Cons(k, acc);
      };
    };
  })(Nil.value);
}();
var empty4 = /* @__PURE__ */ function() {
  return Leaf.value;
}();
var fromFoldable4 = function(dictOrd) {
  var insert1 = insert(dictOrd);
  return function(dictFoldable) {
    return foldl(dictFoldable)(function(m) {
      return function(v) {
        return insert1(v.value0)(v.value1)(m);
      };
    })(empty4);
  };
};
var difference = function(dictOrd) {
  var compare7 = compare(dictOrd);
  return function(m1) {
    return function(m2) {
      return unsafeDifference(compare7, m1, m2);
    };
  };
};

// output/Effect.Aff/foreign.js
var Aff = function() {
  var EMPTY = {};
  var PURE = "Pure";
  var THROW = "Throw";
  var CATCH = "Catch";
  var SYNC = "Sync";
  var ASYNC = "Async";
  var BIND = "Bind";
  var BRACKET = "Bracket";
  var FORK = "Fork";
  var SEQ = "Sequential";
  var MAP = "Map";
  var APPLY = "Apply";
  var ALT = "Alt";
  var CONS = "Cons";
  var RESUME = "Resume";
  var RELEASE = "Release";
  var FINALIZER = "Finalizer";
  var FINALIZED = "Finalized";
  var FORKED = "Forked";
  var FIBER = "Fiber";
  var THUNK = "Thunk";
  function Aff2(tag, _1, _2, _3) {
    this.tag = tag;
    this._1 = _1;
    this._2 = _2;
    this._3 = _3;
  }
  function AffCtr(tag) {
    var fn = function(_1, _2, _3) {
      return new Aff2(tag, _1, _2, _3);
    };
    fn.tag = tag;
    return fn;
  }
  function nonCanceler2(error5) {
    return new Aff2(PURE, void 0);
  }
  function runEff(eff) {
    try {
      eff();
    } catch (error5) {
      setTimeout(function() {
        throw error5;
      }, 0);
    }
  }
  function runSync(left, right, eff) {
    try {
      return right(eff());
    } catch (error5) {
      return left(error5);
    }
  }
  function runAsync(left, eff, k) {
    try {
      return eff(k)();
    } catch (error5) {
      k(left(error5))();
      return nonCanceler2;
    }
  }
  var Scheduler = function() {
    var limit = 1024;
    var size6 = 0;
    var ix = 0;
    var queue = new Array(limit);
    var draining = false;
    function drain() {
      var thunk;
      draining = true;
      while (size6 !== 0) {
        size6--;
        thunk = queue[ix];
        queue[ix] = void 0;
        ix = (ix + 1) % limit;
        thunk();
      }
      draining = false;
    }
    return {
      isDraining: function() {
        return draining;
      },
      enqueue: function(cb) {
        var i, tmp;
        if (size6 === limit) {
          tmp = draining;
          drain();
          draining = tmp;
        }
        queue[(ix + size6) % limit] = cb;
        size6++;
        if (!draining) {
          drain();
        }
      }
    };
  }();
  function Supervisor(util) {
    var fibers = {};
    var fiberId = 0;
    var count = 0;
    return {
      register: function(fiber) {
        var fid = fiberId++;
        fiber.onComplete({
          rethrow: true,
          handler: function(result) {
            return function() {
              count--;
              delete fibers[fid];
            };
          }
        })();
        fibers[fid] = fiber;
        count++;
      },
      isEmpty: function() {
        return count === 0;
      },
      killAll: function(killError, cb) {
        return function() {
          if (count === 0) {
            return cb();
          }
          var killCount = 0;
          var kills = {};
          function kill2(fid) {
            kills[fid] = fibers[fid].kill(killError, function(result) {
              return function() {
                delete kills[fid];
                killCount--;
                if (util.isLeft(result) && util.fromLeft(result)) {
                  setTimeout(function() {
                    throw util.fromLeft(result);
                  }, 0);
                }
                if (killCount === 0) {
                  cb();
                }
              };
            })();
          }
          for (var k in fibers) {
            if (fibers.hasOwnProperty(k)) {
              killCount++;
              kill2(k);
            }
          }
          fibers = {};
          fiberId = 0;
          count = 0;
          return function(error5) {
            return new Aff2(SYNC, function() {
              for (var k2 in kills) {
                if (kills.hasOwnProperty(k2)) {
                  kills[k2]();
                }
              }
            });
          };
        };
      }
    };
  }
  var SUSPENDED = 0;
  var CONTINUE = 1;
  var STEP_BIND = 2;
  var STEP_RESULT = 3;
  var PENDING = 4;
  var RETURN = 5;
  var COMPLETED = 6;
  function Fiber(util, supervisor, aff) {
    var runTick = 0;
    var status = SUSPENDED;
    var step2 = aff;
    var fail3 = null;
    var interrupt = null;
    var bhead = null;
    var btail = null;
    var attempts = null;
    var bracketCount = 0;
    var joinId = 0;
    var joins = null;
    var rethrow = true;
    function run3(localRunTick) {
      var tmp, result, attempt;
      while (true) {
        tmp = null;
        result = null;
        attempt = null;
        switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step2 = bhead(step2);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail3 = util.left(e);
              step2 = null;
            }
            break;
          case STEP_RESULT:
            if (util.isLeft(step2)) {
              status = RETURN;
              fail3 = step2;
              step2 = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step2 = util.fromRight(step2);
            }
            break;
          case CONTINUE:
            switch (step2.tag) {
              case BIND:
                if (bhead) {
                  btail = new Aff2(CONS, bhead, btail);
                }
                bhead = step2._2;
                status = CONTINUE;
                step2 = step2._1;
                break;
              case PURE:
                if (bhead === null) {
                  status = RETURN;
                  step2 = util.right(step2._1);
                } else {
                  status = STEP_BIND;
                  step2 = step2._1;
                }
                break;
              case SYNC:
                status = STEP_RESULT;
                step2 = runSync(util.left, util.right, step2._1);
                break;
              case ASYNC:
                status = PENDING;
                step2 = runAsync(util.left, step2._1, function(result2) {
                  return function() {
                    if (runTick !== localRunTick) {
                      return;
                    }
                    runTick++;
                    Scheduler.enqueue(function() {
                      if (runTick !== localRunTick + 1) {
                        return;
                      }
                      status = STEP_RESULT;
                      step2 = result2;
                      run3(runTick);
                    });
                  };
                });
                return;
              case THROW:
                status = RETURN;
                fail3 = util.left(step2._1);
                step2 = null;
                break;
              // Enqueue the Catch so that we can call the error handler later on
              // in case of an exception.
              case CATCH:
                if (bhead === null) {
                  attempts = new Aff2(CONS, step2, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step2 = step2._1;
                break;
              // Enqueue the Bracket so that we can call the appropriate handlers
              // after resource acquisition.
              case BRACKET:
                bracketCount++;
                if (bhead === null) {
                  attempts = new Aff2(CONS, step2, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step2 = step2._1;
                break;
              case FORK:
                status = STEP_RESULT;
                tmp = Fiber(util, supervisor, step2._2);
                if (supervisor) {
                  supervisor.register(tmp);
                }
                if (step2._1) {
                  tmp.run();
                }
                step2 = util.right(tmp);
                break;
              case SEQ:
                status = CONTINUE;
                step2 = sequential3(util, supervisor, step2._1);
                break;
            }
            break;
          case RETURN:
            bhead = null;
            btail = null;
            if (attempts === null) {
              status = COMPLETED;
              step2 = interrupt || fail3 || step2;
            } else {
              tmp = attempts._3;
              attempt = attempts._1;
              attempts = attempts._2;
              switch (attempt.tag) {
                // We cannot recover from an unmasked interrupt. Otherwise we should
                // continue stepping, or run the exception handler if an exception
                // was raised.
                case CATCH:
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    status = RETURN;
                  } else if (fail3) {
                    status = CONTINUE;
                    step2 = attempt._2(util.fromLeft(fail3));
                    fail3 = null;
                  }
                  break;
                // We cannot resume from an unmasked interrupt or exception.
                case RESUME:
                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail3) {
                    status = RETURN;
                  } else {
                    bhead = attempt._1;
                    btail = attempt._2;
                    status = STEP_BIND;
                    step2 = util.fromRight(step2);
                  }
                  break;
                // If we have a bracket, we should enqueue the handlers,
                // and continue with the success branch only if the fiber has
                // not been interrupted. If the bracket acquisition failed, we
                // should not run either.
                case BRACKET:
                  bracketCount--;
                  if (fail3 === null) {
                    result = util.fromRight(step2);
                    attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                    if (interrupt === tmp || bracketCount > 0) {
                      status = CONTINUE;
                      step2 = attempt._3(result);
                    }
                  }
                  break;
                // Enqueue the appropriate handler. We increase the bracket count
                // because it should not be cancelled.
                case RELEASE:
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail3), attempts, interrupt);
                  status = CONTINUE;
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    step2 = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                  } else if (fail3) {
                    step2 = attempt._1.failed(util.fromLeft(fail3))(attempt._2);
                  } else {
                    step2 = attempt._1.completed(util.fromRight(step2))(attempt._2);
                  }
                  fail3 = null;
                  bracketCount++;
                  break;
                case FINALIZER:
                  bracketCount++;
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail3), attempts, interrupt);
                  status = CONTINUE;
                  step2 = attempt._1;
                  break;
                case FINALIZED:
                  bracketCount--;
                  status = RETURN;
                  step2 = attempt._1;
                  fail3 = attempt._2;
                  break;
              }
            }
            break;
          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step2));
              }
            }
            joins = null;
            if (interrupt && fail3) {
              setTimeout(function() {
                throw util.fromLeft(fail3);
              }, 0);
            } else if (util.isLeft(step2) && rethrow) {
              setTimeout(function() {
                if (rethrow) {
                  throw util.fromLeft(step2);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING:
            return;
        }
      }
    }
    function onComplete(join7) {
      return function() {
        if (status === COMPLETED) {
          rethrow = rethrow && join7.rethrow;
          join7.handler(step2)();
          return function() {
          };
        }
        var jid = joinId++;
        joins = joins || {};
        joins[jid] = join7;
        return function() {
          if (joins !== null) {
            delete joins[jid];
          }
        };
      };
    }
    function kill2(error5, cb) {
      return function() {
        if (status === COMPLETED) {
          cb(util.right(void 0))();
          return function() {
          };
        }
        var canceler = onComplete({
          rethrow: false,
          handler: function() {
            return cb(util.right(void 0));
          }
        })();
        switch (status) {
          case SUSPENDED:
            interrupt = util.left(error5);
            status = COMPLETED;
            step2 = interrupt;
            run3(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff2(CONS, new Aff2(FINALIZER, step2(error5)), attempts, interrupt);
              }
              status = RETURN;
              step2 = null;
              fail3 = null;
              run3(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step2 = null;
              fail3 = null;
            }
        }
        return canceler;
      };
    }
    function join6(cb) {
      return function() {
        var canceler = onComplete({
          rethrow: false,
          handler: cb
        })();
        if (status === SUSPENDED) {
          run3(runTick);
        }
        return canceler;
      };
    }
    return {
      kill: kill2,
      join: join6,
      onComplete,
      isSuspended: function() {
        return status === SUSPENDED;
      },
      run: function() {
        if (status === SUSPENDED) {
          if (!Scheduler.isDraining()) {
            Scheduler.enqueue(function() {
              run3(runTick);
            });
          } else {
            run3(runTick);
          }
        }
      }
    };
  }
  function runPar(util, supervisor, par, cb) {
    var fiberId = 0;
    var fibers = {};
    var killId = 0;
    var kills = {};
    var early = new Error("[ParAff] Early exit");
    var interrupt = null;
    var root = EMPTY;
    function kill2(error5, par2, cb2) {
      var step2 = par2;
      var head4 = null;
      var tail2 = null;
      var count = 0;
      var kills2 = {};
      var tmp, kid;
      loop: while (true) {
        tmp = null;
        switch (step2.tag) {
          case FORKED:
            if (step2._3 === EMPTY) {
              tmp = fibers[step2._1];
              kills2[count++] = tmp.kill(error5, function(result) {
                return function() {
                  count--;
                  if (count === 0) {
                    cb2(result)();
                  }
                };
              });
            }
            if (head4 === null) {
              break loop;
            }
            step2 = head4._2;
            if (tail2 === null) {
              head4 = null;
            } else {
              head4 = tail2._1;
              tail2 = tail2._2;
            }
            break;
          case MAP:
            step2 = step2._2;
            break;
          case APPLY:
          case ALT:
            if (head4) {
              tail2 = new Aff2(CONS, head4, tail2);
            }
            head4 = step2;
            step2 = step2._1;
            break;
        }
      }
      if (count === 0) {
        cb2(util.right(void 0))();
      } else {
        kid = 0;
        tmp = count;
        for (; kid < tmp; kid++) {
          kills2[kid] = kills2[kid]();
        }
      }
      return kills2;
    }
    function join6(result, head4, tail2) {
      var fail3, step2, lhs, rhs, tmp, kid;
      if (util.isLeft(result)) {
        fail3 = result;
        step2 = null;
      } else {
        step2 = result;
        fail3 = null;
      }
      loop: while (true) {
        lhs = null;
        rhs = null;
        tmp = null;
        kid = null;
        if (interrupt !== null) {
          return;
        }
        if (head4 === null) {
          cb(fail3 || step2)();
          return;
        }
        if (head4._3 !== EMPTY) {
          return;
        }
        switch (head4.tag) {
          case MAP:
            if (fail3 === null) {
              head4._3 = util.right(head4._1(util.fromRight(step2)));
              step2 = head4._3;
            } else {
              head4._3 = fail3;
            }
            break;
          case APPLY:
            lhs = head4._1._3;
            rhs = head4._2._3;
            if (fail3) {
              head4._3 = fail3;
              tmp = true;
              kid = killId++;
              kills[kid] = kill2(early, fail3 === lhs ? head4._2 : head4._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail2 === null) {
                    join6(fail3, null, null);
                  } else {
                    join6(fail3, tail2._1, tail2._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            } else if (lhs === EMPTY || rhs === EMPTY) {
              return;
            } else {
              step2 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
              head4._3 = step2;
            }
            break;
          case ALT:
            lhs = head4._1._3;
            rhs = head4._2._3;
            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
              return;
            }
            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
              fail3 = step2 === lhs ? rhs : lhs;
              step2 = null;
              head4._3 = fail3;
            } else {
              head4._3 = step2;
              tmp = true;
              kid = killId++;
              kills[kid] = kill2(early, step2 === lhs ? head4._2 : head4._1, function() {
                return function() {
                  delete kills[kid];
                  if (tmp) {
                    tmp = false;
                  } else if (tail2 === null) {
                    join6(step2, null, null);
                  } else {
                    join6(step2, tail2._1, tail2._2);
                  }
                };
              });
              if (tmp) {
                tmp = false;
                return;
              }
            }
            break;
        }
        if (tail2 === null) {
          head4 = null;
        } else {
          head4 = tail2._1;
          tail2 = tail2._2;
        }
      }
    }
    function resolve2(fiber) {
      return function(result) {
        return function() {
          delete fibers[fiber._1];
          fiber._3 = result;
          join6(result, fiber._2._1, fiber._2._2);
        };
      };
    }
    function run3() {
      var status = CONTINUE;
      var step2 = par;
      var head4 = null;
      var tail2 = null;
      var tmp, fid;
      loop: while (true) {
        tmp = null;
        fid = null;
        switch (status) {
          case CONTINUE:
            switch (step2.tag) {
              case MAP:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(MAP, step2._1, EMPTY, EMPTY);
                step2 = step2._2;
                break;
              case APPLY:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(APPLY, EMPTY, step2._2, EMPTY);
                step2 = step2._1;
                break;
              case ALT:
                if (head4) {
                  tail2 = new Aff2(CONS, head4, tail2);
                }
                head4 = new Aff2(ALT, EMPTY, step2._2, EMPTY);
                step2 = step2._1;
                break;
              default:
                fid = fiberId++;
                status = RETURN;
                tmp = step2;
                step2 = new Aff2(FORKED, fid, new Aff2(CONS, head4, tail2), EMPTY);
                tmp = Fiber(util, supervisor, tmp);
                tmp.onComplete({
                  rethrow: false,
                  handler: resolve2(step2)
                })();
                fibers[fid] = tmp;
                if (supervisor) {
                  supervisor.register(tmp);
                }
            }
            break;
          case RETURN:
            if (head4 === null) {
              break loop;
            }
            if (head4._1 === EMPTY) {
              head4._1 = step2;
              status = CONTINUE;
              step2 = head4._2;
              head4._2 = EMPTY;
            } else {
              head4._2 = step2;
              step2 = head4;
              if (tail2 === null) {
                head4 = null;
              } else {
                head4 = tail2._1;
                tail2 = tail2._2;
              }
            }
        }
      }
      root = step2;
      for (fid = 0; fid < fiberId; fid++) {
        fibers[fid].run();
      }
    }
    function cancel(error5, cb2) {
      interrupt = util.left(error5);
      var innerKills;
      for (var kid in kills) {
        if (kills.hasOwnProperty(kid)) {
          innerKills = kills[kid];
          for (kid in innerKills) {
            if (innerKills.hasOwnProperty(kid)) {
              innerKills[kid]();
            }
          }
        }
      }
      kills = null;
      var newKills = kill2(error5, root, cb2);
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            for (var kid2 in newKills) {
              if (newKills.hasOwnProperty(kid2)) {
                newKills[kid2]();
              }
            }
            return nonCanceler2;
          };
        });
      };
    }
    run3();
    return function(killError) {
      return new Aff2(ASYNC, function(killCb) {
        return function() {
          return cancel(killError, killCb);
        };
      });
    };
  }
  function sequential3(util, supervisor, par) {
    return new Aff2(ASYNC, function(cb) {
      return function() {
        return runPar(util, supervisor, par, cb);
      };
    });
  }
  Aff2.EMPTY = EMPTY;
  Aff2.Pure = AffCtr(PURE);
  Aff2.Throw = AffCtr(THROW);
  Aff2.Catch = AffCtr(CATCH);
  Aff2.Sync = AffCtr(SYNC);
  Aff2.Async = AffCtr(ASYNC);
  Aff2.Bind = AffCtr(BIND);
  Aff2.Bracket = AffCtr(BRACKET);
  Aff2.Fork = AffCtr(FORK);
  Aff2.Seq = AffCtr(SEQ);
  Aff2.ParMap = AffCtr(MAP);
  Aff2.ParApply = AffCtr(APPLY);
  Aff2.ParAlt = AffCtr(ALT);
  Aff2.Fiber = Fiber;
  Aff2.Supervisor = Supervisor;
  Aff2.Scheduler = Scheduler;
  Aff2.nonCanceler = nonCanceler2;
  return Aff2;
}();
var _pure = Aff.Pure;
var _throwError = Aff.Throw;
function _catchError(aff) {
  return function(k) {
    return Aff.Catch(aff, k);
  };
}
function _map(f) {
  return function(aff) {
    if (aff.tag === Aff.Pure.tag) {
      return Aff.Pure(f(aff._1));
    } else {
      return Aff.Bind(aff, function(value3) {
        return Aff.Pure(f(value3));
      });
    }
  };
}
function _bind(aff) {
  return function(k) {
    return Aff.Bind(aff, k);
  };
}
function _fork(immediate) {
  return function(aff) {
    return Aff.Fork(immediate, aff);
  };
}
var _liftEffect = Aff.Sync;
function _parAffMap(f) {
  return function(aff) {
    return Aff.ParMap(f, aff);
  };
}
function _parAffApply(aff1) {
  return function(aff2) {
    return Aff.ParApply(aff1, aff2);
  };
}
function _parAffAlt(aff1) {
  return function(aff2) {
    return Aff.ParAlt(aff1, aff2);
  };
}
var makeAff = Aff.Async;
function generalBracket(acquire) {
  return function(options) {
    return function(k) {
      return Aff.Bracket(acquire, options, k);
    };
  };
}
function _makeFiber(util, aff) {
  return function() {
    return Aff.Fiber(util, null, aff);
  };
}
var _sequential = Aff.Seq;

// output/Type.Equality/index.js
var refl = {
  proof: function(a) {
    return a;
  },
  Coercible0: function() {
    return void 0;
  }
};

// output/Control.Monad.Reader.Trans/index.js
var ReaderT = function(x) {
  return x;
};
var runReaderT = function(v) {
  return v;
};
var monadTransReaderT = {
  lift: function(dictMonad) {
    return function($153) {
      return ReaderT($$const($153));
    };
  }
};
var lift3 = /* @__PURE__ */ lift(monadTransReaderT);
var mapReaderT = function(f) {
  return function(v) {
    return function($154) {
      return f(v($154));
    };
  };
};
var functorReaderT = function(dictFunctor) {
  return {
    map: function() {
      var $155 = map(dictFunctor);
      return function($156) {
        return mapReaderT($155($156));
      };
    }()
  };
};
var applyReaderT = function(dictApply) {
  var apply11 = apply(dictApply);
  var functorReaderT1 = functorReaderT(dictApply.Functor0());
  return {
    apply: function(v) {
      return function(v1) {
        return function(r) {
          return apply11(v(r))(v1(r));
        };
      };
    },
    Functor0: function() {
      return functorReaderT1;
    }
  };
};
var bindReaderT = function(dictBind) {
  var bind30 = bind(dictBind);
  var applyReaderT1 = applyReaderT(dictBind.Apply0());
  return {
    bind: function(v) {
      return function(k) {
        return function(r) {
          return bind30(v(r))(function(a) {
            var v1 = k(a);
            return v1(r);
          });
        };
      };
    },
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var applicativeReaderT = function(dictApplicative) {
  var applyReaderT1 = applyReaderT(dictApplicative.Apply0());
  return {
    pure: function() {
      var $160 = pure(dictApplicative);
      return function($161) {
        return ReaderT($$const($160($161)));
      };
    }(),
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var monadReaderT = function(dictMonad) {
  var applicativeReaderT1 = applicativeReaderT(dictMonad.Applicative0());
  var bindReaderT1 = bindReaderT(dictMonad.Bind1());
  return {
    Applicative0: function() {
      return applicativeReaderT1;
    },
    Bind1: function() {
      return bindReaderT1;
    }
  };
};
var monadAskReaderT = function(dictMonad) {
  var monadReaderT12 = monadReaderT(dictMonad);
  return {
    ask: pure(dictMonad.Applicative0()),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadEffectReader = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    liftEffect: function() {
      var $163 = lift3(Monad0);
      var $164 = liftEffect(dictMonadEffect);
      return function($165) {
        return $163($164($165));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadThrowReaderT = function(dictMonadThrow) {
  var Monad0 = dictMonadThrow.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    throwError: function() {
      var $172 = lift3(Monad0);
      var $173 = throwError(dictMonadThrow);
      return function($174) {
        return $172($173($174));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadErrorReaderT = function(dictMonadError) {
  var catchError3 = catchError(dictMonadError);
  var monadThrowReaderT1 = monadThrowReaderT(dictMonadError.MonadThrow0());
  return {
    catchError: function(v) {
      return function(h) {
        return function(r) {
          return catchError3(v(r))(function(e) {
            var v1 = h(e);
            return v1(r);
          });
        };
      };
    },
    MonadThrow0: function() {
      return monadThrowReaderT1;
    }
  };
};

// output/Control.Monad.Writer.Trans/index.js
var runWriterT = function(v) {
  return v;
};
var monadTransWriterT = function(dictMonoid) {
  var mempty11 = mempty(dictMonoid);
  return {
    lift: function(dictMonad) {
      var bind30 = bind(dictMonad.Bind1());
      var pure35 = pure(dictMonad.Applicative0());
      return function(m) {
        return bind30(m)(function(a) {
          return pure35(new Tuple(a, mempty11));
        });
      };
    }
  };
};
var mapWriterT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorWriterT = function(dictFunctor) {
  var map44 = map(dictFunctor);
  return {
    map: function(f) {
      return mapWriterT(map44(function(v) {
        return new Tuple(f(v.value0), v.value1);
      }));
    }
  };
};
var applyWriterT = function(dictSemigroup) {
  var append20 = append(dictSemigroup);
  return function(dictApply) {
    var apply11 = apply(dictApply);
    var Functor0 = dictApply.Functor0();
    var map44 = map(Functor0);
    var functorWriterT1 = functorWriterT(Functor0);
    return {
      apply: function(v) {
        return function(v1) {
          var k = function(v3) {
            return function(v42) {
              return new Tuple(v3.value0(v42.value0), append20(v3.value1)(v42.value1));
            };
          };
          return apply11(map44(k)(v))(v1);
        };
      },
      Functor0: function() {
        return functorWriterT1;
      }
    };
  };
};
var bindWriterT = function(dictSemigroup) {
  var append20 = append(dictSemigroup);
  var applyWriterT1 = applyWriterT(dictSemigroup);
  return function(dictBind) {
    var bind30 = bind(dictBind);
    var Apply0 = dictBind.Apply0();
    var map44 = map(Apply0.Functor0());
    var applyWriterT2 = applyWriterT1(Apply0);
    return {
      bind: function(v) {
        return function(k) {
          return bind30(v)(function(v1) {
            var v2 = k(v1.value0);
            return map44(function(v3) {
              return new Tuple(v3.value0, append20(v1.value1)(v3.value1));
            })(v2);
          });
        };
      },
      Apply0: function() {
        return applyWriterT2;
      }
    };
  };
};
var applicativeWriterT = function(dictMonoid) {
  var mempty11 = mempty(dictMonoid);
  var applyWriterT1 = applyWriterT(dictMonoid.Semigroup0());
  return function(dictApplicative) {
    var pure35 = pure(dictApplicative);
    var applyWriterT2 = applyWriterT1(dictApplicative.Apply0());
    return {
      pure: function(a) {
        return pure35(new Tuple(a, mempty11));
      },
      Apply0: function() {
        return applyWriterT2;
      }
    };
  };
};
var monadWriterT = function(dictMonoid) {
  var applicativeWriterT1 = applicativeWriterT(dictMonoid);
  var bindWriterT1 = bindWriterT(dictMonoid.Semigroup0());
  return function(dictMonad) {
    var applicativeWriterT22 = applicativeWriterT1(dictMonad.Applicative0());
    var bindWriterT22 = bindWriterT1(dictMonad.Bind1());
    return {
      Applicative0: function() {
        return applicativeWriterT22;
      },
      Bind1: function() {
        return bindWriterT22;
      }
    };
  };
};
var monadAskWriterT = function(dictMonoid) {
  var lift8 = lift(monadTransWriterT(dictMonoid));
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var monadWriterT22 = monadWriterT1(Monad0);
    return {
      ask: lift8(Monad0)(ask(dictMonadAsk)),
      Monad0: function() {
        return monadWriterT22;
      }
    };
  };
};
var monadEffectWriter = function(dictMonoid) {
  var lift8 = lift(monadTransWriterT(dictMonoid));
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonadEffect) {
    var Monad0 = dictMonadEffect.Monad0();
    var monadWriterT22 = monadWriterT1(Monad0);
    return {
      liftEffect: function() {
        var $259 = lift8(Monad0);
        var $260 = liftEffect(dictMonadEffect);
        return function($261) {
          return $259($260($261));
        };
      }(),
      Monad0: function() {
        return monadWriterT22;
      }
    };
  };
};
var monadThrowWriterT = function(dictMonoid) {
  var lift8 = lift(monadTransWriterT(dictMonoid));
  var monadWriterT1 = monadWriterT(dictMonoid);
  return function(dictMonadThrow) {
    var Monad0 = dictMonadThrow.Monad0();
    var lift13 = lift8(Monad0);
    var throwError6 = throwError(dictMonadThrow);
    var monadWriterT22 = monadWriterT1(Monad0);
    return {
      throwError: function(e) {
        return lift13(throwError6(e));
      },
      Monad0: function() {
        return monadWriterT22;
      }
    };
  };
};
var monadErrorWriterT = function(dictMonoid) {
  var monadThrowWriterT1 = monadThrowWriterT(dictMonoid);
  return function(dictMonadError) {
    var catchError3 = catchError(dictMonadError);
    var monadThrowWriterT2 = monadThrowWriterT1(dictMonadError.MonadThrow0());
    return {
      catchError: function(v) {
        return function(h) {
          return catchError3(v)(function(e) {
            var v1 = h(e);
            return v1;
          });
        };
      },
      MonadThrow0: function() {
        return monadThrowWriterT2;
      }
    };
  };
};

// output/Data.Profunctor/index.js
var dimap = function(dict) {
  return dict.dimap;
};

// output/Control.Parallel.Class/index.js
var sequential = function(dict) {
  return dict.sequential;
};
var parallel = function(dict) {
  return dict.parallel;
};

// output/Control.Parallel/index.js
var identity9 = /* @__PURE__ */ identity(categoryFn);
var parTraverse_ = function(dictParallel) {
  var sequential3 = sequential(dictParallel);
  var parallel4 = parallel(dictParallel);
  return function(dictApplicative) {
    var traverse_3 = traverse_(dictApplicative);
    return function(dictFoldable) {
      var traverse_1 = traverse_3(dictFoldable);
      return function(f) {
        var $51 = traverse_1(function($53) {
          return parallel4(f($53));
        });
        return function($52) {
          return sequential3($51($52));
        };
      };
    };
  };
};
var parSequence_ = function(dictParallel) {
  var parTraverse_1 = parTraverse_(dictParallel);
  return function(dictApplicative) {
    var parTraverse_2 = parTraverse_1(dictApplicative);
    return function(dictFoldable) {
      return parTraverse_2(dictFoldable)(identity9);
    };
  };
};
var parOneOf = function(dictParallel) {
  var sequential3 = sequential(dictParallel);
  var parallel4 = parallel(dictParallel);
  return function(dictAlternative) {
    var Plus1 = dictAlternative.Plus1();
    return function(dictFoldable) {
      var oneOfMap2 = oneOfMap(dictFoldable)(Plus1);
      return function(dictFunctor) {
        var $60 = oneOfMap2(parallel4);
        return function($61) {
          return sequential3($60($61));
        };
      };
    };
  };
};

// output/Data.Time.Duration/index.js
var show2 = /* @__PURE__ */ show(showNumber);
var Milliseconds = function(x) {
  return x;
};
var showMilliseconds = {
  show: function(v) {
    return "(Milliseconds " + (show2(v) + ")");
  }
};
var ordMilliseconds = ordNumber;

// output/Partial.Unsafe/foreign.js
var _unsafePartial = function(f) {
  return f();
};

// output/Partial/foreign.js
var _crashWith = function(msg) {
  throw new Error(msg);
};

// output/Partial/index.js
var crashWith = function() {
  return _crashWith;
};

// output/Partial.Unsafe/index.js
var crashWith2 = /* @__PURE__ */ crashWith();
var unsafePartial = _unsafePartial;
var unsafeCrashWith = function(msg) {
  return unsafePartial(function() {
    return crashWith2(msg);
  });
};

// output/Effect.Aff/index.js
var $runtime_lazy5 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var pure4 = /* @__PURE__ */ pure(applicativeEffect);
var $$void5 = /* @__PURE__ */ $$void(functorEffect);
var map12 = /* @__PURE__ */ map(functorEffect);
var Canceler = function(x) {
  return x;
};
var suspendAff = /* @__PURE__ */ _fork(false);
var functorParAff = {
  map: _parAffMap
};
var functorAff = {
  map: _map
};
var forkAff = /* @__PURE__ */ _fork(true);
var ffiUtil = /* @__PURE__ */ function() {
  var unsafeFromRight = function(v) {
    if (v instanceof Right) {
      return v.value0;
    }
    ;
    if (v instanceof Left) {
      return unsafeCrashWith("unsafeFromRight: Left");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
  };
  var unsafeFromLeft = function(v) {
    if (v instanceof Left) {
      return v.value0;
    }
    ;
    if (v instanceof Right) {
      return unsafeCrashWith("unsafeFromLeft: Right");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
  };
  var isLeft = function(v) {
    if (v instanceof Left) {
      return true;
    }
    ;
    if (v instanceof Right) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
  };
  return {
    isLeft,
    fromLeft: unsafeFromLeft,
    fromRight: unsafeFromRight,
    left: Left.create,
    right: Right.create
  };
}();
var makeFiber = function(aff) {
  return _makeFiber(ffiUtil, aff);
};
var launchAff = function(aff) {
  return function __do3() {
    var fiber = makeFiber(aff)();
    fiber.run();
    return fiber;
  };
};
var launchAff_ = function($75) {
  return $$void5(launchAff($75));
};
var bracket = function(acquire) {
  return function(completed) {
    return generalBracket(acquire)({
      killed: $$const(completed),
      failed: $$const(completed),
      completed: $$const(completed)
    });
  };
};
var applyParAff = {
  apply: _parAffApply,
  Functor0: function() {
    return functorParAff;
  }
};
var monadAff = {
  Applicative0: function() {
    return applicativeAff;
  },
  Bind1: function() {
    return bindAff;
  }
};
var bindAff = {
  bind: _bind,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var applicativeAff = {
  pure: _pure,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy5("applyAff", "Effect.Aff", function() {
  return {
    apply: ap(monadAff),
    Functor0: function() {
      return functorAff;
    }
  };
});
var applyAff = /* @__PURE__ */ $lazy_applyAff(73);
var pure22 = /* @__PURE__ */ pure(applicativeAff);
var $$finally = function(fin) {
  return function(a) {
    return bracket(pure22(unit))($$const(fin))($$const(a));
  };
};
var parallelAff = {
  parallel: unsafeCoerce2,
  sequential: _sequential,
  Apply0: function() {
    return applyAff;
  },
  Apply1: function() {
    return applyParAff;
  }
};
var parallel2 = /* @__PURE__ */ parallel(parallelAff);
var applicativeParAff = {
  pure: function($76) {
    return parallel2(pure22($76));
  },
  Apply0: function() {
    return applyParAff;
  }
};
var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableArray);
var semigroupCanceler = {
  append: function(v) {
    return function(v1) {
      return function(err) {
        return parSequence_2([v(err), v1(err)]);
      };
    };
  }
};
var monadEffectAff = {
  liftEffect: _liftEffect,
  Monad0: function() {
    return monadAff;
  }
};
var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
var effectCanceler = function($77) {
  return Canceler($$const(liftEffect2($77)));
};
var joinFiber = function(v) {
  return makeAff(function(k) {
    return map12(effectCanceler)(v.join(k));
  });
};
var monadThrowAff = {
  throwError: _throwError,
  Monad0: function() {
    return monadAff;
  }
};
var monadErrorAff = {
  catchError: _catchError,
  MonadThrow0: function() {
    return monadThrowAff;
  }
};
var catchError2 = /* @__PURE__ */ catchError(monadErrorAff);
var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure22(unit));
var monoidCanceler = {
  mempty: nonCanceler,
  Semigroup0: function() {
    return semigroupCanceler;
  }
};
var mempty2 = /* @__PURE__ */ mempty(monoidCanceler);
var never = /* @__PURE__ */ makeAff(function(v) {
  return pure4(mempty2);
});
var altParAff = {
  alt: _parAffAlt,
  Functor0: function() {
    return functorParAff;
  }
};
var altAff = {
  alt: function(a1) {
    return function(a2) {
      return catchError2(a1)($$const(a2));
    };
  },
  Functor0: function() {
    return functorAff;
  }
};
var plusAff = {
  empty: /* @__PURE__ */ throwError(monadThrowAff)(/* @__PURE__ */ error2("Always fails")),
  Alt0: function() {
    return altAff;
  }
};
var plusParAff = {
  empty: /* @__PURE__ */ parallel2(/* @__PURE__ */ empty(plusAff)),
  Alt0: function() {
    return altParAff;
  }
};
var alternativeParAff = {
  Applicative0: function() {
    return applicativeParAff;
  },
  Plus1: function() {
    return plusParAff;
  }
};

// output/Data.Lazy/foreign.js
var defer2 = function(thunk) {
  var v = null;
  return function() {
    if (thunk === void 0) return v;
    v = thunk();
    thunk = void 0;
    return v;
  };
};
var force = function(l) {
  return l();
};

// output/Data.Lazy/index.js
var functorLazy = {
  map: function(f) {
    return function(l) {
      return defer2(function(v) {
        return f(force(l));
      });
    };
  }
};
var applyLazy = {
  apply: function(f) {
    return function(x) {
      return defer2(function(v) {
        return force(f)(force(x));
      });
    };
  },
  Functor0: function() {
    return functorLazy;
  }
};
var bindLazy = {
  bind: function(l) {
    return function(f) {
      return defer2(function(v) {
        return force(f(force(l)));
      });
    };
  },
  Apply0: function() {
    return applyLazy;
  }
};

// output/Control.Monad.State.Trans/index.js
var StateT = function(x) {
  return x;
};
var runStateT = function(v) {
  return v;
};
var monadTransStateT = {
  lift: function(dictMonad) {
    var bind30 = bind(dictMonad.Bind1());
    var pure35 = pure(dictMonad.Applicative0());
    return function(m) {
      return function(s) {
        return bind30(m)(function(x) {
          return pure35(new Tuple(x, s));
        });
      };
    };
  }
};
var lift4 = /* @__PURE__ */ lift(monadTransStateT);
var functorStateT = function(dictFunctor) {
  var map44 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return function(s) {
          return map44(function(v1) {
            return new Tuple(f(v1.value0), v1.value1);
          })(v(s));
        };
      };
    }
  };
};
var evalStateT = function(dictFunctor) {
  var map44 = map(dictFunctor);
  return function(v) {
    return function(s) {
      return map44(fst)(v(s));
    };
  };
};
var monadStateT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeStateT(dictMonad);
    },
    Bind1: function() {
      return bindStateT(dictMonad);
    }
  };
};
var bindStateT = function(dictMonad) {
  var bind30 = bind(dictMonad.Bind1());
  return {
    bind: function(v) {
      return function(f) {
        return function(s) {
          return bind30(v(s))(function(v1) {
            var v3 = f(v1.value0);
            return v3(v1.value1);
          });
        };
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var applyStateT = function(dictMonad) {
  var functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadStateT(dictMonad)),
    Functor0: function() {
      return functorStateT1;
    }
  };
};
var applicativeStateT = function(dictMonad) {
  var pure35 = pure(dictMonad.Applicative0());
  return {
    pure: function(a) {
      return function(s) {
        return pure35(new Tuple(a, s));
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var monadStateStateT = function(dictMonad) {
  var pure35 = pure(dictMonad.Applicative0());
  var monadStateT1 = monadStateT(dictMonad);
  return {
    state: function(f) {
      return function($206) {
        return pure35(f($206));
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};
var monadThrowStateT = function(dictMonadThrow) {
  var Monad0 = dictMonadThrow.Monad0();
  var lift13 = lift4(Monad0);
  var throwError6 = throwError(dictMonadThrow);
  var monadStateT1 = monadStateT(Monad0);
  return {
    throwError: function(e) {
      return lift13(throwError6(e));
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};

// output/Effect.Aff.Class/index.js
var lift42 = /* @__PURE__ */ lift(monadTransReaderT);
var monadAffAff = {
  liftAff: /* @__PURE__ */ identity(categoryFn),
  MonadEffect0: function() {
    return monadEffectAff;
  }
};
var liftAff = function(dict) {
  return dict.liftAff;
};
var monadAffReader = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var monadEffectReader2 = monadEffectReader(MonadEffect0);
  return {
    liftAff: function() {
      var $79 = lift42(MonadEffect0.Monad0());
      var $80 = liftAff(dictMonadAff);
      return function($81) {
        return $79($80($81));
      };
    }(),
    MonadEffect0: function() {
      return monadEffectReader2;
    }
  };
};
var monadAffWriter = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var Monad0 = MonadEffect0.Monad0();
  var liftAff1 = liftAff(dictMonadAff);
  return function(dictMonoid) {
    var monadEffectWriter3 = monadEffectWriter(dictMonoid)(MonadEffect0);
    return {
      liftAff: function() {
        var $85 = lift(monadTransWriterT(dictMonoid))(Monad0);
        return function($86) {
          return $85(liftAff1($86));
        };
      }(),
      MonadEffect0: function() {
        return monadEffectWriter3;
      }
    };
  };
};

// output/Effect.Console/foreign.js
var log2 = function(s) {
  return function() {
    console.log(s);
  };
};
var warn = function(s) {
  return function() {
    console.warn(s);
  };
};
var error3 = function(s) {
  return function() {
    console.error(s);
  };
};
var info = function(s) {
  return function() {
    console.info(s);
  };
};
var debug = function(s) {
  return function() {
    console.debug(s);
  };
};

// output/Effect.Class.Console/index.js
var warn2 = function(dictMonadEffect) {
  var $57 = liftEffect(dictMonadEffect);
  return function($58) {
    return $57(warn($58));
  };
};
var log3 = function(dictMonadEffect) {
  var $67 = liftEffect(dictMonadEffect);
  return function($68) {
    return $67(log2($68));
  };
};
var info2 = function(dictMonadEffect) {
  var $71 = liftEffect(dictMonadEffect);
  return function($72) {
    return $71(info($72));
  };
};
var error4 = function(dictMonadEffect) {
  var $79 = liftEffect(dictMonadEffect);
  return function($80) {
    return $79(error3($80));
  };
};
var debug2 = function(dictMonadEffect) {
  var $83 = liftEffect(dictMonadEffect);
  return function($84) {
    return $83(debug($84));
  };
};

// output/Node.ChildProcess.Types/foreign.js
var fromKillSignalImpl = (fromInt2, fromStr, sig) => {
  const ty = typeof sig;
  if (ty === "number") return fromInt2(sig | 0);
  if (ty === "string") return fromStr(sig);
  throw new Error("Impossible. Got kill signal that was neither int nor string: " + sig);
};

// output/Data.Nullable/foreign.js
var nullImpl = null;
function nullable(a, r, f) {
  return a == null ? r : f(a);
}
function notNull(x) {
  return x;
}

// output/Data.Nullable/index.js
var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);
var toMaybe = function(n) {
  return nullable(n, Nothing.value, Just.create);
};
var showNullable = function(dictShow) {
  return {
    show: function() {
      var $17 = maybe("null")(show(dictShow));
      return function($18) {
        return $17(toMaybe($18));
      };
    }()
  };
};

// output/Node.ChildProcess.Types/index.js
var Normally = /* @__PURE__ */ function() {
  function Normally2(value0) {
    this.value0 = value0;
  }
  ;
  Normally2.create = function(value0) {
    return new Normally2(value0);
  };
  return Normally2;
}();
var BySignal = /* @__PURE__ */ function() {
  function BySignal2(value0) {
    this.value0 = value0;
  }
  ;
  BySignal2.create = function(value0) {
    return new BySignal2(value0);
  };
  return BySignal2;
}();
var stringSignal = unsafeCoerce2;
var pipe = "pipe";
var ipc = "ipc";
var inherit = "inherit";
var fromKillSignal$prime = function(fromInt2) {
  return function(fromStr) {
    return function(sig) {
      return fromKillSignalImpl(fromInt2, fromStr, sig);
    };
  };
};
var fromKillSignal = function(sig) {
  return fromKillSignal$prime(Left.create)(Right.create)(sig);
};
var defaultStdIO = nullImpl;
var customShell = unsafeCoerce2;

// output/Node.Process/foreign.js
import process2 from "process";
var abortImpl = process2.abort ? () => process2.abort() : null;
var argv = () => process2.argv.slice();
var channelRefImpl = process2.channel && process2.channel.ref ? () => process2.channel.ref() : null;
var channelUnrefImpl = process2.channel && process2.channel.unref ? () => process2.channel.unref() : null;
var chdirImpl = (dir) => process2.chdir(dir);
var cwd = () => process2.cwd();
var debugPort = process2.debugPort;
var disconnectImpl = process2.disconnect ? () => process2.disconnect() : null;
var getEnv = () => Object.assign({}, process2.env);
var execPath = () => process2.execPath;
var exitImpl = (code2) => process2.exit(code2);
var setExitCodeImpl = (code2) => {
  process2.exitCode = code2;
};
var getExitCodeImpl = () => process2.exitCode;
var getGidImpl = () => process2.getgid();
var getUidImpl = () => process2.getuid();
var killStrImpl = (pid3, sig) => process2.kill(pid3, sig);
var pid = process2.pid;
var platformStr = process2.platform;
var ppid = process2.ppid;
var stdin = process2.stdin;
var stdout = process2.stdout;
var stderr = process2.stderr;
var stdinIsTTY = process2.stdinIsTTY;
var stdoutIsTTY = process2.stdoutIsTTY;
var stderrIsTTY = process2.stderrIsTTY;
var version = process2.version;

// output/Effect.Uncurried/foreign.js
var mkEffectFn1 = function mkEffectFn12(fn) {
  return function(x) {
    return fn(x)();
  };
};

// output/Foreign.Object/foreign.js
function _copyST(m) {
  return function() {
    var r = {};
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r[k] = m[k];
      }
    }
    return r;
  };
}
var empty5 = {};
function runST(f) {
  return f();
}
function _foldM(bind30) {
  return function(f) {
    return function(mz) {
      return function(m) {
        var acc = mz;
        function g(k2) {
          return function(z) {
            return f(z)(k2)(m[k2]);
          };
        }
        for (var k in m) {
          if (hasOwnProperty.call(m, k)) {
            acc = bind30(acc)(g(k));
          }
        }
        return acc;
      };
    };
  };
}
function _lookup2(no, yes, k, m) {
  return k in m ? yes(m[k]) : no;
}
function toArrayWithKey(f) {
  return function(m) {
    var r = [];
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r.push(f(k)(m[k]));
      }
    }
    return r;
  };
}
var keys3 = Object.keys || toArrayWithKey(function(k) {
  return function() {
    return k;
  };
});

// output/Foreign.Object.ST/foreign.js
function poke2(k) {
  return function(v) {
    return function(m) {
      return function() {
        m[k] = v;
        return m;
      };
    };
  };
}

// output/Foreign.Object/index.js
var foldr4 = /* @__PURE__ */ foldr(foldableArray);
var values = /* @__PURE__ */ toArrayWithKey(function(v) {
  return function(v1) {
    return v1;
  };
});
var thawST = _copyST;
var mutate = function(f) {
  return function(m) {
    return runST(function __do3() {
      var s = thawST(m)();
      f(s)();
      return s;
    });
  };
};
var lookup4 = /* @__PURE__ */ function() {
  return runFn4(_lookup2)(Nothing.value)(Just.create);
}();
var insert2 = function(k) {
  return function(v) {
    return mutate(poke2(k)(v));
  };
};
var fromHomogeneous = function() {
  return unsafeCoerce2;
};
var foldM = function(dictMonad) {
  var bind114 = bind(dictMonad.Bind1());
  var pure118 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(z) {
      return _foldM(bind114)(f)(pure118(z));
    };
  };
};
var foldM1 = /* @__PURE__ */ foldM(monadST);
var union2 = function(m) {
  return mutate(function(s) {
    return foldM1(function(s$prime) {
      return function(k) {
        return function(v) {
          return poke2(k)(v)(s$prime);
        };
      };
    })(s)(m);
  });
};
var fold3 = /* @__PURE__ */ _foldM(applyFlipped);
var foldMap2 = function(dictMonoid) {
  var append110 = append(dictMonoid.Semigroup0());
  var mempty11 = mempty(dictMonoid);
  return function(f) {
    return fold3(function(acc) {
      return function(k) {
        return function(v) {
          return append110(acc)(f(k)(v));
        };
      };
    })(mempty11);
  };
};
var foldableObject = {
  foldl: function(f) {
    return fold3(function(z) {
      return function(v) {
        return f(z);
      };
    });
  },
  foldr: function(f) {
    return function(z) {
      return function(m) {
        return foldr4(f)(z)(values(m));
      };
    };
  },
  foldMap: function(dictMonoid) {
    var foldMap13 = foldMap2(dictMonoid);
    return function(f) {
      return foldMap13($$const(f));
    };
  }
};
var foldableWithIndexObject = {
  foldlWithIndex: function(f) {
    return fold3(flip(f));
  },
  foldrWithIndex: function(f) {
    return function(z) {
      return function(m) {
        return foldr4(uncurry(f))(z)(toArrayWithKey(Tuple.create)(m));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMap2(dictMonoid);
  },
  Foldable0: function() {
    return foldableObject;
  }
};

// output/Node.EventEmitter/foreign.js
import EventEmitter from "node:events";
var newImpl2 = function() {
  return new EventEmitter();
};
var unsafeEmitFn = (emitter) => emitter.emit.bind(emitter);
var listenerCountImpl = (emitter, eventName) => emitter.listenerCount(eventName);
var unsafeOff = (emitter, eventName, cb) => emitter.off(eventName, cb);
var unsafeOn = (emitter, eventName, cb) => emitter.on(eventName, cb);
var unsafeOnce = (emitter, eventName, cb) => emitter.once(eventName, cb);
var setMaxListenersImpl = (emitter, max4) => emitter.setMaxListeners(max4);

// output/Node.EventEmitter/index.js
var EventHandle = /* @__PURE__ */ function() {
  function EventHandle2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  EventHandle2.create = function(value0) {
    return function(value12) {
      return new EventHandle2(value0, value12);
    };
  };
  return EventHandle2;
}();
var subscribeSameFunction = function(onXFn, eventEmitter, eventName, jsCb) {
  onXFn(eventEmitter, eventName, jsCb);
  return function() {
    return unsafeOff(eventEmitter, eventName, jsCb);
  };
};
var setMaxListeners = function(max4) {
  return function(emitter) {
    return function() {
      return setMaxListenersImpl(emitter, max4);
    };
  };
};
var setUnlimitedListeners = /* @__PURE__ */ setMaxListeners(0);
var once_ = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return unsafeOnce(eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var once = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return subscribeSameFunction(unsafeOnce, eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var on2 = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return subscribeSameFunction(unsafeOn, eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var listenerCount = function(emitter) {
  return function(eventName) {
    return function() {
      return listenerCountImpl(emitter, eventName);
    };
  };
};

// output/Node.Platform/index.js
var AIX = /* @__PURE__ */ function() {
  function AIX2() {
  }
  ;
  AIX2.value = new AIX2();
  return AIX2;
}();
var Darwin = /* @__PURE__ */ function() {
  function Darwin2() {
  }
  ;
  Darwin2.value = new Darwin2();
  return Darwin2;
}();
var FreeBSD = /* @__PURE__ */ function() {
  function FreeBSD2() {
  }
  ;
  FreeBSD2.value = new FreeBSD2();
  return FreeBSD2;
}();
var Linux = /* @__PURE__ */ function() {
  function Linux2() {
  }
  ;
  Linux2.value = new Linux2();
  return Linux2;
}();
var OpenBSD = /* @__PURE__ */ function() {
  function OpenBSD2() {
  }
  ;
  OpenBSD2.value = new OpenBSD2();
  return OpenBSD2;
}();
var SunOS = /* @__PURE__ */ function() {
  function SunOS2() {
  }
  ;
  SunOS2.value = new SunOS2();
  return SunOS2;
}();
var Win32 = /* @__PURE__ */ function() {
  function Win322() {
  }
  ;
  Win322.value = new Win322();
  return Win322;
}();
var Android = /* @__PURE__ */ function() {
  function Android2() {
  }
  ;
  Android2.value = new Android2();
  return Android2;
}();
var fromString3 = function(v) {
  if (v === "aix") {
    return new Just(AIX.value);
  }
  ;
  if (v === "darwin") {
    return new Just(Darwin.value);
  }
  ;
  if (v === "freebsd") {
    return new Just(FreeBSD.value);
  }
  ;
  if (v === "linux") {
    return new Just(Linux.value);
  }
  ;
  if (v === "openbsd") {
    return new Just(OpenBSD.value);
  }
  ;
  if (v === "sunos") {
    return new Just(SunOS.value);
  }
  ;
  if (v === "win32") {
    return new Just(Win32.value);
  }
  ;
  if (v === "android") {
    return new Just(Android.value);
  }
  ;
  return Nothing.value;
};
var eqPlatform = {
  eq: function(x) {
    return function(y) {
      if (x instanceof AIX && y instanceof AIX) {
        return true;
      }
      ;
      if (x instanceof Darwin && y instanceof Darwin) {
        return true;
      }
      ;
      if (x instanceof FreeBSD && y instanceof FreeBSD) {
        return true;
      }
      ;
      if (x instanceof Linux && y instanceof Linux) {
        return true;
      }
      ;
      if (x instanceof OpenBSD && y instanceof OpenBSD) {
        return true;
      }
      ;
      if (x instanceof SunOS && y instanceof SunOS) {
        return true;
      }
      ;
      if (x instanceof Win32 && y instanceof Win32) {
        return true;
      }
      ;
      if (x instanceof Android && y instanceof Android) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Node.Process/index.js
var identity10 = /* @__PURE__ */ identity(categoryFn);
var map13 = /* @__PURE__ */ map(functorEffect);
var setExitCode = function(code2) {
  return function() {
    return setExitCodeImpl(code2);
  };
};
var platform = /* @__PURE__ */ fromString3(platformStr);
var mkSignalH$prime = function(sig) {
  return new EventHandle(toUpper(sig), identity10);
};
var killStr = function(p) {
  return function(sig) {
    return function() {
      return killStrImpl(p, sig);
    };
  };
};
var getUid = /* @__PURE__ */ map13(toMaybe)(getUidImpl);
var getGid = /* @__PURE__ */ map13(toMaybe)(getGidImpl);
var getExitCode = /* @__PURE__ */ map13(toMaybe)(getExitCodeImpl);
var exit$prime = function(code2) {
  return function() {
    return exitImpl(code2);
  };
};
var chdir = function(dir) {
  return function() {
    return chdirImpl(dir);
  };
};

// output/Spago.Generated.BuildInfo/index.js
var spagoVersion = "0.93.44";
var pursVersion = "0.15.15";
var packages = {
  bootstrap: "0.0.0",
  "whine-core": "0.0.31",
  "whine-extension": "0.0.0"
};

// output/Data.Array.NonEmpty.Internal/index.js
var NonEmptyArray = function(x) {
  return x;
};

// output/Data.Array.NonEmpty/index.js
var fromJust4 = /* @__PURE__ */ fromJust();
var unsafeFromArray = NonEmptyArray;
var toArray2 = function(v) {
  return v;
};
var singleton8 = function($110) {
  return unsafeFromArray(singleton2($110));
};
var fromArray3 = function(xs) {
  if (length(xs) > 0) {
    return new Just(unsafeFromArray(xs));
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): " + [xs.constructor.name]);
};
var fromFoldable5 = function(dictFoldable) {
  var $119 = fromFoldable(dictFoldable);
  return function($120) {
    return fromArray3($119($120));
  };
};
var adaptMaybe = function(f) {
  return function($126) {
    return fromJust4(f(toArray2($126)));
  };
};
var head2 = /* @__PURE__ */ adaptMaybe(head);
var uncons3 = /* @__PURE__ */ adaptMaybe(uncons);

// output/Data.List/index.js
var map14 = /* @__PURE__ */ map(functorMaybe);
var uncons4 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just({
      head: v.value0,
      tail: v.value1
    });
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [v.constructor.name]);
};
var toUnfoldable3 = function(dictUnfoldable) {
  return unfoldr(dictUnfoldable)(function(xs) {
    return map14(function(rec) {
      return new Tuple(rec.head, rec.tail);
    })(uncons4(xs));
  });
};
var span2 = function(v) {
  return function(v1) {
    if (v1 instanceof Cons && v(v1.value0)) {
      var v2 = span2(v)(v1.value1);
      return {
        init: new Cons(v1.value0, v2.init),
        rest: v2.rest
      };
    }
    ;
    return {
      init: Nil.value,
      rest: v1
    };
  };
};
var reverse2 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
}();
var $$null4 = function(v) {
  if (v instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var mapMaybe2 = function(f) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return reverse2(v);
        }
        ;
        if (v1 instanceof Cons) {
          var v2 = f(v1.value0);
          if (v2 instanceof Nothing) {
            $tco_var_v = v;
            $copy_v1 = v1.value1;
            return;
          }
          ;
          if (v2 instanceof Just) {
            $tco_var_v = new Cons(v2.value0, v);
            $copy_v1 = v1.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List (line 419, column 5 - line 421, column 32): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 417, column 3 - line 417, column 27): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var fromFoldable6 = function(dictFoldable) {
  return foldr(dictFoldable)(Cons.create)(Nil.value);
};

// output/Data.Set/index.js
var coerce4 = /* @__PURE__ */ coerce();
var toList = function(v) {
  return keys2(v);
};
var toUnfoldable4 = function(dictUnfoldable) {
  var $96 = toUnfoldable3(dictUnfoldable);
  return function($97) {
    return $96(toList($97));
  };
};
var member2 = function(dictOrd) {
  return coerce4(member(dictOrd));
};
var isEmpty2 = /* @__PURE__ */ coerce4(isEmpty);
var insert4 = function(dictOrd) {
  var insert1 = insert(dictOrd);
  return function(a) {
    return function(v) {
      return insert1(a)(unit)(v);
    };
  };
};
var empty6 = empty4;
var fromFoldable7 = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictOrd) {
    var insert1 = insert4(dictOrd);
    return foldl22(function(m) {
      return function(a) {
        return insert1(a)(m);
      };
    })(empty6);
  };
};
var difference3 = function(dictOrd) {
  return coerce4(difference(dictOrd));
};

// output/Data.String.NonEmpty.Internal/index.js
var toString4 = function(v) {
  return v;
};
var fromString4 = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(v);
};

// output/Data.Codec.JSON.Common/index.js
var functorExceptT2 = /* @__PURE__ */ functorExceptT(functorIdentity);
var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));
var map22 = /* @__PURE__ */ map(functorExceptT2);
var fromFoldable11 = /* @__PURE__ */ fromFoldable4(ordString)(foldableArray);
var applicativeExceptT3 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var traverse2 = /* @__PURE__ */ traverse(traversableArray)(applicativeExceptT3);
var traverse12 = /* @__PURE__ */ traverse(traversableTuple)(applicativeExceptT3);
var fromFoldableWithIndex2 = /* @__PURE__ */ fromFoldableWithIndex(foldableWithIndexMap);
var map32 = /* @__PURE__ */ map(functorMap);
var strMap = function(codec2) {
  return codec$prime(composeKleisliFlipped2(function() {
    var $61 = map22(fromFoldable11);
    var $62 = traverse2(traverse12(decode(codec2)));
    return function($63) {
      return $61($62(entries($63)));
    };
  }())(decode(jobject)))(function() {
    var $64 = encode2(jobject);
    var $65 = map32(encode2(codec2));
    return function($66) {
      return $64(fromFoldableWithIndex2($65($66)));
    };
  }());
};
var nonEmptyString = /* @__PURE__ */ prismaticCodec("NonEmptyString")(fromString4)(toString4)(string);

// output/Data.Codec.JSON.Strict/index.js
var monadExceptT2 = /* @__PURE__ */ monadExceptT(monadIdentity);
var bindStateT2 = /* @__PURE__ */ bindStateT(monadExceptT2);
var bind3 = /* @__PURE__ */ bind(bindStateT2);
var lift5 = /* @__PURE__ */ lift(monadTransStateT)(monadExceptT2);
var withExceptT2 = /* @__PURE__ */ withExceptT(functorIdentity);
var map16 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var pure5 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeStateT(monadExceptT2));
var discard2 = /* @__PURE__ */ discard(discardUnit);
var discard1 = /* @__PURE__ */ discard2(bindStateT2);
var modify_3 = /* @__PURE__ */ modify_2(/* @__PURE__ */ monadStateStateT(monadExceptT2));
var insert5 = /* @__PURE__ */ insert4(ordString);
var monadThrowExceptT2 = /* @__PURE__ */ monadThrowExceptT(monadIdentity);
var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowStateT(monadThrowExceptT2));
var fromFoldable12 = /* @__PURE__ */ fromFoldable2(foldableList);
var bindExceptT3 = /* @__PURE__ */ bindExceptT(monadIdentity);
var bind1 = /* @__PURE__ */ bind(bindExceptT3);
var difference4 = /* @__PURE__ */ difference3(ordString);
var fromFoldable13 = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString);
var discard22 = /* @__PURE__ */ discard2(bindExceptT3);
var applicativeExceptT4 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var when2 = /* @__PURE__ */ when(applicativeExceptT4);
var not3 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var throwError1 = /* @__PURE__ */ throwError(monadThrowExceptT2);
var toUnfoldable7 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var pure23 = /* @__PURE__ */ pure(applicativeExceptT4);
var recordPropOptional2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var key = reflectSymbol2($$Proxy.value);
        var liftError = withPath(AtKey.create(key));
        var enc = function(val) {
          var r = encode(codecR)(val);
          var v = unsafeGet(key)(val);
          if (v instanceof Nothing) {
            return r;
          }
          ;
          if (v instanceof Just) {
            return new Cons(new Tuple(key, encode(codecA)(v.value0)), r);
          }
          ;
          throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 168, column 5 - line 170, column 59): " + [v.constructor.name]);
        };
        var dec = function(obj) {
          return bind3(decode(codecR)(obj))(function(r) {
            return bind3(function() {
              var v = lookup2(key)(obj);
              if (v instanceof Just) {
                return lift5(withExceptT2(liftError)(map16(Just.create)(decode(codecA)(v.value0))));
              }
              ;
              if (v instanceof Nothing) {
                return pure5(Nothing.value);
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 159, column 19 - line 161, column 29): " + [v.constructor.name]);
            }())(function(v) {
              return discard1(modify_3(insert5(key)))(function() {
                return pure5(unsafeSet(key)(v)(r));
              });
            });
          });
        };
        return codec(dec)(enc);
      };
    };
  };
};
var recordProp2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(codecA) {
      return function(codecR) {
        var key = reflectSymbol2($$Proxy.value);
        var liftError = withPath(AtKey.create(key));
        var enc = function(val) {
          return new Cons(new Tuple(key, encode(codecA)(unsafeGet(key)(val))), encode(codecR)(val));
        };
        var dec = function(obj) {
          return bind3(decode(codecR)(obj))(function(r) {
            return bind3(function() {
              var v = lookup2(key)(obj);
              if (v instanceof Just) {
                return lift5(withExceptT2(liftError)(decode(codecA)(v.value0)));
              }
              ;
              if (v instanceof Nothing) {
                return throwError2(noValueFound(new AtKey(key, Tip.value)));
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON.Strict (line 126, column 13 - line 128, column 70): " + [v.constructor.name]);
            }())(function(v) {
              return discard1(modify_3(insert5(key)))(function() {
                return pure5(unsafeSet(key)(v)(r));
              });
            });
          });
        };
        return codec(dec)(enc);
      };
    };
  };
};
var record2 = /* @__PURE__ */ function() {
  return new Codec($$const(pure5({})), pure(applicativeTuple(monoidList)));
}();
var objectStrict = function(codec2) {
  var enc = function(a) {
    return encode(jobject)(fromFoldable12(encode(codec2)(a)));
  };
  var dec = function(j) {
    return bind1(decode(jobject)(j))(function(obj) {
      return bind1(runStateT(decode(codec2)(obj))(empty6))(function(v) {
        var unclaimedProps = difference4(fromFoldable13(keys(obj)))(v.value1);
        return discard22(when2(not3(isEmpty2)(unclaimedProps))(throwError1(error(Tip.value)("Unknown field(s): " + joinWith(", ")(toUnfoldable7(unclaimedProps))))))(function() {
          return pure23(v.value0);
        });
      });
    });
  };
  return codec$prime(dec)(enc);
};

// output/Record/index.js
var get2 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(l) {
      return function(r) {
        return unsafeGet(reflectSymbol2(l))(r);
      };
    };
  };
};

// output/Data.Codec.JSON.Record/index.js
var rowListCodecNilRowRow = {
  rowListCodec: function(v) {
    return record;
  }
};
var rowListCodec = function(dict) {
  return dict.rowListCodec;
};
var rowListCodecConsCodec = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get3 = get2(dictIsSymbol)();
        var recordProp3 = recordProp(dictIsSymbol)();
        return {
          rowListCodec: function(codecs) {
            var tail2 = rowListCodec1(codecs);
            var codec2 = get3($$Proxy.value)(codecs);
            return recordProp3(codec2)(tail2);
          }
        };
      };
    };
  };
};
var record3 = function() {
  return function(dictRowListCodec) {
    return rowListCodec(dictRowListCodec);
  };
};
var record1 = /* @__PURE__ */ record3();
var object2 = function() {
  return function(dictRowListCodec) {
    var record22 = record1(dictRowListCodec);
    return function(rec) {
      return object(record22(rec));
    };
  };
};

// output/Data.Date/foreign.js
var createDate = function(y, m, d) {
  var date2 = new Date(Date.UTC(y, m, d));
  if (y >= 0 && y < 100) {
    date2.setUTCFullYear(y);
  }
  return date2;
};
function canonicalDateImpl(ctor, y, m, d) {
  var date2 = createDate(y, m - 1, d);
  return ctor(date2.getUTCFullYear())(date2.getUTCMonth() + 1)(date2.getUTCDate());
}
function calcWeekday(y, m, d) {
  return createDate(y, m - 1, d).getUTCDay();
}

// output/Data.Date.Component/index.js
var $runtime_lazy6 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var Monday = /* @__PURE__ */ function() {
  function Monday2() {
  }
  ;
  Monday2.value = new Monday2();
  return Monday2;
}();
var Tuesday = /* @__PURE__ */ function() {
  function Tuesday2() {
  }
  ;
  Tuesday2.value = new Tuesday2();
  return Tuesday2;
}();
var Wednesday = /* @__PURE__ */ function() {
  function Wednesday2() {
  }
  ;
  Wednesday2.value = new Wednesday2();
  return Wednesday2;
}();
var Thursday = /* @__PURE__ */ function() {
  function Thursday2() {
  }
  ;
  Thursday2.value = new Thursday2();
  return Thursday2;
}();
var Friday = /* @__PURE__ */ function() {
  function Friday2() {
  }
  ;
  Friday2.value = new Friday2();
  return Friday2;
}();
var Saturday = /* @__PURE__ */ function() {
  function Saturday2() {
  }
  ;
  Saturday2.value = new Saturday2();
  return Saturday2;
}();
var Sunday = /* @__PURE__ */ function() {
  function Sunday2() {
  }
  ;
  Sunday2.value = new Sunday2();
  return Sunday2;
}();
var January = /* @__PURE__ */ function() {
  function January2() {
  }
  ;
  January2.value = new January2();
  return January2;
}();
var February = /* @__PURE__ */ function() {
  function February2() {
  }
  ;
  February2.value = new February2();
  return February2;
}();
var March = /* @__PURE__ */ function() {
  function March2() {
  }
  ;
  March2.value = new March2();
  return March2;
}();
var April = /* @__PURE__ */ function() {
  function April2() {
  }
  ;
  April2.value = new April2();
  return April2;
}();
var May = /* @__PURE__ */ function() {
  function May2() {
  }
  ;
  May2.value = new May2();
  return May2;
}();
var June = /* @__PURE__ */ function() {
  function June2() {
  }
  ;
  June2.value = new June2();
  return June2;
}();
var July = /* @__PURE__ */ function() {
  function July2() {
  }
  ;
  July2.value = new July2();
  return July2;
}();
var August = /* @__PURE__ */ function() {
  function August2() {
  }
  ;
  August2.value = new August2();
  return August2;
}();
var September = /* @__PURE__ */ function() {
  function September2() {
  }
  ;
  September2.value = new September2();
  return September2;
}();
var October = /* @__PURE__ */ function() {
  function October2() {
  }
  ;
  October2.value = new October2();
  return October2;
}();
var November = /* @__PURE__ */ function() {
  function November2() {
  }
  ;
  November2.value = new November2();
  return November2;
}();
var December = /* @__PURE__ */ function() {
  function December2() {
  }
  ;
  December2.value = new December2();
  return December2;
}();
var showWeekday = {
  show: function(v) {
    if (v instanceof Monday) {
      return "Monday";
    }
    ;
    if (v instanceof Tuesday) {
      return "Tuesday";
    }
    ;
    if (v instanceof Wednesday) {
      return "Wednesday";
    }
    ;
    if (v instanceof Thursday) {
      return "Thursday";
    }
    ;
    if (v instanceof Friday) {
      return "Friday";
    }
    ;
    if (v instanceof Saturday) {
      return "Saturday";
    }
    ;
    if (v instanceof Sunday) {
      return "Sunday";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 184, column 1 - line 191, column 25): " + [v.constructor.name]);
  }
};
var showMonth = {
  show: function(v) {
    if (v instanceof January) {
      return "January";
    }
    ;
    if (v instanceof February) {
      return "February";
    }
    ;
    if (v instanceof March) {
      return "March";
    }
    ;
    if (v instanceof April) {
      return "April";
    }
    ;
    if (v instanceof May) {
      return "May";
    }
    ;
    if (v instanceof June) {
      return "June";
    }
    ;
    if (v instanceof July) {
      return "July";
    }
    ;
    if (v instanceof August) {
      return "August";
    }
    ;
    if (v instanceof September) {
      return "September";
    }
    ;
    if (v instanceof October) {
      return "October";
    }
    ;
    if (v instanceof November) {
      return "November";
    }
    ;
    if (v instanceof December) {
      return "December";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 101, column 1 - line 113, column 29): " + [v.constructor.name]);
  }
};
var ordYear = ordInt;
var ordDay = ordInt;
var eqYear = eqInt;
var eqWeekday = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return true;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return true;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return true;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return true;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return true;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return true;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordWeekday = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return EQ.value;
      }
      ;
      if (x instanceof Monday) {
        return LT.value;
      }
      ;
      if (y instanceof Monday) {
        return GT.value;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Tuesday) {
        return LT.value;
      }
      ;
      if (y instanceof Tuesday) {
        return GT.value;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Wednesday) {
        return LT.value;
      }
      ;
      if (y instanceof Wednesday) {
        return GT.value;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return EQ.value;
      }
      ;
      if (x instanceof Thursday) {
        return LT.value;
      }
      ;
      if (y instanceof Thursday) {
        return GT.value;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return EQ.value;
      }
      ;
      if (x instanceof Friday) {
        return LT.value;
      }
      ;
      if (y instanceof Friday) {
        return GT.value;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return EQ.value;
      }
      ;
      if (x instanceof Saturday) {
        return LT.value;
      }
      ;
      if (y instanceof Saturday) {
        return GT.value;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqWeekday;
  }
};
var eqMonth = {
  eq: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return true;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return true;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return true;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return true;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return true;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return true;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return true;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return true;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return true;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return true;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return true;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordMonth = {
  compare: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return EQ.value;
      }
      ;
      if (x instanceof January) {
        return LT.value;
      }
      ;
      if (y instanceof January) {
        return GT.value;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return EQ.value;
      }
      ;
      if (x instanceof February) {
        return LT.value;
      }
      ;
      if (y instanceof February) {
        return GT.value;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return EQ.value;
      }
      ;
      if (x instanceof March) {
        return LT.value;
      }
      ;
      if (y instanceof March) {
        return GT.value;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return EQ.value;
      }
      ;
      if (x instanceof April) {
        return LT.value;
      }
      ;
      if (y instanceof April) {
        return GT.value;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return EQ.value;
      }
      ;
      if (x instanceof May) {
        return LT.value;
      }
      ;
      if (y instanceof May) {
        return GT.value;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return EQ.value;
      }
      ;
      if (x instanceof June) {
        return LT.value;
      }
      ;
      if (y instanceof June) {
        return GT.value;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return EQ.value;
      }
      ;
      if (x instanceof July) {
        return LT.value;
      }
      ;
      if (y instanceof July) {
        return GT.value;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return EQ.value;
      }
      ;
      if (x instanceof August) {
        return LT.value;
      }
      ;
      if (y instanceof August) {
        return GT.value;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return EQ.value;
      }
      ;
      if (x instanceof September) {
        return LT.value;
      }
      ;
      if (y instanceof September) {
        return GT.value;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return EQ.value;
      }
      ;
      if (x instanceof October) {
        return LT.value;
      }
      ;
      if (y instanceof October) {
        return GT.value;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return EQ.value;
      }
      ;
      if (x instanceof November) {
        return LT.value;
      }
      ;
      if (y instanceof November) {
        return GT.value;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqMonth;
  }
};
var eqDay = eqInt;
var boundedYear = /* @__PURE__ */ function() {
  return {
    bottom: -271820 | 0,
    top: 275759,
    Ord0: function() {
      return ordYear;
    }
  };
}();
var boundedWeekday = /* @__PURE__ */ function() {
  return {
    bottom: Monday.value,
    top: Sunday.value,
    Ord0: function() {
      return ordWeekday;
    }
  };
}();
var boundedMonth = /* @__PURE__ */ function() {
  return {
    bottom: January.value,
    top: December.value,
    Ord0: function() {
      return ordMonth;
    }
  };
}();
var boundedEnumYear = {
  cardinality: 547580,
  toEnum: function(n) {
    if (n >= (-271820 | 0) && n <= 275759) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 35, column 1 - line 40, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedYear;
  },
  Enum1: function() {
    return $lazy_enumYear(0);
  }
};
var $lazy_enumYear = /* @__PURE__ */ $runtime_lazy6("enumYear", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $55 = toEnum(boundedEnumYear);
      var $56 = fromEnum(boundedEnumYear);
      return function($57) {
        return $55(function(v) {
          return v + 1 | 0;
        }($56($57)));
      };
    }(),
    pred: function() {
      var $58 = toEnum(boundedEnumYear);
      var $59 = fromEnum(boundedEnumYear);
      return function($60) {
        return $58(function(v) {
          return v - 1 | 0;
        }($59($60)));
      };
    }(),
    Ord0: function() {
      return ordYear;
    }
  };
});
var boundedEnumWeekday = {
  cardinality: 7,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(Monday.value);
    }
    ;
    if (v === 2) {
      return new Just(Tuesday.value);
    }
    ;
    if (v === 3) {
      return new Just(Wednesday.value);
    }
    ;
    if (v === 4) {
      return new Just(Thursday.value);
    }
    ;
    if (v === 5) {
      return new Just(Friday.value);
    }
    ;
    if (v === 6) {
      return new Just(Saturday.value);
    }
    ;
    if (v === 7) {
      return new Just(Sunday.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Monday) {
      return 1;
    }
    ;
    if (v instanceof Tuesday) {
      return 2;
    }
    ;
    if (v instanceof Wednesday) {
      return 3;
    }
    ;
    if (v instanceof Thursday) {
      return 4;
    }
    ;
    if (v instanceof Friday) {
      return 5;
    }
    ;
    if (v instanceof Saturday) {
      return 6;
    }
    ;
    if (v instanceof Sunday) {
      return 7;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 175, column 14 - line 182, column 16): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedWeekday;
  },
  Enum1: function() {
    return $lazy_enumWeekday(0);
  }
};
var $lazy_enumWeekday = /* @__PURE__ */ $runtime_lazy6("enumWeekday", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $61 = toEnum(boundedEnumWeekday);
      var $62 = fromEnum(boundedEnumWeekday);
      return function($63) {
        return $61(function(v) {
          return v + 1 | 0;
        }($62($63)));
      };
    }(),
    pred: function() {
      var $64 = toEnum(boundedEnumWeekday);
      var $65 = fromEnum(boundedEnumWeekday);
      return function($66) {
        return $64(function(v) {
          return v - 1 | 0;
        }($65($66)));
      };
    }(),
    Ord0: function() {
      return ordWeekday;
    }
  };
});
var boundedEnumMonth = {
  cardinality: 12,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(January.value);
    }
    ;
    if (v === 2) {
      return new Just(February.value);
    }
    ;
    if (v === 3) {
      return new Just(March.value);
    }
    ;
    if (v === 4) {
      return new Just(April.value);
    }
    ;
    if (v === 5) {
      return new Just(May.value);
    }
    ;
    if (v === 6) {
      return new Just(June.value);
    }
    ;
    if (v === 7) {
      return new Just(July.value);
    }
    ;
    if (v === 8) {
      return new Just(August.value);
    }
    ;
    if (v === 9) {
      return new Just(September.value);
    }
    ;
    if (v === 10) {
      return new Just(October.value);
    }
    ;
    if (v === 11) {
      return new Just(November.value);
    }
    ;
    if (v === 12) {
      return new Just(December.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof January) {
      return 1;
    }
    ;
    if (v instanceof February) {
      return 2;
    }
    ;
    if (v instanceof March) {
      return 3;
    }
    ;
    if (v instanceof April) {
      return 4;
    }
    ;
    if (v instanceof May) {
      return 5;
    }
    ;
    if (v instanceof June) {
      return 6;
    }
    ;
    if (v instanceof July) {
      return 7;
    }
    ;
    if (v instanceof August) {
      return 8;
    }
    ;
    if (v instanceof September) {
      return 9;
    }
    ;
    if (v instanceof October) {
      return 10;
    }
    ;
    if (v instanceof November) {
      return 11;
    }
    ;
    if (v instanceof December) {
      return 12;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 87, column 14 - line 99, column 19): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedMonth;
  },
  Enum1: function() {
    return $lazy_enumMonth(0);
  }
};
var $lazy_enumMonth = /* @__PURE__ */ $runtime_lazy6("enumMonth", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $67 = toEnum(boundedEnumMonth);
      var $68 = fromEnum(boundedEnumMonth);
      return function($69) {
        return $67(function(v) {
          return v + 1 | 0;
        }($68($69)));
      };
    }(),
    pred: function() {
      var $70 = toEnum(boundedEnumMonth);
      var $71 = fromEnum(boundedEnumMonth);
      return function($72) {
        return $70(function(v) {
          return v - 1 | 0;
        }($71($72)));
      };
    }(),
    Ord0: function() {
      return ordMonth;
    }
  };
});
var boundedDay = {
  bottom: 1,
  top: 31,
  Ord0: function() {
    return ordDay;
  }
};
var boundedEnumDay = {
  cardinality: 31,
  toEnum: function(n) {
    if (n >= 1 && n <= 31) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 133, column 1 - line 138, column 23): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedDay;
  },
  Enum1: function() {
    return $lazy_enumDay(0);
  }
};
var $lazy_enumDay = /* @__PURE__ */ $runtime_lazy6("enumDay", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $73 = toEnum(boundedEnumDay);
      var $74 = fromEnum(boundedEnumDay);
      return function($75) {
        return $73(function(v) {
          return v + 1 | 0;
        }($74($75)));
      };
    }(),
    pred: function() {
      var $76 = toEnum(boundedEnumDay);
      var $77 = fromEnum(boundedEnumDay);
      return function($78) {
        return $76(function(v) {
          return v - 1 | 0;
        }($77($78)));
      };
    }(),
    Ord0: function() {
      return ordDay;
    }
  };
});

// output/Data.Date/index.js
var fromEnum3 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromJust5 = /* @__PURE__ */ fromJust();
var toEnum2 = /* @__PURE__ */ toEnum(boundedEnumWeekday);
var eq14 = /* @__PURE__ */ eq(eqYear);
var eq22 = /* @__PURE__ */ eq(eqMonth);
var eq3 = /* @__PURE__ */ eq(eqDay);
var compare3 = /* @__PURE__ */ compare(ordYear);
var compare12 = /* @__PURE__ */ compare(ordMonth);
var compare22 = /* @__PURE__ */ compare(ordDay);
var toEnum22 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var $$Date = /* @__PURE__ */ function() {
  function $$Date2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  $$Date2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new $$Date2(value0, value12, value22);
      };
    };
  };
  return $$Date2;
}();
var year = function(v) {
  return v.value0;
};
var weekday = function(v) {
  var n = calcWeekday(v.value0, fromEnum3(v.value1), v.value2);
  var $86 = n === 0;
  if ($86) {
    return fromJust5(toEnum2(7));
  }
  ;
  return fromJust5(toEnum2(n));
};
var month = function(v) {
  return v.value1;
};
var eqDate = {
  eq: function(x) {
    return function(y) {
      return eq14(x.value0)(y.value0) && eq22(x.value1)(y.value1) && eq3(x.value2)(y.value2);
    };
  }
};
var ordDate = {
  compare: function(x) {
    return function(y) {
      var v = compare3(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      var v1 = compare12(x.value1)(y.value1);
      if (v1 instanceof LT) {
        return LT.value;
      }
      ;
      if (v1 instanceof GT) {
        return GT.value;
      }
      ;
      return compare22(x.value2)(y.value2);
    };
  },
  Eq0: function() {
    return eqDate;
  }
};
var day = function(v) {
  return v.value2;
};
var canonicalDate = function(y) {
  return function(m) {
    return function(d) {
      var mkDate = function(y$prime) {
        return function(m$prime) {
          return function(d$prime) {
            return new $$Date(y$prime, fromJust5(toEnum22(m$prime)), d$prime);
          };
        };
      };
      return canonicalDateImpl(mkDate, y, fromEnum3(m), d);
    };
  };
};

// output/Data.Time.Component/index.js
var $runtime_lazy7 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var ordSecond = ordInt;
var ordMinute = ordInt;
var ordMillisecond = ordInt;
var ordHour = ordInt;
var eqSecond = eqInt;
var eqMinute = eqInt;
var eqMillisecond = eqInt;
var eqHour = eqInt;
var boundedSecond = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordSecond;
  }
};
var boundedMinute = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordMinute;
  }
};
var boundedMillisecond = {
  bottom: 0,
  top: 999,
  Ord0: function() {
    return ordMillisecond;
  }
};
var boundedHour = {
  bottom: 0,
  top: 23,
  Ord0: function() {
    return ordHour;
  }
};
var boundedEnumSecond = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 90, column 1 - line 95, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedSecond;
  },
  Enum1: function() {
    return $lazy_enumSecond(0);
  }
};
var $lazy_enumSecond = /* @__PURE__ */ $runtime_lazy7("enumSecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $36 = toEnum(boundedEnumSecond);
      var $37 = fromEnum(boundedEnumSecond);
      return function($38) {
        return $36(function(v) {
          return v + 1 | 0;
        }($37($38)));
      };
    }(),
    pred: function() {
      var $39 = toEnum(boundedEnumSecond);
      var $40 = fromEnum(boundedEnumSecond);
      return function($41) {
        return $39(function(v) {
          return v - 1 | 0;
        }($40($41)));
      };
    }(),
    Ord0: function() {
      return ordSecond;
    }
  };
});
var boundedEnumMinute = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 61, column 1 - line 66, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMinute;
  },
  Enum1: function() {
    return $lazy_enumMinute(0);
  }
};
var $lazy_enumMinute = /* @__PURE__ */ $runtime_lazy7("enumMinute", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $42 = toEnum(boundedEnumMinute);
      var $43 = fromEnum(boundedEnumMinute);
      return function($44) {
        return $42(function(v) {
          return v + 1 | 0;
        }($43($44)));
      };
    }(),
    pred: function() {
      var $45 = toEnum(boundedEnumMinute);
      var $46 = fromEnum(boundedEnumMinute);
      return function($47) {
        return $45(function(v) {
          return v - 1 | 0;
        }($46($47)));
      };
    }(),
    Ord0: function() {
      return ordMinute;
    }
  };
});
var boundedEnumMillisecond = {
  cardinality: 1e3,
  toEnum: function(n) {
    if (n >= 0 && n <= 999) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 120, column 1 - line 125, column 31): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMillisecond;
  },
  Enum1: function() {
    return $lazy_enumMillisecond(0);
  }
};
var $lazy_enumMillisecond = /* @__PURE__ */ $runtime_lazy7("enumMillisecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $48 = toEnum(boundedEnumMillisecond);
      var $49 = fromEnum(boundedEnumMillisecond);
      return function($50) {
        return $48(function(v) {
          return v + 1 | 0;
        }($49($50)));
      };
    }(),
    pred: function() {
      var $51 = toEnum(boundedEnumMillisecond);
      var $52 = fromEnum(boundedEnumMillisecond);
      return function($53) {
        return $51(function(v) {
          return v - 1 | 0;
        }($52($53)));
      };
    }(),
    Ord0: function() {
      return ordMillisecond;
    }
  };
});
var boundedEnumHour = {
  cardinality: 24,
  toEnum: function(n) {
    if (n >= 0 && n <= 23) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 32, column 1 - line 37, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedHour;
  },
  Enum1: function() {
    return $lazy_enumHour(0);
  }
};
var $lazy_enumHour = /* @__PURE__ */ $runtime_lazy7("enumHour", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $54 = toEnum(boundedEnumHour);
      var $55 = fromEnum(boundedEnumHour);
      return function($56) {
        return $54(function(v) {
          return v + 1 | 0;
        }($55($56)));
      };
    }(),
    pred: function() {
      var $57 = toEnum(boundedEnumHour);
      var $58 = fromEnum(boundedEnumHour);
      return function($59) {
        return $57(function(v) {
          return v - 1 | 0;
        }($58($59)));
      };
    }(),
    Ord0: function() {
      return ordHour;
    }
  };
});

// output/Data.Time/index.js
var eq4 = /* @__PURE__ */ eq(eqHour);
var eq15 = /* @__PURE__ */ eq(eqMinute);
var eq23 = /* @__PURE__ */ eq(eqSecond);
var eq32 = /* @__PURE__ */ eq(eqMillisecond);
var compare4 = /* @__PURE__ */ compare(ordHour);
var compare13 = /* @__PURE__ */ compare(ordMinute);
var compare23 = /* @__PURE__ */ compare(ordSecond);
var compare32 = /* @__PURE__ */ compare(ordMillisecond);
var Time = /* @__PURE__ */ function() {
  function Time2(value0, value12, value22, value3) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value3;
  }
  ;
  Time2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value3) {
          return new Time2(value0, value12, value22, value3);
        };
      };
    };
  };
  return Time2;
}();
var second = function(v) {
  return v.value2;
};
var minute = function(v) {
  return v.value1;
};
var millisecond = function(v) {
  return v.value3;
};
var hour = function(v) {
  return v.value0;
};
var eqTime = {
  eq: function(x) {
    return function(y) {
      return eq4(x.value0)(y.value0) && eq15(x.value1)(y.value1) && eq23(x.value2)(y.value2) && eq32(x.value3)(y.value3);
    };
  }
};
var ordTime = {
  compare: function(x) {
    return function(y) {
      var v = compare4(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      var v1 = compare13(x.value1)(y.value1);
      if (v1 instanceof LT) {
        return LT.value;
      }
      ;
      if (v1 instanceof GT) {
        return GT.value;
      }
      ;
      var v2 = compare23(x.value2)(y.value2);
      if (v2 instanceof LT) {
        return LT.value;
      }
      ;
      if (v2 instanceof GT) {
        return GT.value;
      }
      ;
      return compare32(x.value3)(y.value3);
    };
  },
  Eq0: function() {
    return eqTime;
  }
};

// output/Data.DateTime/index.js
var eq5 = /* @__PURE__ */ eq(eqDate);
var eq16 = /* @__PURE__ */ eq(eqTime);
var compare5 = /* @__PURE__ */ compare(ordDate);
var compare14 = /* @__PURE__ */ compare(ordTime);
var DateTime = /* @__PURE__ */ function() {
  function DateTime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DateTime2.create = function(value0) {
    return function(value12) {
      return new DateTime2(value0, value12);
    };
  };
  return DateTime2;
}();
var eqDateTime = {
  eq: function(x) {
    return function(y) {
      return eq5(x.value0)(y.value0) && eq16(x.value1)(y.value1);
    };
  }
};
var ordDateTime = {
  compare: function(x) {
    return function(y) {
      var v = compare5(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      return compare14(x.value1)(y.value1);
    };
  },
  Eq0: function() {
    return eqDateTime;
  }
};

// output/Data.DateTime.Instant/foreign.js
var createDateTime = function(y, m, d, h, mi, s, ms) {
  var dateTime = new Date(Date.UTC(y, m, d, h, mi, s, ms));
  if (y >= 0 && y < 100) {
    dateTime.setUTCFullYear(y);
  }
  return dateTime;
};
function fromDateTimeImpl(y, mo, d, h, mi, s, ms) {
  return createDateTime(y, mo - 1, d, h, mi, s, ms).getTime();
}
function toDateTimeImpl(ctor) {
  return function(instant2) {
    var dt = new Date(instant2);
    return ctor(dt.getUTCFullYear())(dt.getUTCMonth() + 1)(dt.getUTCDate())(dt.getUTCHours())(dt.getUTCMinutes())(dt.getUTCSeconds())(dt.getUTCMilliseconds());
  };
}

// output/Data.DateTime.Instant/index.js
var fromJust6 = /* @__PURE__ */ fromJust();
var toEnum3 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var fromEnum4 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var unInstant = function(v) {
  return v;
};
var toDateTime = /* @__PURE__ */ function() {
  var mkDateTime = function(y) {
    return function(mo) {
      return function(d) {
        return function(h) {
          return function(mi) {
            return function(s) {
              return function(ms) {
                return new DateTime(canonicalDate(y)(fromJust6(toEnum3(mo)))(d), new Time(h, mi, s, ms));
              };
            };
          };
        };
      };
    };
  };
  return toDateTimeImpl(mkDateTime);
}();
var instant = function(v) {
  if (v >= -86399778816e5 && v <= 8639977881599999) {
    return new Just(v);
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.DateTime.Instant (line 44, column 1 - line 44, column 41): " + [v.constructor.name]);
};
var fromDateTime = function(v) {
  return fromDateTimeImpl(year(v.value0), fromEnum4(month(v.value0)), day(v.value0), hour(v.value1), minute(v.value1), second(v.value1), millisecond(v.value1));
};

// output/Parsing/index.js
var unwrap4 = /* @__PURE__ */ unwrap();
var ParseState = /* @__PURE__ */ function() {
  function ParseState2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ParseState2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ParseState2(value0, value12, value22);
      };
    };
  };
  return ParseState2;
}();
var ParseError = /* @__PURE__ */ function() {
  function ParseError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseError2.create = function(value0) {
    return function(value12) {
      return new ParseError2(value0, value12);
    };
  };
  return ParseError2;
}();
var More = /* @__PURE__ */ function() {
  function More2(value0) {
    this.value0 = value0;
  }
  ;
  More2.create = function(value0) {
    return new More2(value0);
  };
  return More2;
}();
var Lift = /* @__PURE__ */ function() {
  function Lift2(value0) {
    this.value0 = value0;
  }
  ;
  Lift2.create = function(value0) {
    return new Lift2(value0);
  };
  return Lift2;
}();
var Stop = /* @__PURE__ */ function() {
  function Stop2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Stop2.create = function(value0) {
    return function(value12) {
      return new Stop2(value0, value12);
    };
  };
  return Stop2;
}();
var functorParserT = {
  map: function(f) {
    return function(v) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift13, $$throw2, function(state2, a) {
            return more(function(v2) {
              return done(state2, f(a));
            });
          });
        });
      };
    };
  }
};
var applyParserT = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v2) {
          return v(state1, more, lift13, $$throw2, function(state2, f) {
            return more(function(v3) {
              return v1(state2, more, lift13, $$throw2, function(state3, a) {
                return more(function(v42) {
                  return done(state3, f(a));
                });
              });
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var bindParserT = {
  bind: function(v) {
    return function(next2) {
      return function(state1, more, lift13, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift13, $$throw2, function(state2, a) {
            return more(function(v2) {
              var v3 = next2(a);
              return v3(state2, more, lift13, $$throw2, done);
            });
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindParserT);
var applicativeParserT = {
  pure: function(a) {
    return function(state1, v, v1, v2, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var monadParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Bind1: function() {
    return bindParserT;
  }
};
var monadThrowParseErrorParse = {
  throwError: function(err) {
    return function(state1, v, v1, $$throw2, v2) {
      return $$throw2(state1, err);
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var throwError3 = /* @__PURE__ */ throwError(monadThrowParseErrorParse);
var altParserT = {
  alt: function(v) {
    return function(v1) {
      return function(v2, more, lift13, $$throw2, done) {
        return more(function(v3) {
          return v(new ParseState(v2.value0, v2.value1, false), more, lift13, function(v42, err) {
            return more(function(v5) {
              if (v42.value2) {
                return $$throw2(v42, err);
              }
              ;
              return v1(v2, more, lift13, $$throw2, done);
            });
          }, done);
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var stateParserT = function(k) {
  return function(state1, v, v1, v2, done) {
    var v3 = k(state1);
    return done(v3.value1, v3.value0);
  };
};
var runParserT$prime = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var map44 = map(Monad0.Bind1().Apply0().Functor0());
  var pure118 = pure(Monad0.Applicative0());
  var tailRecM5 = tailRecM(dictMonadRec);
  return function(state1) {
    return function(v) {
      var go = function($copy_step) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(step2) {
          var v1 = step2(unit);
          if (v1 instanceof More) {
            $copy_step = v1.value0;
            return;
          }
          ;
          if (v1 instanceof Lift) {
            $tco_done = true;
            return map44(Loop.create)(v1.value0);
          }
          ;
          if (v1 instanceof Stop) {
            $tco_done = true;
            return pure118(new Done(new Tuple(v1.value1, v1.value0)));
          }
          ;
          throw new Error("Failed pattern match at Parsing (line 152, column 13 - line 158, column 32): " + [v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_step);
        }
        ;
        return $tco_result;
      };
      return tailRecM5(go)(function(v1) {
        return v(state1, More.create, Lift.create, function(state2, err) {
          return new Stop(state2, new Left(err));
        }, function(state2, res) {
          return new Stop(state2, new Right(res));
        });
      });
    };
  };
};
var position = /* @__PURE__ */ stateParserT(function(v) {
  return new Tuple(v.value1, v);
});
var initialPos = {
  index: 0,
  line: 1,
  column: 1
};
var runParserT = function(dictMonadRec) {
  var map44 = map(dictMonadRec.Monad0().Bind1().Apply0().Functor0());
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(s) {
    return function(p) {
      var initialState = new ParseState(s, initialPos, false);
      return map44(fst)(runParserT$prime1(initialState)(p));
    };
  };
};
var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
var runParser = function(s) {
  var $281 = runParserT1(s);
  return function($282) {
    return unwrap4($281($282));
  };
};
var failWithPosition = function(message3) {
  return function(pos) {
    return throwError3(new ParseError(message3, pos));
  };
};
var fail2 = function(message3) {
  return bindFlipped3(failWithPosition(message3))(position);
};

// output/Parsing.Combinators/index.js
var alt2 = /* @__PURE__ */ alt(altParserT);
var withErrorMessage = function(p) {
  return function(msg) {
    return alt2(p)(fail2("Expected " + msg));
  };
};
var tryRethrow = function(v) {
  return function(v1, more, lift8, $$throw2, done) {
    return v(v1, more, lift8, function(v2, v3) {
      return $$throw2(new ParseState(v2.value0, v2.value1, v1.value2), new ParseError(v3.value0, v1.value1));
    }, done);
  };
};

// output/Data.String.Regex/foreign.js
var regexImpl = function(left) {
  return function(right) {
    return function(s1) {
      return function(s2) {
        try {
          return right(new RegExp(s1, s2));
        } catch (e) {
          return left(e.message);
        }
      };
    };
  };
};
var test = function(r) {
  return function(s) {
    var lastIndex = r.lastIndex;
    var result = r.test(s);
    r.lastIndex = lastIndex;
    return result;
  };
};
var _match = function(just) {
  return function(nothing) {
    return function(r) {
      return function(s) {
        var m = s.match(r);
        if (m == null || m.length === 0) {
          return nothing;
        } else {
          for (var i = 0; i < m.length; i++) {
            m[i] = m[i] == null ? nothing : just(m[i]);
          }
          return just(m);
        }
      };
    };
  };
};
var replace2 = function(r) {
  return function(s1) {
    return function(s2) {
      return s2.replace(r, s1);
    };
  };
};
var split2 = function(r) {
  return function(s) {
    return s.split(r);
  };
};

// output/Data.String.Regex.Flags/index.js
var semigroupRegexFlags = {
  append: function(v) {
    return function(v1) {
      return {
        global: v.global || v1.global,
        ignoreCase: v.ignoreCase || v1.ignoreCase,
        multiline: v.multiline || v1.multiline,
        dotAll: v.dotAll || v1.dotAll,
        sticky: v.sticky || v1.sticky,
        unicode: v.unicode || v1.unicode
      };
    };
  }
};
var noFlags = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var monoidRegexFlags = {
  mempty: noFlags,
  Semigroup0: function() {
    return semigroupRegexFlags;
  }
};
var ignoreCase = {
  global: false,
  ignoreCase: true,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var global2 = {
  global: true,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};

// output/Data.String.Regex/index.js
var renderFlags = function(v) {
  return function() {
    if (v.global) {
      return "g";
    }
    ;
    return "";
  }() + (function() {
    if (v.ignoreCase) {
      return "i";
    }
    ;
    return "";
  }() + (function() {
    if (v.multiline) {
      return "m";
    }
    ;
    return "";
  }() + (function() {
    if (v.dotAll) {
      return "s";
    }
    ;
    return "";
  }() + (function() {
    if (v.sticky) {
      return "y";
    }
    ;
    return "";
  }() + function() {
    if (v.unicode) {
      return "u";
    }
    ;
    return "";
  }()))));
};
var regex = function(s) {
  return function(f) {
    return regexImpl(Left.create)(Right.create)(s)(renderFlags(f));
  };
};
var match = /* @__PURE__ */ function() {
  return _match(Just.create)(Nothing.value);
}();

// output/Parsing.String/index.js
var fromEnum5 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
var fromJust7 = /* @__PURE__ */ fromJust();
var toEnum4 = /* @__PURE__ */ toEnum(boundedEnumChar);
var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorEither);
var map17 = /* @__PURE__ */ map(functorMaybe);
var show12 = /* @__PURE__ */ show(showString);
var show22 = /* @__PURE__ */ show(showChar);
var updatePosSingle = function(v) {
  return function(cp) {
    return function(after) {
      var v1 = fromEnum5(cp);
      if (v1 === 10) {
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 13) {
        var v2 = codePointAt(0)(after);
        if (v2 instanceof Just && fromEnum5(v2.value0) === 10) {
          return {
            index: v.index + 1 | 0,
            line: v.line,
            column: v.column
          };
        }
        ;
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 9) {
        return {
          index: v.index + 1 | 0,
          line: v.line,
          column: (v.column + 8 | 0) - mod3(v.column - 1 | 0)(8) | 0
        };
      }
      ;
      return {
        index: v.index + 1 | 0,
        line: v.line,
        column: v.column + 1 | 0
      };
    };
  };
};
var updatePosString = function($copy_pos) {
  return function($copy_before) {
    return function($copy_after) {
      var $tco_var_pos = $copy_pos;
      var $tco_var_before = $copy_before;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(pos, before, after) {
        var v = uncons2(before);
        if (v instanceof Nothing) {
          $tco_done = true;
          return pos;
        }
        ;
        if (v instanceof Just) {
          var newPos = function() {
            if ($$null2(v.value0.tail)) {
              return updatePosSingle(pos)(v.value0.head)(after);
            }
            ;
            if (otherwise) {
              return updatePosSingle(pos)(v.value0.head)(v.value0.tail);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 165, column 7 - line 167, column 52): ");
          }();
          $tco_var_pos = newPos;
          $tco_var_before = v.value0.tail;
          $copy_after = after;
          return;
        }
        ;
        throw new Error("Failed pattern match at Parsing.String (line 161, column 36 - line 168, column 38): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_pos, $tco_var_before, $copy_after);
      }
      ;
      return $tco_result;
    };
  };
};
var satisfy = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = uncons2(v.value0);
            if (v3 instanceof Nothing) {
              return $$throw2(v, new ParseError("Unexpected EOF", v.value1));
            }
            ;
            if (v3 instanceof Just) {
              var cp = fromEnum5(v3.value0.head);
              var $85 = cp < 0 || cp > 65535;
              if ($85) {
                return $$throw2(v, new ParseError("Expected Char", v.value1));
              }
              ;
              var ch = fromJust7(toEnum4(cp));
              var $86 = f(ch);
              if ($86) {
                return done(new ParseState(v3.value0.tail, updatePosSingle(v.value1)(v3.value0.head)(v3.value0.tail), true), ch);
              }
              ;
              return $$throw2(v, new ParseError("Predicate unsatisfied", v.value1));
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 114, column 7 - line 129, column 75): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var consumeWith = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = f(v.value0);
            if (v3 instanceof Left) {
              return $$throw2(v, new ParseError(v3.value0, v.value1));
            }
            ;
            if (v3 instanceof Right) {
              return done(new ParseState(v3.value0.remainder, updatePosString(v.value1)(v3.value0.consumed)(v3.value0.remainder), !$$null2(v3.value0.consumed)), v3.value0.value);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 286, column 7 - line 290, column 121): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var regex2 = function(pattern) {
  return function(flags) {
    return mapFlipped2(regex("^(" + (pattern + ")"))(flags))(function(regexobj) {
      return consumeWith(function(input) {
        var v = map17(head2)(match(regexobj)(input));
        if (v instanceof Just && v.value0 instanceof Just) {
          var remainder2 = drop2(length3(v.value0.value0))(input);
          return new Right({
            value: v.value0.value0,
            consumed: v.value0.value0,
            remainder: remainder2
          });
        }
        ;
        return new Left("No Regex pattern match");
      });
    });
  };
};
var string2 = function(str2) {
  return consumeWith(function(input) {
    var v = stripPrefix2(str2)(input);
    if (v instanceof Just) {
      return new Right({
        value: str2,
        consumed: str2,
        remainder: v.value0
      });
    }
    ;
    return new Left("Expected " + show12(str2));
  });
};
var $$char2 = function(c) {
  return withErrorMessage(satisfy(function(v) {
    return v === c;
  }))(show22(c));
};

// output/Data.Char/index.js
var toCharCode2 = /* @__PURE__ */ fromEnum(boundedEnumChar);

// output/Parsing.String.Basic/index.js
var identity11 = /* @__PURE__ */ identity(categoryFn);
var mempty3 = /* @__PURE__ */ mempty(monoidRegexFlags);
var alt3 = /* @__PURE__ */ alt(altParserT);
var pure6 = /* @__PURE__ */ pure(applicativeParserT);
var bind4 = /* @__PURE__ */ bind(bindParserT);
var intDecimalRegex = /* @__PURE__ */ either(unsafeCrashWith)(identity11)(/* @__PURE__ */ regex2("[+-]?[0-9]+")(mempty3));
var intDecimal = /* @__PURE__ */ tryRethrow(/* @__PURE__ */ bind4(/* @__PURE__ */ alt3(intDecimalRegex)(/* @__PURE__ */ fail2("Expected Int")))(function(section) {
  var v = fromString2(section);
  if (v instanceof Nothing) {
    return fail2("Expected Int");
  }
  ;
  if (v instanceof Just) {
    return pure6(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Parsing.String.Basic (line 140, column 3 - line 142, column 21): " + [v.constructor.name]);
}));

// output/Data.Formatter.DateTime/index.js
var show3 = /* @__PURE__ */ show(showInt);
var foldMap3 = /* @__PURE__ */ foldMap(foldableList);
var foldMap12 = /* @__PURE__ */ foldMap3(monoidString);
var abs3 = /* @__PURE__ */ abs(ordInt)(ringInt);
var fromEnum6 = /* @__PURE__ */ fromEnum(boundedEnumYear);
var show13 = /* @__PURE__ */ show(showMonth);
var fromEnum1 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromEnum22 = /* @__PURE__ */ fromEnum(boundedEnumDay);
var unwrap5 = /* @__PURE__ */ unwrap();
var fromEnum32 = /* @__PURE__ */ fromEnum(boundedEnumWeekday);
var show23 = /* @__PURE__ */ show(showWeekday);
var fromEnum42 = /* @__PURE__ */ fromEnum(boundedEnumHour);
var mod4 = /* @__PURE__ */ mod(euclideanRingInt);
var fromEnum52 = /* @__PURE__ */ fromEnum(boundedEnumMinute);
var fromEnum62 = /* @__PURE__ */ fromEnum(boundedEnumSecond);
var fromEnum7 = /* @__PURE__ */ fromEnum(boundedEnumMillisecond);
var div1 = /* @__PURE__ */ div(euclideanRingInt);
var YearFull = /* @__PURE__ */ function() {
  function YearFull2() {
  }
  ;
  YearFull2.value = new YearFull2();
  return YearFull2;
}();
var YearTwoDigits = /* @__PURE__ */ function() {
  function YearTwoDigits2() {
  }
  ;
  YearTwoDigits2.value = new YearTwoDigits2();
  return YearTwoDigits2;
}();
var YearAbsolute = /* @__PURE__ */ function() {
  function YearAbsolute2() {
  }
  ;
  YearAbsolute2.value = new YearAbsolute2();
  return YearAbsolute2;
}();
var MonthFull = /* @__PURE__ */ function() {
  function MonthFull2() {
  }
  ;
  MonthFull2.value = new MonthFull2();
  return MonthFull2;
}();
var MonthShort = /* @__PURE__ */ function() {
  function MonthShort2() {
  }
  ;
  MonthShort2.value = new MonthShort2();
  return MonthShort2;
}();
var MonthTwoDigits = /* @__PURE__ */ function() {
  function MonthTwoDigits2() {
  }
  ;
  MonthTwoDigits2.value = new MonthTwoDigits2();
  return MonthTwoDigits2;
}();
var DayOfMonthTwoDigits = /* @__PURE__ */ function() {
  function DayOfMonthTwoDigits2() {
  }
  ;
  DayOfMonthTwoDigits2.value = new DayOfMonthTwoDigits2();
  return DayOfMonthTwoDigits2;
}();
var DayOfMonth = /* @__PURE__ */ function() {
  function DayOfMonth2() {
  }
  ;
  DayOfMonth2.value = new DayOfMonth2();
  return DayOfMonth2;
}();
var UnixTimestamp = /* @__PURE__ */ function() {
  function UnixTimestamp2() {
  }
  ;
  UnixTimestamp2.value = new UnixTimestamp2();
  return UnixTimestamp2;
}();
var DayOfWeek = /* @__PURE__ */ function() {
  function DayOfWeek2() {
  }
  ;
  DayOfWeek2.value = new DayOfWeek2();
  return DayOfWeek2;
}();
var DayOfWeekName = /* @__PURE__ */ function() {
  function DayOfWeekName2() {
  }
  ;
  DayOfWeekName2.value = new DayOfWeekName2();
  return DayOfWeekName2;
}();
var DayOfWeekNameShort = /* @__PURE__ */ function() {
  function DayOfWeekNameShort2() {
  }
  ;
  DayOfWeekNameShort2.value = new DayOfWeekNameShort2();
  return DayOfWeekNameShort2;
}();
var Hours24 = /* @__PURE__ */ function() {
  function Hours242() {
  }
  ;
  Hours242.value = new Hours242();
  return Hours242;
}();
var Hours12 = /* @__PURE__ */ function() {
  function Hours122() {
  }
  ;
  Hours122.value = new Hours122();
  return Hours122;
}();
var Meridiem = /* @__PURE__ */ function() {
  function Meridiem2() {
  }
  ;
  Meridiem2.value = new Meridiem2();
  return Meridiem2;
}();
var Minutes = /* @__PURE__ */ function() {
  function Minutes2() {
  }
  ;
  Minutes2.value = new Minutes2();
  return Minutes2;
}();
var MinutesTwoDigits = /* @__PURE__ */ function() {
  function MinutesTwoDigits2() {
  }
  ;
  MinutesTwoDigits2.value = new MinutesTwoDigits2();
  return MinutesTwoDigits2;
}();
var Seconds = /* @__PURE__ */ function() {
  function Seconds2() {
  }
  ;
  Seconds2.value = new Seconds2();
  return Seconds2;
}();
var SecondsTwoDigits = /* @__PURE__ */ function() {
  function SecondsTwoDigits2() {
  }
  ;
  SecondsTwoDigits2.value = new SecondsTwoDigits2();
  return SecondsTwoDigits2;
}();
var Milliseconds2 = /* @__PURE__ */ function() {
  function Milliseconds3() {
  }
  ;
  Milliseconds3.value = new Milliseconds3();
  return Milliseconds3;
}();
var MillisecondsShort = /* @__PURE__ */ function() {
  function MillisecondsShort2() {
  }
  ;
  MillisecondsShort2.value = new MillisecondsShort2();
  return MillisecondsShort2;
}();
var MillisecondsTwoDigits = /* @__PURE__ */ function() {
  function MillisecondsTwoDigits2() {
  }
  ;
  MillisecondsTwoDigits2.value = new MillisecondsTwoDigits2();
  return MillisecondsTwoDigits2;
}();
var Placeholder = /* @__PURE__ */ function() {
  function Placeholder2(value0) {
    this.value0 = value0;
  }
  ;
  Placeholder2.create = function(value0) {
    return new Placeholder2(value0);
  };
  return Placeholder2;
}();
var printShortMonth = function(v) {
  if (v instanceof January) {
    return "Jan";
  }
  ;
  if (v instanceof February) {
    return "Feb";
  }
  ;
  if (v instanceof March) {
    return "Mar";
  }
  ;
  if (v instanceof April) {
    return "Apr";
  }
  ;
  if (v instanceof May) {
    return "May";
  }
  ;
  if (v instanceof June) {
    return "Jun";
  }
  ;
  if (v instanceof July) {
    return "Jul";
  }
  ;
  if (v instanceof August) {
    return "Aug";
  }
  ;
  if (v instanceof September) {
    return "Sep";
  }
  ;
  if (v instanceof October) {
    return "Oct";
  }
  ;
  if (v instanceof November) {
    return "Nov";
  }
  ;
  if (v instanceof December) {
    return "Dec";
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 489, column 19 - line 501, column 22): " + [v.constructor.name]);
};
var padSingleDigit = function(i) {
  if (i < 0) {
    return "-" + padSingleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 194, column 1 - line 194, column 32): " + [i.constructor.name]);
};
var padQuadrupleDigit = function(i) {
  if (i < 0) {
    return "-" + padQuadrupleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "000" + show3(i);
  }
  ;
  if (i < 100) {
    return "00" + show3(i);
  }
  ;
  if (i < 1e3) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 207, column 1 - line 207, column 35): " + [i.constructor.name]);
};
var padDoubleDigit = function(i) {
  if (i < 0) {
    return "-" + padDoubleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "00" + show3(i);
  }
  ;
  if (i < 100) {
    return "0" + show3(i);
  }
  ;
  if (otherwise) {
    return show3(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 200, column 1 - line 200, column 32): " + [i.constructor.name]);
};
var formatYearTwoDigits = function(i) {
  var dateString = show3(abs3(i));
  var dateLength = length4(dateString);
  if (dateLength === 1) {
    return "0" + dateString;
  }
  ;
  if (dateLength === 2) {
    return dateString;
  }
  ;
  return drop3(dateLength - 2 | 0)(dateString);
};
var fix12 = function(h) {
  var $618 = h === 0;
  if ($618) {
    return 12;
  }
  ;
  return h;
};
var formatCommand = function(v) {
  return function(v1) {
    if (v1 instanceof YearFull) {
      return padQuadrupleDigit(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof YearTwoDigits) {
      return formatYearTwoDigits(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof YearAbsolute) {
      return show3(fromEnum6(year(v.value0)));
    }
    ;
    if (v1 instanceof MonthFull) {
      return show13(month(v.value0));
    }
    ;
    if (v1 instanceof MonthShort) {
      return printShortMonth(month(v.value0));
    }
    ;
    if (v1 instanceof MonthTwoDigits) {
      return padSingleDigit(fromEnum1(month(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonthTwoDigits) {
      return padSingleDigit(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonth) {
      return show3(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof UnixTimestamp) {
      return show3(floor2(function(v2) {
        return v2 / 1e3;
      }(unwrap5(unInstant(fromDateTime(v))))));
    }
    ;
    if (v1 instanceof DayOfWeek) {
      return show3(fromEnum32(weekday(v.value0)));
    }
    ;
    if (v1 instanceof DayOfWeekName) {
      return show23(weekday(v.value0));
    }
    ;
    if (v1 instanceof DayOfWeekNameShort) {
      return take2(3)(show23(weekday(v.value0)));
    }
    ;
    if (v1 instanceof Hours24) {
      return padSingleDigit(fromEnum42(hour(v.value1)));
    }
    ;
    if (v1 instanceof Hours12) {
      return padSingleDigit(fix12(mod4(fromEnum42(hour(v.value1)))(12)));
    }
    ;
    if (v1 instanceof Meridiem) {
      var $621 = fromEnum42(hour(v.value1)) >= 12;
      if ($621) {
        return "PM";
      }
      ;
      return "AM";
    }
    ;
    if (v1 instanceof Minutes) {
      return show3(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof MinutesTwoDigits) {
      return padSingleDigit(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof Seconds) {
      return show3(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof SecondsTwoDigits) {
      return padSingleDigit(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof Milliseconds2) {
      return padDoubleDigit(fromEnum7(millisecond(v.value1)));
    }
    ;
    if (v1 instanceof MillisecondsShort) {
      return show3(function(v2) {
        return div1(v2)(100);
      }(fromEnum7(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof MillisecondsTwoDigits) {
      return padSingleDigit(function(v2) {
        return div1(v2)(10);
      }(fromEnum7(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof Placeholder) {
      return v1.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 169, column 38 - line 192, column 21): " + [v1.constructor.name]);
  };
};
var format = function(f) {
  return function(d) {
    return foldMap12(formatCommand(d))(f);
  };
};

// node_modules/uuid/dist/esm/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm/rng.js
import { randomFillSync } from "crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// node_modules/uuid/dist/esm/native.js
import { randomUUID } from "crypto";
var native_default = { randomUUID };

// node_modules/uuid/dist/esm/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// output/Data.UUID/foreign.js
var getUUIDImpl = v4_default;

// output/Data.UUID/index.js
var UUID = function(x) {
  return x;
};
var toString5 = function(v) {
  return v;
};
var genUUID = /* @__PURE__ */ bind(bindEffect)(getUUIDImpl)(/* @__PURE__ */ function() {
  var $30 = pure(applicativeEffect);
  return function($31) {
    return $30(UUID($31));
  };
}());

// output/Node.Path/foreign.js
import path from "path";
var normalize = path.normalize;
function concat2(segments) {
  return path.join.apply(this, segments);
}
function resolve(from3) {
  return (to2) => () => path.resolve.apply(this, from3.concat([to2]));
}
function relative(from3) {
  return (to2) => path.relative(from3, to2);
}
var basename = path.basename;
var extname = path.extname;
var sep = path.sep;
var delimiter = path.delimiter;
var parse2 = path.parse;
var isAbsolute = path.isAbsolute;

// output/Node.Library.Execa/foreign.js
function setTimeoutImpl(timeout, cb) {
  const t = setTimeout(cb, timeout);
  return t.unref ? t : { unref: () => {
  } };
}
var undefinedVal = void 0;

// output/Data.String.Regex.Unsafe/index.js
var identity12 = /* @__PURE__ */ identity(categoryFn);
var unsafeRegex = function(s) {
  return function(f) {
    return either(unsafeCrashWith)(identity12)(regex(s)(f));
  };
};

// output/Effect.Timer/foreign.js
function setTimeoutImpl2(ms) {
  return function(fn) {
    return function() {
      return setTimeout(fn, ms);
    };
  };
}
function clearTimeoutImpl(id) {
  return function() {
    clearTimeout(id);
  };
}

// output/Effect.Timer/index.js
var setTimeout2 = setTimeoutImpl2;
var clearTimeout2 = clearTimeoutImpl;

// output/Node.Buffer.Immutable/foreign.js
import { Buffer as Buffer2 } from "node:buffer";
var alloc = (size6) => Buffer2.alloc(size6);
var size4 = (buff) => buff.length;
var fromStringImpl2 = (str2, encoding) => Buffer2.from(str2, encoding);
var readImpl = (ty, offset, buf) => buf["read" + ty](offset);
var toStringImpl = (enc, buff) => buff.toString(enc);
var sliceImpl2 = (start, end2, buff) => buff.slice(start, end2);
var concatToLength = (buffs, totalLength) => Buffer2.concat(buffs, totalLength);

// output/Node.Buffer.Types/index.js
var UInt8 = /* @__PURE__ */ function() {
  function UInt82() {
  }
  ;
  UInt82.value = new UInt82();
  return UInt82;
}();
var UInt16LE = /* @__PURE__ */ function() {
  function UInt16LE2() {
  }
  ;
  UInt16LE2.value = new UInt16LE2();
  return UInt16LE2;
}();
var UInt16BE = /* @__PURE__ */ function() {
  function UInt16BE2() {
  }
  ;
  UInt16BE2.value = new UInt16BE2();
  return UInt16BE2;
}();
var UInt32LE = /* @__PURE__ */ function() {
  function UInt32LE2() {
  }
  ;
  UInt32LE2.value = new UInt32LE2();
  return UInt32LE2;
}();
var UInt32BE = /* @__PURE__ */ function() {
  function UInt32BE2() {
  }
  ;
  UInt32BE2.value = new UInt32BE2();
  return UInt32BE2;
}();
var Int8 = /* @__PURE__ */ function() {
  function Int82() {
  }
  ;
  Int82.value = new Int82();
  return Int82;
}();
var Int16LE = /* @__PURE__ */ function() {
  function Int16LE2() {
  }
  ;
  Int16LE2.value = new Int16LE2();
  return Int16LE2;
}();
var Int16BE = /* @__PURE__ */ function() {
  function Int16BE2() {
  }
  ;
  Int16BE2.value = new Int16BE2();
  return Int16BE2;
}();
var Int32LE = /* @__PURE__ */ function() {
  function Int32LE2() {
  }
  ;
  Int32LE2.value = new Int32LE2();
  return Int32LE2;
}();
var Int32BE = /* @__PURE__ */ function() {
  function Int32BE2() {
  }
  ;
  Int32BE2.value = new Int32BE2();
  return Int32BE2;
}();
var FloatLE = /* @__PURE__ */ function() {
  function FloatLE2() {
  }
  ;
  FloatLE2.value = new FloatLE2();
  return FloatLE2;
}();
var FloatBE = /* @__PURE__ */ function() {
  function FloatBE2() {
  }
  ;
  FloatBE2.value = new FloatBE2();
  return FloatBE2;
}();
var DoubleLE = /* @__PURE__ */ function() {
  function DoubleLE2() {
  }
  ;
  DoubleLE2.value = new DoubleLE2();
  return DoubleLE2;
}();
var DoubleBE = /* @__PURE__ */ function() {
  function DoubleBE2() {
  }
  ;
  DoubleBE2.value = new DoubleBE2();
  return DoubleBE2;
}();
var showBufferValueType = {
  show: function(v) {
    if (v instanceof UInt8) {
      return "UInt8";
    }
    ;
    if (v instanceof UInt16LE) {
      return "UInt16LE";
    }
    ;
    if (v instanceof UInt16BE) {
      return "UInt16BE";
    }
    ;
    if (v instanceof UInt32LE) {
      return "UInt32LE";
    }
    ;
    if (v instanceof UInt32BE) {
      return "UInt32BE";
    }
    ;
    if (v instanceof Int8) {
      return "Int8";
    }
    ;
    if (v instanceof Int16LE) {
      return "Int16LE";
    }
    ;
    if (v instanceof Int16BE) {
      return "Int16BE";
    }
    ;
    if (v instanceof Int32LE) {
      return "Int32LE";
    }
    ;
    if (v instanceof Int32BE) {
      return "Int32BE";
    }
    ;
    if (v instanceof FloatLE) {
      return "FloatLE";
    }
    ;
    if (v instanceof FloatBE) {
      return "FloatBE";
    }
    ;
    if (v instanceof DoubleLE) {
      return "DoubleLE";
    }
    ;
    if (v instanceof DoubleBE) {
      return "DoubleBE";
    }
    ;
    throw new Error("Failed pattern match at Node.Buffer.Types (line 33, column 1 - line 47, column 29): " + [v.constructor.name]);
  }
};

// output/Node.Encoding/index.js
var ASCII = /* @__PURE__ */ function() {
  function ASCII2() {
  }
  ;
  ASCII2.value = new ASCII2();
  return ASCII2;
}();
var UTF8 = /* @__PURE__ */ function() {
  function UTF82() {
  }
  ;
  UTF82.value = new UTF82();
  return UTF82;
}();
var UTF16LE = /* @__PURE__ */ function() {
  function UTF16LE2() {
  }
  ;
  UTF16LE2.value = new UTF16LE2();
  return UTF16LE2;
}();
var UCS2 = /* @__PURE__ */ function() {
  function UCS22() {
  }
  ;
  UCS22.value = new UCS22();
  return UCS22;
}();
var Base64 = /* @__PURE__ */ function() {
  function Base642() {
  }
  ;
  Base642.value = new Base642();
  return Base642;
}();
var Base64Url = /* @__PURE__ */ function() {
  function Base64Url2() {
  }
  ;
  Base64Url2.value = new Base64Url2();
  return Base64Url2;
}();
var Latin1 = /* @__PURE__ */ function() {
  function Latin12() {
  }
  ;
  Latin12.value = new Latin12();
  return Latin12;
}();
var Binary = /* @__PURE__ */ function() {
  function Binary2() {
  }
  ;
  Binary2.value = new Binary2();
  return Binary2;
}();
var Hex = /* @__PURE__ */ function() {
  function Hex2() {
  }
  ;
  Hex2.value = new Hex2();
  return Hex2;
}();
var showEncoding = {
  show: function(v) {
    if (v instanceof ASCII) {
      return "ASCII";
    }
    ;
    if (v instanceof UTF8) {
      return "UTF8";
    }
    ;
    if (v instanceof UTF16LE) {
      return "UTF16LE";
    }
    ;
    if (v instanceof UCS2) {
      return "UCS2";
    }
    ;
    if (v instanceof Base64) {
      return "Base64";
    }
    ;
    if (v instanceof Base64Url) {
      return "Base64Url";
    }
    ;
    if (v instanceof Latin1) {
      return "Latin1";
    }
    ;
    if (v instanceof Binary) {
      return "Binary";
    }
    ;
    if (v instanceof Hex) {
      return "Hex";
    }
    ;
    throw new Error("Failed pattern match at Node.Encoding (line 22, column 1 - line 31, column 19): " + [v.constructor.name]);
  }
};
var encodingToNode = function(v) {
  if (v instanceof ASCII) {
    return "ascii";
  }
  ;
  if (v instanceof UTF8) {
    return "utf8";
  }
  ;
  if (v instanceof UTF16LE) {
    return "utf16le";
  }
  ;
  if (v instanceof UCS2) {
    return "ucs2";
  }
  ;
  if (v instanceof Base64) {
    return "base64";
  }
  ;
  if (v instanceof Base64Url) {
    return "base64url";
  }
  ;
  if (v instanceof Latin1) {
    return "latin1";
  }
  ;
  if (v instanceof Binary) {
    return "binary";
  }
  ;
  if (v instanceof Hex) {
    return "hex";
  }
  ;
  throw new Error("Failed pattern match at Node.Encoding (line 35, column 1 - line 35, column 37): " + [v.constructor.name]);
};

// output/Node.Buffer.Immutable/index.js
var show4 = /* @__PURE__ */ show(showBufferValueType);
var toString6 = function(enc) {
  return function(buf) {
    return toStringImpl(encodingToNode(enc), buf);
  };
};
var slice3 = function(start) {
  return function(end2) {
    return function(buf) {
      return sliceImpl2(start, end2, buf);
    };
  };
};
var read3 = function(ty) {
  return function(off) {
    return function(buf) {
      return readImpl(show4(ty), off, buf);
    };
  };
};
var fromString6 = function(str2) {
  return function(enc) {
    return fromStringImpl2(str2, encodingToNode(enc));
  };
};
var concat$prime = function(a) {
  return function(i) {
    return concatToLength(a, i);
  };
};

// output/Node.Buffer/index.js
var pure7 = /* @__PURE__ */ pure(applicativeEffect);
var map18 = /* @__PURE__ */ map(functorEffect);
var unsafeThaw2 = function($7) {
  return pure7($7);
};
var usingToImmutable = function(f) {
  return function(x) {
    return unsafeThaw2(f(x));
  };
};
var unsafeFreeze2 = function($8) {
  return pure7($8);
};
var usingFromImmutable = function(f) {
  return function(buf) {
    return map18(f)(unsafeFreeze2(buf));
  };
};
var toString7 = function(enc) {
  return usingFromImmutable(toString6(enc));
};
var slice4 = slice3;
var size5 = /* @__PURE__ */ usingFromImmutable(size4);
var read4 = function(t) {
  return function(o) {
    return usingFromImmutable(read3(t)(o));
  };
};
var fromString7 = function(s) {
  return usingToImmutable(fromString6(s));
};
var concat$prime2 = function(arrs) {
  return function(n) {
    return function(v) {
      return concat$prime(arrs)(n);
    };
  };
};
var alloc2 = /* @__PURE__ */ usingToImmutable(alloc);
var create = alloc2;

// output/Node.UnsafeChildProcess.Safe/foreign.js
var connectedImpl = (cp) => cp.connected;
var disconnectImpl2 = (cp) => cp.disconnect();
var exitCodeImpl = (cp) => cp.exitCode;
var pidImpl = (cp) => cp.pid;
var killImpl2 = (cp) => cp.kill();
var killStrImpl2 = (cp, str2) => cp.kill(str2);
var killedImpl = (cp) => cp.killed;
var refImpl = (cp) => cp.ref();
var unrefImpl = (cp) => cp.unref();
var signalCodeImpl = (cp) => cp.signalCode;
var spawnArgs = (cp) => cp.spawnArgs;
var spawnFile = (cp) => cp.spawnFile;

// output/Node.UnsafeChildProcess.Safe/index.js
var identity13 = /* @__PURE__ */ identity(categoryFn);
var map19 = /* @__PURE__ */ map(functorEffect);
var show5 = /* @__PURE__ */ show(/* @__PURE__ */ showNullable(showInt));
var unref = function(cp) {
  return function() {
    return unrefImpl(cp);
  };
};
var spawnH = /* @__PURE__ */ function() {
  return new EventHandle("spawn", identity13);
}();
var signalCode = function(cp) {
  return map19(toMaybe)(function() {
    return signalCodeImpl(cp);
  });
};
var ref = function(cp) {
  return function() {
    return refImpl(cp);
  };
};
var pid2 = function(cp) {
  return map19(toMaybe)(function() {
    return pidImpl(cp);
  });
};
var killed = function(cp) {
  return function() {
    return killedImpl(cp);
  };
};
var kill$prime = function(sig) {
  return function(cp) {
    return function() {
      return killStrImpl2(cp, sig);
    };
  };
};
var kill = function(cp) {
  return function() {
    return killImpl2(cp);
  };
};
var exitH = /* @__PURE__ */ function() {
  return new EventHandle("exit", function(cb) {
    return function(code2, signal) {
      var v = toMaybe(signal);
      var v1 = toMaybe(code2);
      if (v1 instanceof Just) {
        return cb(new Normally(v1.value0))();
      }
      ;
      if (v instanceof Just) {
        return cb(new BySignal(v.value0))();
      }
      ;
      return unsafeCrashWith("Impossible. 'exit' event did not get an exit code or kill signal: " + (show5(code2) + ("; " + signal)))();
    };
  });
}();
var exitCode = function(cp) {
  return map19(toMaybe)(function() {
    return exitCodeImpl(cp);
  });
};
var errorH = /* @__PURE__ */ function() {
  return new EventHandle("error", mkEffectFn1);
}();
var disconnect = function(cp) {
  return function() {
    return disconnectImpl2(cp);
  };
};
var connected2 = function(cp) {
  return function() {
    return connectedImpl(cp);
  };
};

// output/Node.UnsafeChildProcess.Unsafe/foreign.js
import {
  exec,
  exec as exec2,
  exec as exec3,
  exec as exec4,
  execFile,
  execFile as execFile2,
  execFile as execFile3,
  execFile as execFile4,
  spawn,
  spawn as spawn2,
  execSync,
  execSync as execSync2,
  execFileSync,
  execFileSync as execFileSync2,
  spawnSync,
  spawnSync as spawnSync2,
  fork,
  fork as fork2
} from "node:child_process";
var unsafeStdin = (cp) => cp.stdin;
var unsafeStdout = (cp) => cp.stdout;
var unsafeStderr = (cp) => cp.stderr;
var unsafeChannelRefImpl = (cp) => cp.channel.ref();
var unsafeChannelUnrefImpl = (cp) => cp.channel.unref();

// output/Node.UnsafeChildProcess.Unsafe/index.js
var unsafeChannelUnref = function(cp) {
  return function() {
    return unsafeChannelUnrefImpl(cp);
  };
};
var unsafeChannelRef = function(cp) {
  return function() {
    return unsafeChannelRefImpl(cp);
  };
};
var spawn$prime = function() {
  return function(command2) {
    return function(args) {
      return function(opts) {
        return function() {
          return spawn2(command2, args, opts);
        };
      };
    };
  };
};

// output/Node.ChildProcess.Aff/index.js
var mempty4 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidEffect(monoidUnit));
var join2 = /* @__PURE__ */ join(bindEffect);
var fromJust8 = /* @__PURE__ */ fromJust();
var parOneOf2 = /* @__PURE__ */ parOneOf(parallelAff)(alternativeParAff)(foldableArray)(functorArray);
var waitSpawned$prime = function(cp) {
  var pidOnSpawn = makeAff(function(done) {
    return function __do3() {
      var ref2 = $$new(mempty4)();
      var removeListener = once(spawnH)(function __do4() {
        join2(read(ref2))();
        var pid$prime = pid2(cp)();
        return done(new Right(new Right(fromJust8(pid$prime))))();
      })(cp)();
      write(removeListener)(ref2)();
      return effectCanceler(removeListener);
    };
  });
  var errored = makeAff(function(done) {
    return function __do3() {
      var ref2 = $$new(mempty4)();
      var removeListener = once(errorH)(function(sysErr) {
        return function __do4() {
          join2(read(ref2))();
          return done(new Right(new Left(sysErr)))();
        };
      })(cp)();
      write(removeListener)(ref2)();
      return effectCanceler(removeListener);
    };
  });
  return parOneOf2([pidOnSpawn, errored]);
};

// output/Node.Errors.SystemError/foreign.js
var getField = (field, err) => err[field];

// output/Node.Errors.SystemError/index.js
var message2 = /* @__PURE__ */ runFn2(getField)("message");
var code = /* @__PURE__ */ runFn2(getField)("code");

// output/Node.Library.Execa.CrossSpawn/foreign.js
import process3 from "process";
var processHasChdir = () => process3.chdir !== void 0;

// output/Node.FS.Constants/foreign.js
import { constants } from "node:fs";
var f_OK = constants.F_OK;
var r_OK = constants.R_OK;
var w_OK = constants.W_OK;
var x_OK = constants.X_OK;
var copyFile_EXCL = constants.COPYFILE_EXCL;
var copyFile_FICLONE = constants.COPYFILE_FICLONE;
var copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;

// output/Node.FS.Constants/index.js
var R = /* @__PURE__ */ function() {
  function R2() {
  }
  ;
  R2.value = new R2();
  return R2;
}();
var R_PLUS = /* @__PURE__ */ function() {
  function R_PLUS2() {
  }
  ;
  R_PLUS2.value = new R_PLUS2();
  return R_PLUS2;
}();
var RS = /* @__PURE__ */ function() {
  function RS2() {
  }
  ;
  RS2.value = new RS2();
  return RS2;
}();
var RS_PLUS = /* @__PURE__ */ function() {
  function RS_PLUS2() {
  }
  ;
  RS_PLUS2.value = new RS_PLUS2();
  return RS_PLUS2;
}();
var W = /* @__PURE__ */ function() {
  function W2() {
  }
  ;
  W2.value = new W2();
  return W2;
}();
var WX = /* @__PURE__ */ function() {
  function WX2() {
  }
  ;
  WX2.value = new WX2();
  return WX2;
}();
var W_PLUS = /* @__PURE__ */ function() {
  function W_PLUS2() {
  }
  ;
  W_PLUS2.value = new W_PLUS2();
  return W_PLUS2;
}();
var WX_PLUS = /* @__PURE__ */ function() {
  function WX_PLUS2() {
  }
  ;
  WX_PLUS2.value = new WX_PLUS2();
  return WX_PLUS2;
}();
var A = /* @__PURE__ */ function() {
  function A2() {
  }
  ;
  A2.value = new A2();
  return A2;
}();
var AX = /* @__PURE__ */ function() {
  function AX2() {
  }
  ;
  AX2.value = new AX2();
  return AX2;
}();
var A_PLUS = /* @__PURE__ */ function() {
  function A_PLUS2() {
  }
  ;
  A_PLUS2.value = new A_PLUS2();
  return A_PLUS2;
}();
var AX_PLUS = /* @__PURE__ */ function() {
  function AX_PLUS2() {
  }
  ;
  AX_PLUS2.value = new AX_PLUS2();
  return AX_PLUS2;
}();
var fileFlagsToNode = function(ff2) {
  if (ff2 instanceof R) {
    return "r";
  }
  ;
  if (ff2 instanceof R_PLUS) {
    return "r+";
  }
  ;
  if (ff2 instanceof RS) {
    return "rs";
  }
  ;
  if (ff2 instanceof RS_PLUS) {
    return "rs+";
  }
  ;
  if (ff2 instanceof W) {
    return "w";
  }
  ;
  if (ff2 instanceof WX) {
    return "wx";
  }
  ;
  if (ff2 instanceof W_PLUS) {
    return "w+";
  }
  ;
  if (ff2 instanceof WX_PLUS) {
    return "wx+";
  }
  ;
  if (ff2 instanceof A) {
    return "a";
  }
  ;
  if (ff2 instanceof AX) {
    return "ax";
  }
  ;
  if (ff2 instanceof A_PLUS) {
    return "a+";
  }
  ;
  if (ff2 instanceof AX_PLUS) {
    return "ax+";
  }
  ;
  throw new Error("Failed pattern match at Node.FS.Constants (line 78, column 22 - line 90, column 19): " + [ff2.constructor.name]);
};

// output/Node.FS.Sync/foreign.js
import {
  accessSync,
  copyFileSync,
  mkdtempSync,
  renameSync,
  truncateSync,
  chownSync,
  chmodSync,
  statSync,
  lstatSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  realpathSync,
  unlinkSync,
  rmdirSync,
  rmSync,
  mkdirSync,
  readdirSync,
  utimesSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  existsSync,
  openSync,
  readSync,
  writeSync,
  fsyncSync,
  closeSync
} from "node:fs";

// output/Node.FS.Perms/index.js
var semiringPerm = {
  add: function(v) {
    return function(v1) {
      return {
        r: v.r || v1.r,
        w: v.w || v1.w,
        x: v.x || v1.x
      };
    };
  },
  zero: {
    r: false,
    w: false,
    x: false
  },
  mul: function(v) {
    return function(v1) {
      return {
        r: v.r && v1.r,
        w: v.w && v1.w,
        x: v.x && v1.x
      };
    };
  },
  one: {
    r: true,
    w: true,
    x: true
  }
};
var permToInt = function(v) {
  return (function() {
    if (v.r) {
      return 4;
    }
    ;
    return 0;
  }() + function() {
    if (v.w) {
      return 2;
    }
    ;
    return 0;
  }() | 0) + function() {
    if (v.x) {
      return 1;
    }
    ;
    return 0;
  }() | 0;
};
var permToString = /* @__PURE__ */ function() {
  var $129 = show(showInt);
  return function($130) {
    return $129(permToInt($130));
  };
}();
var permsToString = function(v) {
  return "0" + (permToString(v.u) + (permToString(v.g) + permToString(v.o)));
};
var none = /* @__PURE__ */ zero(semiringPerm);
var mkPerms = function(u) {
  return function(g) {
    return function(o) {
      return {
        u,
        g,
        o
      };
    };
  };
};
var all4 = /* @__PURE__ */ one(semiringPerm);
var permsReadWrite = /* @__PURE__ */ mkPerms(all4)(all4)(none);

// output/Node.FS.Sync/index.js
var stat = function(file) {
  return function() {
    return statSync(file);
  };
};
var fdRead = function(fd) {
  return function(buff) {
    return function(off) {
      return function(len) {
        return function(pos) {
          return function() {
            return readSync(fd, buff, off, len, toNullable(pos));
          };
        };
      };
    };
  };
};
var fdOpen = function(file) {
  return function(flags) {
    return function(mode2) {
      return function() {
        return openSync(file, fileFlagsToNode(flags), toNullable(mode2));
      };
    };
  };
};
var fdClose = function(fd) {
  return function() {
    return closeSync(fd);
  };
};
var exists = function(file) {
  return function() {
    return existsSync(file);
  };
};

// output/Node.Library.Execa.ShebangCommand/index.js
var bind5 = /* @__PURE__ */ bind(bindMaybe);
var join3 = /* @__PURE__ */ join(bindMaybe);
var voidRight2 = /* @__PURE__ */ voidRight(functorMaybe);
var guard3 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure8 = /* @__PURE__ */ pure(applicativeMaybe);
var intercalate5 = /* @__PURE__ */ intercalate2(monoidString);
var shebangCommand = function(firstLineOfFile) {
  var shebangRegex = unsafeRegex("^#! ?(.*)")(noFlags);
  var extractBinary = function() {
    var $18 = split("/");
    return function($19) {
      return last($18($19));
    };
  }();
  return bind5(match(shebangRegex)(firstLineOfFile))(function(regexMatch) {
    return bind5(join3(index(toArray2(regexMatch))(1)))(function(everythingAfterShebang) {
      var parts = split(" ")(everythingAfterShebang);
      var v = uncons(parts);
      if (v instanceof Just && v.value0.tail.length === 0) {
        return bind5(extractBinary(v.value0.head))(function(binary) {
          return voidRight2(binary)(guard3(binary !== "env"));
        });
      }
      ;
      if (v instanceof Just) {
        return bind5(extractBinary(v.value0.head))(function(binary) {
          return pure8(function() {
            var $14 = binary === "env";
            if ($14) {
              return intercalate5(" ")(v.value0.tail);
            }
            ;
            return intercalate5(" ")(cons(binary)(v.value0.tail));
          }());
        });
      }
      ;
      return Nothing.value;
    });
  });
};

// output/Node.Library.Execa.Utils/foreign.js
var buildCustomErrorImpl = (msg, obj) => Object.assign(new Error(msg), obj);

// output/Node.Library.Execa.Utils/index.js
var eq6 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var findMapWithIndex2 = /* @__PURE__ */ findMapWithIndex(foldableWithIndexObject);
var voidRight3 = /* @__PURE__ */ voidRight(functorMaybe);
var guard4 = /* @__PURE__ */ guard2(alternativeMaybe);
var map20 = /* @__PURE__ */ map(functorEffect);
var voidRight1 = /* @__PURE__ */ voidRight(functorEffect);
var envKey$prime = function(env) {
  return function(key) {
    if (eq6(platform)(new Just(Win32.value))) {
      return findMapWithIndex2(function(k) {
        return function(v) {
          return voidRight3(v)(guard4(toUpper(k) === toUpper(key)));
        };
      })(env);
    }
    ;
    if (otherwise) {
      return lookup4(key)(env);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa.Utils (line 68, column 1 - line 68, column 51): " + [env.constructor.name, key.constructor.name]);
  };
};
var envKey = function(key) {
  return map20(flip(envKey$prime)(key))(getEnv);
};
var buildCustomError = function() {
  return function() {
    return function(msg) {
      return function(info4) {
        return buildCustomErrorImpl(msg, info4);
      };
    };
  };
};
var bracketEffect = function(open2) {
  return function(close2) {
    return function(use) {
      return function __do3() {
        var resource = open2();
        var b = use(resource)();
        return voidRight1(b)(close2(resource))();
      };
    };
  };
};

// output/Node.FS.Async/foreign.js
import {
  access,
  copyFile,
  mkdtemp,
  rename,
  truncate,
  chown,
  chmod,
  stat as stat2,
  lstat,
  link,
  symlink,
  readlink,
  realpath,
  unlink,
  rmdir,
  rm,
  mkdir,
  readdir,
  utimes,
  readFile,
  writeFile,
  appendFile,
  open,
  read as read5,
  write as write3,
  close
} from "node:fs";

// output/Node.FS.Async/index.js
var show6 = /* @__PURE__ */ show(showEncoding);
var handleCallback = function(cb) {
  return function(err, a) {
    var v = toMaybe(err);
    if (v instanceof Nothing) {
      return cb(new Right(a))();
    }
    ;
    if (v instanceof Just) {
      return cb(new Left(v.value0))();
    }
    ;
    throw new Error("Failed pattern match at Node.FS.Async (line 66, column 43 - line 68, column 30): " + [v.constructor.name]);
  };
};
var mkdir$prime = function(file) {
  return function(v) {
    return function(cb) {
      return function() {
        return mkdir(file, {
          recursive: v.recursive,
          mode: permsToString(v.mode)
        }, handleCallback(cb));
      };
    };
  };
};
var readTextFile = function(encoding) {
  return function(file) {
    return function(cb) {
      return function() {
        return readFile(file, {
          encoding: show6(encoding)
        }, handleCallback(cb));
      };
    };
  };
};
var stat3 = function(file) {
  return function(cb) {
    return function() {
      return stat2(file, handleCallback(cb));
    };
  };
};
var unlink2 = function(file) {
  return function(cb) {
    return function() {
      return unlink(file, handleCallback(cb));
    };
  };
};
var writeTextFile = function(encoding) {
  return function(file) {
    return function(buff) {
      return function(cb) {
        return function() {
          return writeFile(file, buff, {
            encoding: show6(encoding)
          }, handleCallback(cb));
        };
      };
    };
  };
};

// output/Node.FS.Stats/foreign.js
var isFileImpl = (s) => s.isFile();
var isSymbolicLinkImpl = (s) => s.isSymbolicLink();
var modeImpl = (s) => s.mode;
var uidImpl = (s) => s.uid;
var gidImpl = (s) => s.gid;
var modifiedTimeImpl = (s) => s.mtime;

// output/Data.JSDate/foreign.js
function toInstantImpl(just) {
  return function(nothing) {
    return function(date2) {
      var t = date2.getTime();
      return isNaN(t) ? nothing : just(t);
    };
  };
}

// output/Foreign/foreign.js
var isArray = Array.isArray || function(value3) {
  return Object.prototype.toString.call(value3) === "[object Array]";
};

// output/Data.JSDate/index.js
var map21 = /* @__PURE__ */ map(functorFn);
var map110 = /* @__PURE__ */ map(functorMaybe);
var toInstant = /* @__PURE__ */ function() {
  return composeKleisliFlipped(bindMaybe)(function($21) {
    return instant(Milliseconds($21));
  })(toInstantImpl(Just.create)(Nothing.value));
}();
var toDateTime2 = /* @__PURE__ */ map21(/* @__PURE__ */ map110(toDateTime))(toInstant);

// output/Node.FS.Stats/index.js
var uid = function(s) {
  return uidImpl(s);
};
var modifiedTime = function(s) {
  var v = toDateTime2(modifiedTimeImpl(s));
  if (v instanceof Just) {
    return v.value0;
  }
  ;
  if (v instanceof Nothing) {
    return unsafeCrashWith("Impossible: `modifiedTime` returned invalid DateTime value.");
  }
  ;
  throw new Error("Failed pattern match at Node.FS.Stats (line 174, column 18 - line 176, column 93): " + [v.constructor.name]);
};
var mode = function(s) {
  return modeImpl(s);
};
var isSymbolicLink = function(s) {
  return isSymbolicLinkImpl(s);
};
var isFile = function(s) {
  return isFileImpl(s);
};
var gid = function(s) {
  return gidImpl(s);
};

// output/Node.Library.Execa.IsExe/index.js
var alt4 = /* @__PURE__ */ alt(altMaybe);
var pure9 = /* @__PURE__ */ pure(applicativeEffect);
var eq7 = /* @__PURE__ */ eq(eqString);
var coerce5 = /* @__PURE__ */ coerce();
var identity14 = /* @__PURE__ */ identity(categoryFn);
var eq17 = /* @__PURE__ */ eq(eqInt);
var getErrorCode = function(e) {
  return e.code;
};
var defaultIsExeOptions = /* @__PURE__ */ function() {
  return {
    pathExt: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    ignoreErrors: false
  };
}();
var coreWindows = /* @__PURE__ */ function() {
  var checkPathExt = function(path2) {
    return function(options) {
      return function __do3() {
        var mbPathExt = envKey("PATHEXT")();
        var v = alt4(options.pathExt)(mbPathExt);
        if (v instanceof Nothing) {
          return true;
        }
        ;
        if (v instanceof Just) {
          var pathLen = length4(path2);
          var pathExt = split(";")(v.value0);
          var pathEndsInExt = isJust(find2(function(p1) {
            var p2 = drop3(pathLen - length4(p1) | 0)(path2);
            return toLower(p1) === toLower(p2);
          })(pathExt));
          var allElemsNonEmpty = isNothing(find2(eq7(""))(pathExt));
          return allElemsNonEmpty || pathEndsInExt;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 106, column 5 - line 120, column 49): " + [v.constructor.name]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(path2) {
      return function(options) {
        var v = function(v1) {
          if (otherwise) {
            return checkPathExt(path2)(options);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 93, column 1 - line 93, column 25): " + [stat6.constructor.name, path2.constructor.name, options.constructor.name]);
        };
        var $36 = !isSymbolicLink(stat6);
        if ($36) {
          var $37 = !isFile(stat6);
          if ($37) {
            return pure9(false);
          }
          ;
          return v(true);
        }
        ;
        return v(true);
      };
    };
  };
  var winIsExe = function(path2) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat3(path2)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var result = checkStat(v.value0)(path2)(options)();
                return cb(new Right(new Tuple(Nothing.value, result)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 124, column 23 - line 128, column 42): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var winIsExeSync = function(path2) {
    return function(options) {
      return function __do3() {
        var statsObj = stat(path2)();
        return checkStat(statsObj)(path2)(options)();
      };
    };
  };
  return {
    isExe: winIsExe,
    isExeSync: winIsExeSync
  };
}();
var coreNonWindows = /* @__PURE__ */ function() {
  var checkMode = function(statsObj) {
    return function(options) {
      var uid2 = floor2(uid(statsObj));
      var mode2 = floor2(mode(statsObj));
      var gid2 = floor2(gid(statsObj));
      return function __do3() {
        var v = coerce5(getUid)();
        var v1 = coerce5(getGid)();
        var truthy = function(x) {
          return x !== 0;
        };
        var myUid = alt4(options.uid)(v);
        var myGid = alt4(options.gid)(v1);
        var ug = 64 | 8;
        return any2(identity14)([truthy(mode2 & 1), truthy(mode2 & 8) && maybe(false)(eq17(gid2))(myGid), truthy(mode2 & 64) && maybe(false)(eq17(uid2))(myUid), truthy(mode2 & ug) && maybe(false)(eq17(0))(myUid)]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(options) {
      return function __do3() {
        var b = checkMode(stat6)(options)();
        return isFile(stat6) && b;
      };
    };
  };
  var nonWinIsExe = function(path2) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat3(path2)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var b = checkStat(v.value0)(options)();
                return cb(new Right(new Tuple(Nothing.value, b)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 142, column 23 - line 146, column 37): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var nonWinIsExeSync = function(path2) {
    return function(options) {
      return function __do3() {
        var stats = stat(path2)();
        return checkStat(stats)(options)();
      };
    };
  };
  return {
    isExe: nonWinIsExe,
    isExeSync: nonWinIsExeSync
  };
}();
var isExeSync = function(path2) {
  return function(options) {
    var core = function() {
      if (platform instanceof Just && platform.value0 instanceof Win32) {
        return coreWindows;
      }
      ;
      return coreNonWindows;
    }();
    return function __do3() {
      var mbEither = $$try(core.isExeSync(path2)(options))();
      var v = function(v1) {
        if (mbEither instanceof Left && otherwise) {
          return pure9(new Left(mbEither.value0));
        }
        ;
        if (mbEither instanceof Right) {
          return pure9(new Right(mbEither.value0));
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 71, column 1 - line 71, column 69): " + [mbEither.constructor.name]);
      };
      if (mbEither instanceof Left) {
        if (options.ignoreErrors) {
          var $59 = getErrorCode(mbEither.value0);
          if ($59 === "EACCESS") {
            return new Right(false);
          }
          ;
          return v(true)();
        }
        ;
        return v(true)();
      }
      ;
      return v(true)();
    };
  };
};

// output/Node.Library.Execa.Which/index.js
var pure10 = /* @__PURE__ */ pure(applicativeEffect);
var eq8 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var eq18 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var alt5 = /* @__PURE__ */ alt(altMaybe);
var buildCustomError2 = /* @__PURE__ */ buildCustomError()();
var tailRecM3 = /* @__PURE__ */ tailRecM(monadRecEffect);
var quotedRegex = /* @__PURE__ */ function() {
  return unsafeRegex('^".*"$')(noFlags);
}();
var isWindows = function __do() {
  var ty = envKey("OSTYPE")();
  return eq8(platform)(new Just(Win32.value)) || (eq18(ty)(new Just("cygwin")) || eq18(ty)(new Just("msys")));
};
var jsColon = function __do2() {
  var w = isWindows();
  if (w) {
    return ";";
  }
  ;
  return ":";
};
var getPathInfo = function(cmd) {
  return function(options) {
    var hasWindowsSlashRegex = unsafeRegex("\\\\")(noFlags);
    var hasPosixSlashRegex = unsafeRegex("\\/")(noFlags);
    return function __do3() {
      var cwd2 = cwd();
      var mbPath = envKey("PATH")();
      var mbPathExt = envKey("PATHEXT")();
      var isWin2 = isWindows();
      var colon = function() {
        if (options.colon instanceof Nothing) {
          return jsColon();
        }
        ;
        if (options.colon instanceof Just) {
          return options.colon.value0;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 77, column 12 - line 79, column 21): " + [options.colon.constructor.name]);
      }();
      var pathExtExe = function() {
        if (isWin2) {
          return fromMaybe(".EXE;.CMD;.BAT;.exe;.cmd;.bat")(alt5(options.pathExt)(mbPathExt));
        }
        ;
        if (otherwise) {
          return "";
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 92, column 5 - line 96, column 23): ");
      }();
      var pathExt = function() {
        if (isWin2) {
          return split(colon)(pathExtExe);
        }
        ;
        if (otherwise) {
          return [""];
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 98, column 5 - line 100, column 27): ");
      }();
      var pathEnv = function() {
        if (test(hasPosixSlashRegex)(cmd) || isWin2 && test(hasWindowsSlashRegex)(cmd)) {
          return [""];
        }
        ;
        if (otherwise) {
          var paths = split(colon)(fromMaybe("")(alt5(options.path)(mbPath)));
          if (isWin2) {
            return cons(cwd2)(paths);
          }
          ;
          return paths;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 84, column 5 - line 90, column 56): ");
      }();
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
  };
};
var getNotFoundError = function(cmd) {
  return buildCustomError2("not found: " + cmd)({
    code: "ENOENT"
  });
};
var dotSlashRegex = /* @__PURE__ */ unsafeRegex("^\\.[\\/]")(noFlags);
var whichSync = function(cmd) {
  return function(options) {
    var go = function(pathEnv) {
      return function(pathExt) {
        return function(pathExtExe) {
          var loop = function(v) {
            if (v.innerLoop instanceof Nothing) {
              var v1 = index(pathEnv)(v.outerLoopIdx);
              if (v1 instanceof Nothing) {
                return pure10(new Done(new Left(getNotFoundError(cmd))));
              }
              ;
              if (v1 instanceof Just) {
                var pathPart = function() {
                  if (test(quotedRegex)(v1.value0)) {
                    return slice2(1)(-1 | 0)(v1.value0);
                  }
                  ;
                  if (otherwise) {
                    return v1.value0;
                  }
                  ;
                  throw new Error("Failed pattern match at Node.Library.Execa.Which (line 163, column 15 - line 165, column 36): ");
                }();
                var pCmd = concat2([pathPart, cmd]);
                var p = function() {
                  var v2 = function(v3) {
                    if (otherwise) {
                      return pCmd;
                    }
                    ;
                    throw new Error("Failed pattern match at Node.Library.Execa.Which (line 148, column 1 - line 148, column 109): ");
                  };
                  var $61 = !$$null2(pathPart);
                  if ($61) {
                    var $62 = test(dotSlashRegex)(cmd);
                    if ($62) {
                      return slice2(0)(2)(cmd) + pCmd;
                    }
                    ;
                    return v2(true);
                  }
                  ;
                  return v2(true);
                }();
                return pure10(new Loop({
                  found: v.found,
                  outerLoopIdx: v.outerLoopIdx,
                  innerLoop: new Just({
                    p,
                    j: 0
                  })
                }));
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 158, column 20 - line 171, column 63): " + [v1.constructor.name]);
            }
            ;
            if (v.innerLoop instanceof Just) {
              var v1 = index(pathExt)(v.innerLoop.value0.j);
              if (v1 instanceof Nothing) {
                return pure10(new Loop({
                  found: v.found,
                  outerLoopIdx: v.outerLoopIdx + 1 | 0,
                  innerLoop: Nothing.value
                }));
              }
              ;
              if (v1 instanceof Just) {
                var cur = v.innerLoop.value0.p + v1.value0;
                return function __do3() {
                  var eOrB = isExeSync(cur)({
                    uid: defaultIsExeOptions.uid,
                    gid: defaultIsExeOptions.gid,
                    ignoreErrors: defaultIsExeOptions.ignoreErrors,
                    pathExt: new Just(pathExtExe)
                  })();
                  if (eOrB instanceof Right) {
                    if (eOrB.value0 && !options.all) {
                      return new Done(new Right(singleton8(cur)));
                    }
                    ;
                    if (eOrB.value0) {
                      return new Loop({
                        outerLoopIdx: v.outerLoopIdx,
                        found: snoc(v.found)(cur),
                        innerLoop: new Just({
                          p: v.innerLoop.value0.p,
                          j: v.innerLoop.value0.j + 1 | 0
                        })
                      });
                    }
                    ;
                  }
                  ;
                  return new Loop({
                    found: v.found,
                    outerLoopIdx: v.outerLoopIdx,
                    innerLoop: new Just({
                      p: v.innerLoop.value0.p,
                      j: v.innerLoop.value0.j + 1 | 0
                    })
                  });
                };
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 174, column 26 - line 187, column 71): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.Which (line 156, column 7 - line 187, column 71): " + [v.innerLoop.constructor.name]);
          };
          return tailRecM3(loop)({
            found: [],
            outerLoopIdx: 0,
            innerLoop: Nothing.value
          });
        };
      };
    };
    return function __do3() {
      var v = getPathInfo(cmd)(options)();
      return go(v.pathEnv)(v.pathExt)(v.pathExtExe)();
    };
  };
};
var defaultWhichOptions = /* @__PURE__ */ function() {
  return {
    path: Nothing.value,
    pathExt: Nothing.value,
    colon: Nothing.value,
    all: false
  };
}();

// output/Node.Library.Execa.CrossSpawn/index.js
var for_2 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var applySecond2 = /* @__PURE__ */ applySecond(applyMaybe);
var guard5 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure11 = /* @__PURE__ */ pure(applicativeEffect);
var map23 = /* @__PURE__ */ map(functorEffect);
var join4 = /* @__PURE__ */ join(bindMaybe);
var $$for2 = /* @__PURE__ */ $$for(applicativeEffect)(traversableMaybe);
var $$void7 = /* @__PURE__ */ $$void(functorEffect);
var append12 = /* @__PURE__ */ append(semigroupArray);
var voidLeft2 = /* @__PURE__ */ voidLeft(functorArray);
var guard1 = /* @__PURE__ */ guard2(alternativeArray);
var intercalate6 = /* @__PURE__ */ intercalate2(monoidString);
var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorArray);
var isWindows2 = /* @__PURE__ */ function() {
  return eq(eqMaybe(eqPlatform))(platform)(new Just(Win32.value));
}();
var parse4 = function(command2) {
  return function(args) {
    return function(options) {
      var wrapInDoubleQuotes = function(s) {
        return '"' + (s + '"');
      };
      var resolveCommand = function(parseRec) {
        var withOptionsCwdIfNeeded = function(optionsCwd) {
          var open2 = function __do3() {
            var cwd2 = cwd();
            var hasChdir = processHasChdir();
            for_2(applySecond2(guard5(hasChdir))(optionsCwd))(function(optionCwd) {
              return chdir(optionCwd);
            })();
            return {
              cwd: cwd2,
              hasChdir
            };
          };
          var close2 = function(v) {
            return for_2(applySecond2(guard5(v.hasChdir))(optionsCwd))(function(v1) {
              return chdir(v.cwd);
            });
          };
          return bracketEffect(open2)(close2);
        };
        return function __do3() {
          var env = function() {
            if (parseRec.options.env instanceof Nothing) {
              return getEnv();
            }
            ;
            if (parseRec.options.env instanceof Just) {
              return parseRec.options.env.value0;
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 147, column 12 - line 149, column 23): " + [parseRec.options.env.constructor.name]);
          }();
          var resolved = withOptionsCwdIfNeeded(parseRec.options.cwd)(function(v) {
            return map23(join4)($$for2(lookup4("Path")(env))(function(envPath) {
              var getFirst = either($$const(Nothing.value))(function($57) {
                return Just.create(head2($57));
              });
              return function __do4() {
                var attempt1 = map23(getFirst)(whichSync(command2)({
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all,
                  path: new Just(envPath),
                  pathExt: new Just(delimiter)
                }))();
                var $40 = isJust(attempt1);
                if ($40) {
                  return attempt1;
                }
                ;
                return map23(getFirst)(whichSync(command2)({
                  pathExt: defaultWhichOptions.pathExt,
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all,
                  path: new Just(envPath)
                }))();
              };
            }));
          })();
          if (parseRec.options.cwd instanceof Just && resolved instanceof Just) {
            return map23(Just.create)(resolve([parseRec.options.cwd.value0])(resolved.value0))();
          }
          ;
          if (parseRec.options.cwd instanceof Nothing && resolved instanceof Just) {
            return map23(Just.create)(resolve([""])(resolved.value0))();
          }
          ;
          return Nothing.value;
        };
      };
      var readShebang = function(cmd) {
        return function __do3() {
          var buf = create(150)();
          $$void7($$try(bracketEffect(fdOpen(cmd)(R.value)(Nothing.value))(fdClose)(function(fd) {
            return fdRead(fd)(buf)(0)(150)(new Just(0));
          })))();
          var firstLine = toString7(UTF8.value)(buf)();
          return shebangCommand(firstLine);
        };
      };
      var metaCharsRegex = unsafeRegex('([()\\][%!^"`<>&|;, *?])')(global2);
      var isExecutableRegex = unsafeRegex("\\.(?:com|exe)$")(ignoreCase);
      var isCommandShimRegex = unsafeRegex("node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$")(ignoreCase);
      var initParseRec = {
        command: command2,
        args,
        options
      };
      var escapeCommand = replace2(metaCharsRegex)("^$1");
      var escapeArgument = function(doubleEscapeMetaChars) {
        var escapeCount = function() {
          if (doubleEscapeMetaChars) {
            return 2;
          }
          ;
          return 1;
        }();
        var endOfStringRegex = unsafeRegex("(\\\\*)$")(noFlags);
        var backSlashSequenceThenDoubleQuoteRegex = unsafeRegex('(\\\\*)"')(global2);
        var $58 = applyN(replace2(metaCharsRegex)("^$1"))(escapeCount);
        var $59 = replace2(endOfStringRegex)("$1$1");
        var $60 = replace2(backSlashSequenceThenDoubleQuoteRegex)('$1$1\\"');
        return function($61) {
          return $58(wrapInDoubleQuotes($59($60($61))));
        };
      };
      var detectShebang = function(parseRec) {
        return function __do3() {
          var mbFile = resolveCommand(parseRec)();
          if (mbFile instanceof Nothing) {
            return new Tuple(parseRec, mbFile);
          }
          ;
          if (mbFile instanceof Just) {
            var mbShebang = readShebang(mbFile.value0)();
            if (mbShebang instanceof Nothing) {
              return new Tuple(parseRec, mbFile);
            }
            ;
            if (mbShebang instanceof Just) {
              var rec1 = {
                options: parseRec.options,
                args: cons(mbFile.value0)(parseRec.args),
                command: mbShebang.value0
              };
              var newCommand = resolveCommand(rec1)();
              return new Tuple(rec1, newCommand);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 134, column 9 - line 143, column 41): " + [mbShebang.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 130, column 5 - line 143, column 41): " + [mbFile.constructor.name]);
        };
      };
      var parseNonShell = function(parseRec) {
        return function __do3() {
          var v = detectShebang(parseRec)();
          var needsShell = function() {
            var $62 = test(isExecutableRegex);
            return function($63) {
              return !$62($63);
            };
          }();
          if (v.value1 instanceof Just && needsShell(v.value1.value0)) {
            var needsDoubleEscapeChars = test(isCommandShimRegex)(v.value1.value0);
            var comSpec = map23(fromMaybe("cmd.exe"))(envKey("COMSPEC"))();
            return {
              args: append12(voidLeft2(guard1(toLower(comSpec) === "cmd.exe" && !parseRec.options.windowsEnableCmdEcho))("/q"))(["/d", "/s", "/c", wrapInDoubleQuotes(intercalate6(" ")(cons(escapeCommand(normalize(v.value0.command)))(mapFlipped3(v.value0.args)(escapeArgument(needsDoubleEscapeChars)))))]),
              command: comSpec,
              options: {
                cwd: v.value0.options.cwd,
                env: v.value0.options.env,
                shell: v.value0.options.shell,
                windowsEnableCmdEcho: v.value0.options.windowsEnableCmdEcho,
                windowsVerbatimArguments: new Just(true)
              }
            };
          }
          ;
          return v.value0;
        };
      };
      var parseWindows = function() {
        if (isJust(options.shell)) {
          return pure11(initParseRec);
        }
        ;
        if (otherwise) {
          return parseNonShell(initParseRec);
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 82, column 3 - line 84, column 45): ");
      }();
      var $56 = !isWindows2;
      if ($56) {
        return pure11(initParseRec);
      }
      ;
      return parseWindows;
    };
  };
};

// output/Node.Stream/foreign.js
import stream from "node:stream";
var readChunkImpl = (useBuffer, useString, chunk) => {
  if (chunk instanceof Buffer) {
    return useBuffer(chunk);
  } else if (typeof chunk === "string") {
    return useString(chunk);
  } else {
    throw new Error(
      "Node.Stream.readChunkImpl: Unrecognised chunk type; expected String or Buffer, got: " + chunk
    );
  }
};
var pipeImpl = (r, w) => r.pipe(w);
var writeImpl = (w, buf) => w.write(buf);
var writeStringImpl = (w, str2, enc) => w.write(str2, enc);
var endImpl = (w) => w.end();
var destroyImpl = (w) => w.destroy();
var pipelineImpl = (src, transforms, dst, cb) => stream.pipeline([src, ...transforms, dst], cb);
var newPassThrough = () => new stream.PassThrough({ objectMode: false });

// output/Node.Stream/index.js
var writeString = function(w) {
  return function(enc) {
    return function(str2) {
      return function() {
        return writeStringImpl(w, str2, encodingToNode(enc));
      };
    };
  };
};
var write4 = function(w) {
  return function(b) {
    return function() {
      return writeImpl(w, b);
    };
  };
};
var pipeline = function(src) {
  return function(transforms) {
    return function(dest) {
      return function(cb) {
        return function() {
          return pipelineImpl(src, transforms, dest, function(err) {
            return cb(toMaybe(err))();
          });
        };
      };
    };
  };
};
var pipe2 = function(r) {
  return function(w) {
    return function() {
      return pipeImpl(r, w);
    };
  };
};
var errorH2 = /* @__PURE__ */ function() {
  return new EventHandle("error", mkEffectFn1);
}();
var end = function(w) {
  return function() {
    return endImpl(w);
  };
};
var destroy = function(w) {
  return function() {
    return destroyImpl(w);
  };
};
var dataH = /* @__PURE__ */ function() {
  return new EventHandle("data", function(cb) {
    return function(chunk) {
      return readChunkImpl(mkEffectFn1(cb), function(v) {
        return $$throw("Got a String, not a Buffer. Stream encoding should not be set")();
      }, chunk);
    };
  });
}();

// output/Node.Library.Execa.GetStream/index.js
var bind12 = /* @__PURE__ */ bind(bindAff);
var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
var when3 = /* @__PURE__ */ when(applicativeEffect);
var show7 = /* @__PURE__ */ show(showNumber);
var getStreamBuffer = function(inputStream) {
  return function(initialOptions) {
    var bufferStream = function __do3() {
      var chunksRef = $$new([])();
      var lengthRef = $$new(0)();
      var stream2 = newPassThrough();
      var rmData = on2(dataH)(function(buf) {
        return function __do4() {
          modify_(function(chunks) {
            return snoc(chunks)(buf);
          })(chunksRef)();
          var bufLen = size5(buf)();
          return modify_(function(v) {
            return v + toNumber(bufLen);
          })(lengthRef)();
        };
      })(stream2)();
      return {
        getBufferedValue: function __do4() {
          var chunks = read(chunksRef)();
          var len = read(lengthRef)();
          return concat$prime2(chunks)(len)();
        },
        getBufferedLength: read(lengthRef),
        stream: stream2,
        unsubcribe: rmData
      };
    };
    var options = {
      maxBuffer: fromMaybe(infinity)(initialOptions.maxBuffer)
    };
    return bind12(liftEffect3(bufferStream))(function($$interface) {
      return makeAff(function(cb) {
        return function __do3() {
          pipeline(inputStream)([])($$interface.stream)(function(err) {
            return function __do4() {
              var bufferedData = $$interface.getBufferedValue();
              return cb(new Right({
                buffer: bufferedData,
                inputError: err
              }))();
            };
          })();
          var rmListener = on2(dataH)(function(v) {
            return function __do4() {
              var bufferedLen = $$interface.getBufferedLength();
              return when3(bufferedLen > options.maxBuffer)(function __do5() {
                var bufferedData = $$interface.getBufferedValue();
                return cb(new Right({
                  buffer: bufferedData,
                  inputError: new Just(error2(maybe("Max buffer exceeded")(function(size6) {
                    return "Max buffer size exceeded. Buffer size was: " + show7(size6);
                  })(initialOptions.maxBuffer)))
                }))();
              })();
            };
          })($$interface.stream)();
          return effectCanceler(function __do4() {
            $$interface.unsubcribe();
            return rmListener();
          });
        };
      });
    });
  };
};

// output/Node.Library.Execa.NpmRunPath/index.js
var intercalate7 = /* @__PURE__ */ intercalate2(monoidString);
var append3 = /* @__PURE__ */ append(semigroupArray);
var foldMap4 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidArray);
var alt6 = /* @__PURE__ */ alt(altMaybe);
var map24 = /* @__PURE__ */ map(functorEffect);
var monoidMaybe2 = /* @__PURE__ */ monoidMaybe(semigroupString);
var npmRunPath = function(initialOptions) {
  var go = function(options) {
    return function(result) {
      return function(previous) {
        return function(cwdPath) {
          if (previous instanceof Just && previous.value0 === cwdPath) {
            return function __do3() {
              var nodeBinaryPath = resolve([cwdPath, options.execPath])("..")();
              return intercalate7(delimiter)(append3(result)(append3([nodeBinaryPath])(foldMap4(singleton2)(options.path))));
            };
          }
          ;
          var nextResult = concat2([cwdPath, "node_modules/.bin"]);
          var nextPrevious = new Just(cwdPath);
          return function __do3() {
            var nextCwdPath = resolve([cwdPath])("..")();
            return go(options)(snoc(result)(nextResult))(nextPrevious)(nextCwdPath)();
          };
        };
      };
    };
  };
  return function __do3() {
    var processCwd = cwd();
    var processPath = envKey("PATH")();
    var processExecPath = execPath();
    var options = {
      cwd: fromMaybe(processCwd)(initialOptions.cwd),
      path: alt6(initialOptions.path)(processPath),
      execPath: fromMaybe(processExecPath)(initialOptions.execPath)
    };
    var cwdPath = resolve([])(options.cwd)();
    return go(options)([])(Nothing.value)(cwdPath)();
  };
};
var npmRunPathEnv = function(env) {
  return function(options) {
    return map24(function(p) {
      return insert2("PATH")(p)(env);
    })(npmRunPath(options));
  };
};
var defaultNpmRunPathOptions = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "cwd";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "execPath";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "path";
  }
})(monoidMaybe2)()(monoidRecordNil)))));

// output/Node.Library.Execa.SignalExit/foreign.js
function unsafeProcessHasProp(prop2) {
  return global.process[prop2] !== null && global.process[prop2] !== void 0;
}
function unsafeReadProcessProp(prop2) {
  return global.process[prop2];
}
function unsafeWriteProcessProp(prop2, value3) {
  global.process[prop2] = value3;
}
function processCallFn(originalProcessReallyExit, exitCode2) {
  return originalProcessReallyExit.call(global.process, exitCode2);
}
function customProcessEmit(cb) {
  return function(ev, arg) {
    const thisArg = this;
    const argumentsArg = arguments;
    return cb((originalProcessEmit) => originalProcessEmit.apply(thisArg, argumentsArg), ev, arg);
  };
}

// output/Node.Library.Execa.SignalExit/index.js
var eq9 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var guard6 = /* @__PURE__ */ guard(monoidArray);
var append4 = /* @__PURE__ */ append(semigroupArray);
var bind6 = /* @__PURE__ */ bind(bindEffect);
var pure12 = /* @__PURE__ */ pure(applicativeEffect);
var $$void8 = /* @__PURE__ */ $$void(functorEffect);
var whenM2 = /* @__PURE__ */ whenM(monadEffect);
var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray);
var unless2 = /* @__PURE__ */ unless(applicativeEffect);
var member3 = /* @__PURE__ */ member2(ordString);
var insert6 = /* @__PURE__ */ insert4(ordString);
var map25 = /* @__PURE__ */ map(functorEffect);
var when4 = /* @__PURE__ */ when(applicativeEffect);
var unlessM2 = /* @__PURE__ */ unlessM(monadEffect);
var $$for3 = /* @__PURE__ */ $$for(applicativeEffect)(traversableArray);
var signalExitProp = "__purescript_signal_exit__";
var processToEventEmitter = unsafeCoerce2;
var isWin = /* @__PURE__ */ function() {
  return eq9(new Just(Win32.value))(platform);
}();
var signals = /* @__PURE__ */ function() {
  var normal = ["SIGHUP", "SIGINT", "SIGTERM"];
  var nonWindows = guard6(!isWin)(["SIGABRT", "SIGALRM", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT", "SIGPROF"]);
  var linux = guard6(eq9(platform)(new Just(Linux.value)))(["SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT"]);
  return append4(normal)(append4(nonWindows)(linux));
}();
var getGlobalRecOnProcessObject = /* @__PURE__ */ function() {
  var attachRefsToProcessObject = function __do3() {
    var v = unsafeReadProcessProp("emit");
    var v1 = unsafeReadProcessProp("reallyExit");
    var restoreOriginalProcessFunctions = function __do4() {
      unsafeWriteProcessProp("emit", v);
      return unsafeWriteProcessProp("reallyExit", v1);
    };
    var emitter = newImpl2();
    setUnlimitedListeners(emitter)();
    var countRef = $$new(0)();
    var emittedEventsRef = $$new(empty6)();
    var loadedRef = $$new(false)();
    var signalListenersRef = $$new([])();
    var obj = {
      originalProcessEmit: v,
      originalProcessReallyExit: v1,
      restoreOriginalProcessFunctions,
      emitter,
      countRef,
      emittedEventsRef,
      loadedRef,
      signalListenersRef
    };
    unsafeWriteProcessProp(signalExitProp, obj);
    return obj;
  };
  return ifM(bindEffect)(function() {
    return unsafeProcessHasProp(signalExitProp);
  })(function() {
    return unsafeReadProcessProp(signalExitProp);
  })(attachRefsToProcessObject);
}();
var exitEvent = "exit";
var exitH2 = /* @__PURE__ */ function() {
  return new EventHandle(exitEvent, function(cb) {
    return function(code2, err) {
      return cb(toMaybe(code2))(toMaybe(err))();
    };
  });
}();
var exitE = function(code2) {
  return function(err) {
    return function(v) {
      return $$void8(function() {
        return unsafeEmitFn(v)(exitEvent, toNullable(code2), toNullable(err));
      });
    };
  };
};
var afterexitEvent = "afterexit";
var afterexitH = /* @__PURE__ */ function() {
  return new EventHandle(afterexitEvent, function(cb) {
    return function(code2, err) {
      return cb(toMaybe(code2))(toMaybe(err))();
    };
  });
}();
var afterexitE = function(code2) {
  return function(err) {
    return function(v) {
      return $$void8(function() {
        return unsafeEmitFn(v)(afterexitEvent, toNullable(code2), toNullable(err));
      });
    };
  };
};
var onExit$prime = function(cb) {
  return function(options) {
    var unload = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return whenM2(read(v.loadedRef))(function __do4() {
        write(false)(v.loadedRef)();
        bind6(read(v.signalListenersRef))(traverse_2(function(v1) {
          if (v1 instanceof Nothing) {
            return pure12(unit);
          }
          ;
          if (v1 instanceof Just) {
            return v1.value0;
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 110, column 49 - line 112, column 40): " + [v1.constructor.name]);
        }))();
        v.restoreOriginalProcessFunctions();
        return modify_(function(v1) {
          return v1 - 1 | 0;
        })(v.countRef)();
      })();
    };
    var processReallyExitFn = function(v) {
      var v1 = getGlobalRecOnProcessObject();
      var exitCode2 = fromMaybe(0)(toMaybe(v));
      unsafeWriteProcessProp(exitEvent, exitCode2);
      exitE(new Just(exitCode2))(Nothing.value)(v1.emitter)();
      afterexitE(new Just(exitCode2))(Nothing.value)(v1.emitter)();
      return processCallFn(v1.originalProcessReallyExit, notNull(exitCode2));
    };
    var emitFn = function(event, code2, signal) {
      var v = getGlobalRecOnProcessObject();
      var eventsAlreadyEmitted = read(v.emittedEventsRef)();
      return unless2(member3(event)(eventsAlreadyEmitted))(function __do3() {
        modify_(insert6(event))(v.emittedEventsRef)();
        return map25(function(v1) {
          return unit;
        })(function() {
          return unsafeEmitFn(v.emitter)(event, code2, signal);
        })();
      })();
    };
    var mkListener = function(sig) {
      return function(countRef) {
        return function __do3() {
          var listenersLen = listenerCount(processToEventEmitter(process2))(sig)();
          var count = read(countRef)();
          return when4(listenersLen === count)(function __do4() {
            unload();
            emitFn(exitEvent, nullImpl, notNull(sig));
            emitFn(afterexitEvent, nullImpl, notNull(sig));
            var sig$prime = function() {
              var $65 = isWin && sig === "SIGHUP";
              if ($65) {
                return "SIGINT";
              }
              ;
              return sig;
            }();
            return killStr(pid)(sig$prime)();
          })();
        };
      };
    };
    var processEmitFn = customProcessEmit(function(runOriginalProcessEmit, ev, arg) {
      var v = getGlobalRecOnProcessObject();
      var $67 = ev === exitEvent;
      if ($67) {
        var exitCode2 = function() {
          var v1 = toMaybe(arg);
          if (v1 instanceof Nothing) {
            return map25(toNullable)(getExitCode)();
          }
          ;
          if (v1 instanceof Just) {
            setExitCode(v1.value0)();
            return notNull(v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 184, column 19 - line 189, column 35): " + [v1.constructor.name]);
        }();
        var ret = runOriginalProcessEmit(v.originalProcessEmit);
        emitFn(exitEvent, exitCode2, nullImpl);
        emitFn(afterexitEvent, exitCode2, nullImpl);
        return ret;
      }
      ;
      return runOriginalProcessEmit(v.originalProcessEmit);
    });
    var load = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return unlessM2(read(v.loadedRef))(function __do4() {
        write(true)(v.loadedRef)();
        modify_(function(v1) {
          return v1 + 1 | 0;
        })(v.countRef)();
        var signalListeners = $$for3(signals)(function(sig) {
          return map25(hush)($$try(function() {
            var listener = mkListener(sig)(v.countRef);
            return function __do5() {
              var rm3 = on2(mkSignalH$prime(sig))(listener)(process2)();
              return $$void8($$try(rm3));
            };
          }()));
        })();
        write(signalListeners)(v.signalListenersRef)();
        unsafeWriteProcessProp("emit", processEmitFn);
        return unsafeWriteProcessProp("reallyExit", processReallyExitFn);
      })();
    };
    return function __do3() {
      var v = getGlobalRecOnProcessObject();
      load();
      var unSubscribe = function() {
        if (options.alwaysLast) {
          return on2(afterexitH)(cb)(v.emitter)();
        }
        ;
        return on2(exitH2)(cb)(v.emitter)();
      }();
      return function __do4() {
        unSubscribe();
        var exitLen = listenerCount(v.emitter)(exitEvent)();
        var afterExitLen = listenerCount(v.emitter)(afterexitEvent)();
        return when4(exitLen === 0 && afterExitLen === 0)(unload)();
      };
    };
  };
};
var onExit = function(cb) {
  return onExit$prime(cb)({
    alwaysLast: false
  });
};

// output/Node.Library.Execa.StripFinalNewline/index.js
var stripFinalNewlineBuf = function(b) {
  var charR = toNumber(toCharCode2("\r"));
  var charN = toNumber(toCharCode2("\n"));
  return function __do3() {
    var len = size5(b)();
    if (len === 0) {
      return b;
    }
    ;
    if (len === 1) {
      var lastChar = read4(UInt8.value)(len - 1 | 0)(b)();
      var $9 = lastChar === charN || lastChar === charR;
      if ($9) {
        return slice4(0)(len - 1 | 0)(b);
      }
      ;
      return b;
    }
    ;
    var lastChar = read4(UInt8.value)(len - 1 | 0)(b)();
    var sndLastChar = read4(UInt8.value)(len - 2 | 0)(b)();
    var $10 = lastChar === charN && sndLastChar === charR;
    if ($10) {
      return slice4(0)(len - 2 | 0)(b);
    }
    ;
    var $11 = lastChar === charN || lastChar === charR;
    if ($11) {
      return slice4(0)(len - 1 | 0)(b);
    }
    ;
    return b;
  };
};

// output/Node.Library.HumanSignals/foreign.js
import { constants as constants2 } from "os";

// output/Node.Library.HumanSignals/index.js
var identity15 = /* @__PURE__ */ identity(categoryFn);
var eq10 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var eq19 = /* @__PURE__ */ eq(eqInt);
var insert7 = /* @__PURE__ */ insert(ordInt);
var alt7 = /* @__PURE__ */ alt(altMaybe);
var Terminate = /* @__PURE__ */ function() {
  function Terminate2() {
  }
  ;
  Terminate2.value = new Terminate2();
  return Terminate2;
}();
var Core = /* @__PURE__ */ function() {
  function Core2() {
  }
  ;
  Core2.value = new Core2();
  return Core2;
}();
var Ignore = /* @__PURE__ */ function() {
  function Ignore2() {
  }
  ;
  Ignore2.value = new Ignore2();
  return Ignore2;
}();
var Pause = /* @__PURE__ */ function() {
  function Pause2() {
  }
  ;
  Pause2.value = new Pause2();
  return Pause2;
}();
var Unpause = /* @__PURE__ */ function() {
  function Unpause2() {
  }
  ;
  Unpause2.value = new Unpause2();
  return Unpause2;
}();
var Ansi = /* @__PURE__ */ function() {
  function Ansi2() {
  }
  ;
  Ansi2.value = new Ansi2();
  return Ansi2;
}();
var Posix = /* @__PURE__ */ function() {
  function Posix2() {
  }
  ;
  Posix2.value = new Posix2();
  return Posix2;
}();
var Bsd = /* @__PURE__ */ function() {
  function Bsd2() {
  }
  ;
  Bsd2.value = new Bsd2();
  return Bsd2;
}();
var Systemv = /* @__PURE__ */ function() {
  function Systemv2() {
  }
  ;
  Systemv2.value = new Systemv2();
  return Systemv2;
}();
var Other = /* @__PURE__ */ function() {
  function Other2() {
  }
  ;
  Other2.value = new Other2();
  return Other2;
}();
var signals2 = /* @__PURE__ */ function() {
  var normalizeSignal = function(v) {
    var mbConstantSignal = lookup4(v.name)(constants2.signals);
    return {
      name: v.name,
      number: fromMaybe(v.number)(mbConstantSignal),
      description: v.description,
      supported: isJust(mbConstantSignal),
      action: v.action,
      standard: v.standard,
      forced: v.forced
    };
  };
  var byName = {
    SIGHUP: normalizeSignal({
      name: "SIGHUP",
      number: 1,
      action: Terminate.value,
      description: "Terminal closed",
      standard: Posix.value,
      forced: false
    }),
    SIGINT: normalizeSignal({
      name: "SIGINT",
      number: 2,
      action: Terminate.value,
      description: "User interruption with CTRL-C",
      standard: Ansi.value,
      forced: false
    }),
    SIGQUIT: normalizeSignal({
      name: "SIGQUIT",
      number: 3,
      action: Core.value,
      description: "User interruption with CTRL-\\",
      standard: Posix.value,
      forced: false
    }),
    SIGILL: normalizeSignal({
      name: "SIGILL",
      number: 4,
      action: Core.value,
      description: "Invalid machine instruction",
      standard: Ansi.value,
      forced: false
    }),
    SIGTRAP: normalizeSignal({
      name: "SIGTRAP",
      number: 5,
      action: Core.value,
      description: "Debugger breakpoint",
      standard: Posix.value,
      forced: false
    }),
    SIGABRT: normalizeSignal({
      name: "SIGABRT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Ansi.value,
      forced: false
    }),
    SIGIOT: normalizeSignal({
      name: "SIGIOT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Bsd.value,
      forced: false
    }),
    SIGBUS: normalizeSignal({
      name: "SIGBUS",
      number: 7,
      action: Core.value,
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: Bsd.value,
      forced: false
    }),
    SIGEMT: normalizeSignal({
      name: "SIGEMT",
      number: 7,
      action: Terminate.value,
      description: "Command should be emulated but is not implemented",
      standard: Other.value,
      forced: false
    }),
    SIGFPE: normalizeSignal({
      name: "SIGFPE",
      number: 8,
      action: Core.value,
      description: "Floating point arithmetic error",
      standard: Ansi.value,
      forced: false
    }),
    SIGKILL: normalizeSignal({
      name: "SIGKILL",
      number: 9,
      action: Terminate.value,
      description: "Forced termination",
      standard: Posix.value,
      forced: true
    }),
    SIGUSR1: normalizeSignal({
      name: "SIGUSR1",
      number: 10,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGSEGV: normalizeSignal({
      name: "SIGSEGV",
      number: 11,
      action: Core.value,
      description: "Segmentation fault",
      standard: Ansi.value,
      forced: false
    }),
    SIGUSR2: normalizeSignal({
      name: "SIGUSR2",
      number: 12,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGPIPE: normalizeSignal({
      name: "SIGPIPE",
      number: 13,
      action: Terminate.value,
      description: "Broken pipe or socket",
      standard: Posix.value,
      forced: false
    }),
    SIGALRM: normalizeSignal({
      name: "SIGALRM",
      number: 14,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Posix.value,
      forced: false
    }),
    SIGTERM: normalizeSignal({
      name: "SIGTERM",
      number: 15,
      action: Terminate.value,
      description: "Termination",
      standard: Ansi.value,
      forced: false
    }),
    SIGSTKFLT: normalizeSignal({
      name: "SIGSTKFLT",
      number: 16,
      action: Terminate.value,
      description: "Stack is empty or overflowed",
      standard: Other.value,
      forced: false
    }),
    SIGCHLD: normalizeSignal({
      name: "SIGCHLD",
      number: 17,
      action: Ignore.value,
      description: "Child process terminated, paused or unpaused",
      standard: Posix.value,
      forced: false
    }),
    SIGCLD: normalizeSignal({
      name: "SIGCLD",
      number: 17,
      action: Ignore.value,
      description: "Child process terminated, paused or unpaused",
      standard: Other.value,
      forced: false
    }),
    SIGCONT: normalizeSignal({
      name: "SIGCONT",
      number: 18,
      action: Unpause.value,
      description: "Unpaused",
      standard: Posix.value,
      forced: true
    }),
    SIGSTOP: normalizeSignal({
      name: "SIGSTOP",
      number: 19,
      action: Pause.value,
      description: "Paused",
      standard: Posix.value,
      forced: true
    }),
    SIGTSTP: normalizeSignal({
      name: "SIGTSTP",
      number: 20,
      action: Pause.value,
      description: 'Paused using CTRL-Z or "suspend"',
      standard: Posix.value,
      forced: false
    }),
    SIGTTIN: normalizeSignal({
      name: "SIGTTIN",
      number: 21,
      action: Pause.value,
      description: "Background process cannot read terminal input",
      standard: Posix.value,
      forced: false
    }),
    SIGBREAK: normalizeSignal({
      name: "SIGBREAK",
      number: 21,
      action: Terminate.value,
      description: "User interruption with CTRL-BREAK",
      standard: Other.value,
      forced: false
    }),
    SIGTTOU: normalizeSignal({
      name: "SIGTTOU",
      number: 22,
      action: Pause.value,
      description: "Background process cannot write to terminal output",
      standard: Posix.value,
      forced: false
    }),
    SIGURG: normalizeSignal({
      name: "SIGURG",
      number: 23,
      action: Ignore.value,
      description: "Socket received out-of-band data",
      standard: Bsd.value,
      forced: false
    }),
    SIGXCPU: normalizeSignal({
      name: "SIGXCPU",
      number: 24,
      action: Core.value,
      description: "Process timed out",
      standard: Bsd.value,
      forced: false
    }),
    SIGXFSZ: normalizeSignal({
      name: "SIGXFSZ",
      number: 25,
      action: Core.value,
      description: "File too big",
      standard: Bsd.value,
      forced: false
    }),
    SIGVTALRM: normalizeSignal({
      name: "SIGVTALRM",
      number: 26,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGPROF: normalizeSignal({
      name: "SIGPROF",
      number: 27,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGWINCH: normalizeSignal({
      name: "SIGWINCH",
      number: 28,
      action: Ignore.value,
      description: "Terminal window size changed",
      standard: Bsd.value,
      forced: false
    }),
    SIGIO: normalizeSignal({
      name: "SIGIO",
      number: 29,
      action: Terminate.value,
      description: "I/O is available",
      standard: Other.value,
      forced: false
    }),
    SIGPOLL: normalizeSignal({
      name: "SIGPOLL",
      number: 29,
      action: Terminate.value,
      description: "Watched event",
      standard: Other.value,
      forced: false
    }),
    SIGINFO: normalizeSignal({
      name: "SIGINFO",
      number: 29,
      action: Ignore.value,
      description: "Request for process information",
      standard: Other.value,
      forced: false
    }),
    SIGPWR: normalizeSignal({
      name: "SIGPWR",
      number: 30,
      action: Terminate.value,
      description: "Device running out of power",
      standard: Systemv.value,
      forced: false
    }),
    SIGSYS: normalizeSignal({
      name: "SIGSYS",
      number: 31,
      action: Core.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGUNUSED: normalizeSignal({
      name: "SIGUNUSED",
      number: 31,
      action: Terminate.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGRT1: normalizeSignal({
      name: "SIGRT1",
      number: 34,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT2: normalizeSignal({
      name: "SIGRT2",
      number: 35,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT3: normalizeSignal({
      name: "SIGRT3",
      number: 36,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT4: normalizeSignal({
      name: "SIGRT4",
      number: 37,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT5: normalizeSignal({
      name: "SIGRT5",
      number: 38,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT6: normalizeSignal({
      name: "SIGRT6",
      number: 39,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT7: normalizeSignal({
      name: "SIGRT7",
      number: 40,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT8: normalizeSignal({
      name: "SIGRT8",
      number: 41,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT9: normalizeSignal({
      name: "SIGRT9",
      number: 42,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT10: normalizeSignal({
      name: "SIGRT10",
      number: 43,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT11: normalizeSignal({
      name: "SIGRT11",
      number: 44,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT12: normalizeSignal({
      name: "SIGRT12",
      number: 45,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT13: normalizeSignal({
      name: "SIGRT13",
      number: 46,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT14: normalizeSignal({
      name: "SIGRT14",
      number: 47,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT15: normalizeSignal({
      name: "SIGRT15",
      number: 48,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT16: normalizeSignal({
      name: "SIGRT16",
      number: 49,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT17: normalizeSignal({
      name: "SIGRT17",
      number: 50,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT18: normalizeSignal({
      name: "SIGRT18",
      number: 51,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT19: normalizeSignal({
      name: "SIGRT19",
      number: 52,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT20: normalizeSignal({
      name: "SIGRT20",
      number: 53,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT21: normalizeSignal({
      name: "SIGRT21",
      number: 54,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT22: normalizeSignal({
      name: "SIGRT22",
      number: 55,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT23: normalizeSignal({
      name: "SIGRT23",
      number: 56,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT24: normalizeSignal({
      name: "SIGRT24",
      number: 57,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT25: normalizeSignal({
      name: "SIGRT25",
      number: 58,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT26: normalizeSignal({
      name: "SIGRT26",
      number: 59,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT27: normalizeSignal({
      name: "SIGRT27",
      number: 60,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT28: normalizeSignal({
      name: "SIGRT28",
      number: 61,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT29: normalizeSignal({
      name: "SIGRT29",
      number: 62,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT30: normalizeSignal({
      name: "SIGRT30",
      number: 63,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT31: normalizeSignal({
      name: "SIGRT31",
      number: 64,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    })
  };
  var byString = fromHomogeneous()(byName);
  var signalsArray = toArrayWithKey(function(v) {
    return identity15;
  })(byString);
  var byNumber = flip(foldl2)(empty4)(function(acc) {
    return function(number2) {
      var byOsConstant = find2(function(v) {
        return eq10(new Just(number2))(lookup4(v.name)(constants2.signals));
      })(signalsArray);
      var byDefinedNumber = find2(function() {
        var $110 = eq19(number2);
        return function($111) {
          return $110(function(v) {
            return v.number;
          }($111));
        };
      }())(signalsArray);
      return maybe(acc)(function(sig) {
        return insert7(number2)(sig)(acc);
      })(alt7(byOsConstant)(byDefinedNumber));
    };
  })(range2(0)(64));
  return {
    byName,
    byNumber,
    byString
  };
}();

// output/Node.Library.Execa/index.js
var append5 = /* @__PURE__ */ append(semigroupArray);
var spawn$prime1 = /* @__PURE__ */ spawn$prime();
var bind7 = /* @__PURE__ */ bind(bindMaybe);
var map26 = /* @__PURE__ */ map(functorMaybe);
var lookup5 = /* @__PURE__ */ lookup3(ordInt);
var append13 = /* @__PURE__ */ append(semigroupString);
var show8 = /* @__PURE__ */ show(showInt);
var show14 = /* @__PURE__ */ show(showString);
var show24 = /* @__PURE__ */ show(showMilliseconds);
var intercalate8 = /* @__PURE__ */ intercalate2(monoidString);
var alt8 = /* @__PURE__ */ alt(altMaybe);
var mapFlipped1 = /* @__PURE__ */ mapFlipped(functorMaybe);
var pure13 = /* @__PURE__ */ pure(applicativeEffect);
var bind13 = /* @__PURE__ */ bind(bindEffect);
var eq11 = /* @__PURE__ */ eq(eqString);
var discard3 = /* @__PURE__ */ discard(discardUnit);
var discard12 = /* @__PURE__ */ discard3(bindMaybe);
var guard7 = /* @__PURE__ */ guard2(alternativeMaybe);
var for_3 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var $$void9 = /* @__PURE__ */ $$void(functorEffect);
var map111 = /* @__PURE__ */ map(functorArray);
var greaterThan2 = /* @__PURE__ */ greaterThan(ordMilliseconds);
var bind22 = /* @__PURE__ */ bind(bindAff);
var liftEffect1 = /* @__PURE__ */ liftEffect(monadEffectAff);
var pure1 = /* @__PURE__ */ pure(applicativeAff);
var sequence_2 = /* @__PURE__ */ sequence_(applicativeEffect)(foldableMaybe);
var discard32 = /* @__PURE__ */ discard3(bindAff);
var when5 = /* @__PURE__ */ when(applicativeEffect);
var mempty5 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidEffect(monoidUnit));
var join5 = /* @__PURE__ */ join(bindEffect);
var void1 = /* @__PURE__ */ $$void(functorAff);
var unless3 = /* @__PURE__ */ unless(applicativeEffect);
var for_1 = /* @__PURE__ */ for_(applicativeAff)(foldableMaybe);
var sequential2 = /* @__PURE__ */ sequential(parallelAff);
var apply3 = /* @__PURE__ */ apply(applyParAff);
var map27 = /* @__PURE__ */ map(functorParAff);
var parallel3 = /* @__PURE__ */ parallel(parallelAff);
var spawn$prime2 = function(cmd) {
  return function(args) {
    return function(buildOpts) {
      var o = buildOpts({
        cwd: Nothing.value,
        env: Nothing.value,
        argv0: Nothing.value,
        stdin: Nothing.value,
        stdout: Nothing.value,
        stderr: Nothing.value,
        ipc: Nothing.value,
        appendStdio: Nothing.value,
        detached: Nothing.value,
        uid: Nothing.value,
        gid: Nothing.value,
        serialization: Nothing.value,
        shell: Nothing.value,
        windowsVerbatimArguments: Nothing.value,
        windowsHide: Nothing.value,
        timeout: Nothing.value,
        killSignal: Nothing.value
      });
      var opts = {
        stdio: append5([fromMaybe(defaultStdIO)(o.stdin), fromMaybe(defaultStdIO)(o.stdout), fromMaybe(defaultStdIO)(o.stderr), function() {
          var $102 = fromMaybe(false)(o.ipc);
          if ($102) {
            return ipc;
          }
          ;
          return defaultStdIO;
        }()])(fromMaybe([])(o.appendStdio)),
        cwd: fromMaybe(undefinedVal)(o.cwd),
        env: fromMaybe(undefinedVal)(o.env),
        argv0: fromMaybe(undefinedVal)(o.argv0),
        detached: fromMaybe(undefinedVal)(o.detached),
        uid: fromMaybe(undefinedVal)(o.uid),
        gid: fromMaybe(undefinedVal)(o.gid),
        serialization: fromMaybe(undefinedVal)(o.serialization),
        shell: fromMaybe(undefinedVal)(o.shell),
        windowsVerbatimArguments: fromMaybe(undefinedVal)(o.windowsVerbatimArguments),
        windowsHide: fromMaybe(undefinedVal)(o.windowsHide),
        timeout: fromMaybe(undefinedVal)(o.timeout),
        killSignal: fromMaybe(undefinedVal)(o.killSignal)
      };
      return spawn$prime1(cmd)(args)(opts);
    };
  };
};
var noEscapeRegex = /* @__PURE__ */ unsafeRegex("^[\\w.-]+$")(noFlags);
var mkExecaResult = function(r) {
  var signalDescription = bind7(r.signal)(function($172) {
    return function(v) {
      if (v instanceof Left) {
        return map26(function(v1) {
          return v1.description;
        })(lookup5(v.value0)(signals2.byNumber));
      }
      ;
      if (v instanceof Right) {
        return map26(function(v1) {
          return v1.description;
        })(lookup4(v.value0)(signals2.byString));
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 887, column 55 - line 889, column 68): " + [v.constructor.name]);
    }(fromKillSignal($172));
  });
  var errorCode = map26(code)(r.spawnError);
  var prefix = function() {
    var v = function(v1) {
      if (r.canceled) {
        return "was canceled";
      }
      ;
      var v2 = function(v3) {
        var v42 = function(v5) {
          var v6 = function(v7) {
            var v8 = function(v9) {
              var v10 = function(v11) {
                var v12 = function(v13) {
                  var v14 = function(v15) {
                    if (otherwise) {
                      return "failed";
                    }
                    ;
                    throw new Error("Failed pattern match at Node.Library.Execa (line 848, column 1 - line 866, column 17): ");
                  };
                  if (r.spawnError instanceof Just) {
                    return "failed to spawn: " + message2(r.spawnError.value0);
                  }
                  ;
                  return v14(true);
                };
                if (r.stderrErr instanceof Just) {
                  return "had error in `stderr`: " + message(r.stderrErr.value0);
                }
                ;
                return v12(true);
              };
              if (r.stdoutErr instanceof Just) {
                return "had error in `stdout`: " + message(r.stdoutErr.value0);
              }
              ;
              return v10(true);
            };
            if (r.stdinErr instanceof Just) {
              return "had error in `stdin`: " + message(r.stdinErr.value0);
            }
            ;
            return v8(true);
          };
          if (r.exitCode instanceof Just) {
            return "failed with exit code " + show8(r.exitCode.value0);
          }
          ;
          return v6(true);
        };
        if (r.signal instanceof Just) {
          if (signalDescription instanceof Just) {
            return "was killed with " + (either(show8)(show14)(fromKillSignal(r.signal.value0)) + (" (" + (signalDescription.value0 + ")")));
          }
          ;
          return v42(true);
        }
        ;
        return v42(true);
      };
      if (errorCode instanceof Just) {
        return "failed with " + errorCode.value0;
      }
      ;
      return v2(true);
    };
    if (r.timedOut) {
      if (r.execaOptions.timeout instanceof Just) {
        return "timed out after " + (show24(r.execaOptions.timeout.value0) + "milliseconds");
      }
      ;
      return v(true);
    }
    ;
    return v(true);
  }();
  var execaMessage = "Command " + (prefix + (": " + r.command));
  var shortMessage = execaMessage + maybe("")(append13("\n"))(map26(message2)(r.spawnError));
  var message3 = intercalate8("\n")([shortMessage, r.stderr, r.stdout]);
  return {
    originalMessage: alt8(mapFlipped1(r.spawnError)(message2))(map26(message)(alt8(r.stdinErr)(alt8(r.stdoutErr)(r.stderrErr)))),
    message: message3,
    shortMessage,
    escapedCommand: r.escapedCommand,
    exit: r.exitStatus,
    exitCode: r.exitCode,
    pid: r.pid,
    signal: r.signal,
    signalDescription,
    stdinError: r.stdinErr,
    stdoutError: r.stdoutErr,
    stderrError: r.stderrErr,
    stdout: r.stdout,
    stderr: r.stderr,
    timedOut: r.timedOut,
    canceled: r.canceled,
    killed: r.killed && !r.timedOut
  };
};
var joinCommand = function(file) {
  return function(args) {
    return file + (" " + intercalate8(" ")(args));
  };
};
var handleOutput = function(options) {
  return function(value3) {
    if (options.stripFinalNewline) {
      return stripFinalNewlineBuf(value3);
    }
    ;
    if (otherwise) {
      return pure13(value3);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 732, column 1 - line 732, column 90): " + [options.constructor.name, value3.constructor.name]);
  };
};
var getEnv2 = function(r) {
  return function __do3() {
    var processEnv = getEnv();
    var env = function() {
      if (r.extendEnv) {
        return union2(r.env)(processEnv);
      }
      ;
      return r.env;
    }();
    if (r.preferLocal instanceof Nothing) {
      return env;
    }
    ;
    if (r.preferLocal instanceof Just) {
      return npmRunPathEnv(env)({
        path: defaultNpmRunPathOptions.path,
        cwd: r.preferLocal.value0.localDir,
        execPath: r.preferLocal.value0.execPath
      })();
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 85, column 3 - line 89, column 107): " + [r.preferLocal.constructor.name]);
  };
};
var execaKill = function(mbKillSignal) {
  return function(forceKillAfterTimeout) {
    return function(cp) {
      var isSigTerm = fromKillSignal$prime(function(i) {
        return maybe(false)(function() {
          var $173 = eq11("SIGTERM");
          return function($174) {
            return $173(toUpper(function(v) {
              return v.name;
            }($174)));
          };
        }())(lookup5(i)(signals2.byNumber));
      })(function(s) {
        return "SIGTERM" === toUpper(s);
      });
      var killSignal2 = fromMaybe(stringSignal("SIGTERM"))(mbKillSignal);
      return function __do3() {
        var killSignalSucceeded = kill$prime(killSignal2)(cp)();
        var mbTimeout = discard12(guard7(isSigTerm(killSignal2)))(function() {
          return discard12(guard7(killSignalSucceeded))(function() {
            return forceKillAfterTimeout;
          });
        });
        for_3(mbTimeout)(function(v) {
          return function __do4() {
            var t = setTimeoutImpl(floor2(v), $$void9(kill$prime(stringSignal("SIGKILL"))(cp)));
            return t.unref();
          };
        })();
        return killSignalSucceeded;
      };
    };
  };
};
var doubleQuotesregex = /* @__PURE__ */ unsafeRegex('"')(global2);
var getEscapedCommand = function(file) {
  return function(args) {
    var escapeArg = function(arg) {
      if (test(noEscapeRegex)(arg)) {
        return arg;
      }
      ;
      if (otherwise) {
        return '"' + (replace2(doubleQuotesregex)('\\"')(arg) + '"');
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 744, column 3 - line 746, column 87): " + [arg.constructor.name]);
    };
    return intercalate8(" ")(map111(escapeArg)(cons(file)(args)));
  };
};
var defaultOptions = /* @__PURE__ */ function() {
  return {
    cleanup: true,
    preferLocal: new Just({
      localDir: Nothing.value,
      execPath: Nothing.value
    }),
    stripFinalNewline: true,
    extendEnv: true,
    maxBuffer: toNumber((1e3 * 1e3 | 0) * 100 | 0),
    encoding: UTF8.value,
    windowsVerbatimArguments: false,
    windowsHide: true,
    windowsEnableCmdEcho: false
  };
}();
var handleArguments = function(file) {
  return function(args) {
    return function(initOptions) {
      return function __do3() {
        var parsed = parse4(file)(args)({
          shell: initOptions.shell,
          env: initOptions.env,
          cwd: initOptions.cwd,
          windowsVerbatimArguments: Nothing.value,
          windowsEnableCmdEcho: fromMaybe(defaultOptions.windowsEnableCmdEcho)(initOptions.windowsEnableCmdEcho)
        })();
        var processCwd = cwd();
        var env = getEnv2({
          env: fromMaybe(empty5)(initOptions.env),
          extendEnv: fromMaybe(defaultOptions.extendEnv)(initOptions.extendEnv),
          preferLocal: initOptions.preferLocal
        })();
        var v = function() {
          if (initOptions.timeout instanceof Just && greaterThan2(initOptions.timeout.value0.milliseconds)(0)) {
            return {
              timeout: new Just(initOptions.timeout.value0.milliseconds),
              killSignal: new Just(initOptions.timeout.value0.killSignal),
              timeoutWithKillSignal: new Just(initOptions.timeout.value0)
            };
          }
          ;
          return {
            timeout: Nothing.value,
            killSignal: Nothing.value,
            timeoutWithKillSignal: Nothing.value
          };
        }();
        var options = {
          cleanup: fromMaybe(defaultOptions.cleanup)(initOptions.cleanup),
          stdin: initOptions.stdin,
          stdout: initOptions.stdout,
          stderr: initOptions.stderr,
          ipc: initOptions.ipc,
          stdioExtra: fromMaybe([])(initOptions.stdioExtra),
          maxBuffer: fromMaybe(defaultOptions.maxBuffer)(initOptions.maxBuffer),
          stripFinalNewline: fromMaybe(defaultOptions.stripFinalNewline)(initOptions.stripFinalNewline),
          cwd: fromMaybe(processCwd)(initOptions.cwd),
          encoding: fromMaybe(defaultOptions.encoding)(initOptions.encoding),
          env,
          argv0: initOptions.argv0,
          detached: fromMaybe(false)(initOptions.detached),
          uid: initOptions.uid,
          gid: initOptions.gid,
          shell: initOptions.shell,
          timeout: v.timeout,
          killSignal: v.killSignal,
          timeoutWithKillSignal: v.timeoutWithKillSignal,
          windowsHide: fromMaybe(defaultOptions.windowsHide)(initOptions.windowsHide),
          windowsVerbatimArguments: fromMaybe(defaultOptions.windowsVerbatimArguments)(parsed.options.windowsVerbatimArguments)
        };
        return {
          file: parsed.command,
          args: parsed.args,
          options,
          parsed
        };
      };
    };
  };
};
var defaultExecaOptions = /* @__PURE__ */ function() {
  return {
    cleanup: Nothing.value,
    preferLocal: Nothing.value,
    stdin: Nothing.value,
    stdout: Nothing.value,
    stderr: Nothing.value,
    ipc: Nothing.value,
    stdioExtra: Nothing.value,
    stripFinalNewline: Nothing.value,
    extendEnv: Nothing.value,
    encoding: Nothing.value,
    cwd: Nothing.value,
    env: Nothing.value,
    argv0: Nothing.value,
    detached: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    shell: Nothing.value,
    timeout: Nothing.value,
    maxBuffer: Nothing.value,
    windowsVerbatimArguments: Nothing.value,
    windowsHide: Nothing.value,
    windowsEnableCmdEcho: Nothing.value
  };
}();
var execa = function(file) {
  return function(args) {
    return function(buildOptions) {
      var options = buildOptions(defaultExecaOptions);
      return bind22(liftEffect1(handleArguments(file)(args)(options)))(function(parsed) {
        var escapedCommand = getEscapedCommand(file)(args);
        var command2 = joinCommand(file)(args);
        return bind22(liftEffect1(spawn$prime2(parsed.file)(parsed.args)(function(v) {
          return {
            timeout: v.timeout,
            killSignal: v.killSignal,
            cwd: new Just(parsed.options.cwd),
            env: new Just(parsed.options.env),
            argv0: options.argv0,
            stdin: parsed.options.stdin,
            stdout: parsed.options.stdout,
            stderr: parsed.options.stdin,
            ipc: parsed.options.ipc,
            appendStdio: new Just(parsed.options.stdioExtra),
            detached: options.detached,
            uid: options.uid,
            gid: options.gid,
            serialization: Nothing.value,
            shell: map26(customShell)(options.shell),
            windowsVerbatimArguments: new Just(parsed.options.windowsVerbatimArguments),
            windowsHide: new Just(parsed.options.windowsHide)
          };
        })))(function(spawned) {
          return bind22(liftEffect1($$new(Nothing.value)))(function(stdinErrRef) {
            return bind22(liftEffect1($$new(false)))(function(canceledRef) {
              return bind22(suspendAff(waitSpawned$prime(spawned)))(function(spawnedFiber) {
                return bind22(function() {
                  var $146 = !parsed.options.cleanup || parsed.options.detached;
                  if ($146) {
                    return pure1(spawnedFiber);
                  }
                  ;
                  return suspendAff(bind22(liftEffect1($$new(Nothing.value)))(function(removeHandlerRef) {
                    return $$finally(liftEffect1(bind13(read(removeHandlerRef))(sequence_2)))(discard32(liftEffect1(function __do3() {
                      var removal = onExit(function(v) {
                        return function(v1) {
                          return $$void9(kill$prime(stringSignal("SIGTERM"))(spawned));
                        };
                      })();
                      return write(new Just(removal))(removeHandlerRef)();
                    }))(function() {
                      return joinFiber(spawnedFiber);
                    }));
                  }));
                }())(function(processSpawnedFiber) {
                  var cancel = liftEffect1(function __do3() {
                    var killSucceeded = kill$prime(stringSignal("SIGTERM"))(spawned)();
                    return when5(killSucceeded)(write(true)(canceledRef))();
                  });
                  var mainFiber = function(postSpawn) {
                    return bind22(joinFiber(processSpawnedFiber))(function(res) {
                      if (res instanceof Left) {
                        return liftEffect1(function() {
                          var gotENOENT = code(res.value0) === "ENOENT";
                          return function __do3() {
                            var unfixedExitCode$prime = exitCode(spawned)();
                            var signalCode$prime = signalCode(spawned)();
                            var exitCode$prime = function() {
                              if (unfixedExitCode$prime instanceof Just && gotENOENT) {
                                return new Just(127);
                              }
                              ;
                              return unfixedExitCode$prime;
                            }();
                            var exitStatus = function() {
                              if (exitCode$prime instanceof Just) {
                                return new Normally(exitCode$prime.value0);
                              }
                              ;
                              if (signalCode$prime instanceof Just) {
                                return new BySignal(stringSignal(signalCode$prime.value0));
                              }
                              ;
                              return unsafeCrashWith("Impossible: either exit or signal should be non-null");
                            }();
                            var canceled = read(canceledRef)();
                            var killed$prime = killed(spawned)();
                            return mkExecaResult({
                              spawnError: new Just(res.value0),
                              pid: Nothing.value,
                              stdinErr: Nothing.value,
                              stdoutErr: Nothing.value,
                              stderrErr: Nothing.value,
                              exitStatus,
                              exitCode: exitCode$prime,
                              signal: map26(stringSignal)(signalCode$prime),
                              stdout: "",
                              stderr: "",
                              command: command2,
                              escapedCommand,
                              execaOptions: parsed.options,
                              timedOut: false,
                              canceled,
                              killed: killed$prime
                            });
                          };
                        }());
                      }
                      ;
                      if (res instanceof Right) {
                        return bind22(liftEffect1($$new(Nothing.value)))(function(timeoutRef) {
                          return bind22(liftEffect1($$new(mempty5)))(function(clearKillOnTimeoutRef) {
                            var clearKillOnTimeout = join5(read(clearKillOnTimeoutRef));
                            return discard32(void1(forkAff(function() {
                              if (parsed.options.timeoutWithKillSignal instanceof Just) {
                                return makeAff(function(cb) {
                                  return function __do3() {
                                    var tid = setTimeout2(parsed.options.timeoutWithKillSignal.value0.milliseconds)(function __do4() {
                                      var killed$prime = killed(spawned)();
                                      unless3(killed$prime)(function __do5() {
                                        $$void9(kill$prime(parsed.options.timeoutWithKillSignal.value0.killSignal)(spawned))();
                                        for_3(toMaybe(unsafeStdin(spawned)))(function($175) {
                                          return $$void9(destroy($175));
                                        })();
                                        for_3(toMaybe(unsafeStdout(spawned)))(function($176) {
                                          return $$void9(destroy($176));
                                        })();
                                        for_3(toMaybe(unsafeStderr(spawned)))(function($177) {
                                          return $$void9(destroy($177));
                                        })();
                                        return write(new Just(parsed.options.timeoutWithKillSignal.value0.killSignal))(timeoutRef)();
                                      })();
                                      return cb(new Right(unit))();
                                    })();
                                    write(clearTimeout2(tid))(clearKillOnTimeoutRef)();
                                    return nonCanceler;
                                  };
                                });
                              }
                              ;
                              return never;
                            }())))(function() {
                              return discard32(for_1(toMaybe(unsafeStdin(spawned)))(function(stdin$prime) {
                                return liftEffect1(once_(errorH2)(function(error5) {
                                  return write(new Just(error5))(stdinErrRef);
                                })(stdin$prime));
                              }))(function() {
                                return discard32(for_1(postSpawn)(function(callback) {
                                  return callback(res.value0);
                                }))(function() {
                                  return bind22(forkAff(makeAff(function(done) {
                                    return function __do3() {
                                      once_(exitH)(function(exitResult) {
                                        return function __do4() {
                                          clearKillOnTimeout();
                                          return done(new Right(exitResult))();
                                        };
                                      })(spawned)();
                                      return nonCanceler;
                                    };
                                  })))(function(v) {
                                    var mkStdIoFiber = function($178) {
                                      return function(v1) {
                                        if (v1 instanceof Nothing) {
                                          return forkAff(pure1({
                                            text: "",
                                            error: Nothing.value
                                          }));
                                        }
                                        ;
                                        if (v1 instanceof Just) {
                                          return forkAff(bind22(getStreamBuffer(v1.value0)({
                                            maxBuffer: new Just(parsed.options.maxBuffer)
                                          }))(function(streamResult) {
                                            return bind22(liftEffect1(function __do3() {
                                              var buf = handleOutput({
                                                stripFinalNewline: parsed.options.stripFinalNewline
                                              })(streamResult.buffer)();
                                              var text2 = toString7(parsed.options.encoding)(buf)();
                                              when5(isJust(streamResult.inputError))(destroy(v1.value0))();
                                              return text2;
                                            }))(function(text2) {
                                              return pure1({
                                                text: text2,
                                                error: streamResult.inputError
                                              });
                                            });
                                          }));
                                        }
                                        ;
                                        throw new Error("Failed pattern match at Node.Library.Execa (line 469, column 40 - line 480, column 62): " + [v1.constructor.name]);
                                      }(toMaybe($178));
                                    };
                                    return bind22(mkStdIoFiber(unsafeStdout(spawned)))(function(stdoutFiber) {
                                      return bind22(mkStdIoFiber(unsafeStderr(spawned)))(function(stderrFiber) {
                                        return bind22(sequential2(apply3(apply3(map27(function(v1) {
                                          return function(v2) {
                                            return function(v3) {
                                              return {
                                                exit: v1,
                                                stdout: v2,
                                                stderr: v3
                                              };
                                            };
                                          };
                                        })(parallel3(joinFiber(v))))(parallel3(joinFiber(stdoutFiber))))(parallel3(joinFiber(stderrFiber)))))(function(result) {
                                          return liftEffect1(function __do3() {
                                            var stdinErr = read(stdinErrRef)();
                                            var canceled = read(canceledRef)();
                                            var killed$prime = killed(spawned)();
                                            var timeout = read(timeoutRef)();
                                            var exitResult = function() {
                                              if (result.exit instanceof Normally) {
                                                return {
                                                  exitCode: new Just(result.exit.value0),
                                                  signal: Nothing.value
                                                };
                                              }
                                              ;
                                              if (result.exit instanceof BySignal) {
                                                return {
                                                  exitCode: Nothing.value,
                                                  signal: new Just(result.exit.value0)
                                                };
                                              }
                                              ;
                                              throw new Error("Failed pattern match at Node.Library.Execa (line 499, column 28 - line 501, column 72): " + [result.exit.constructor.name]);
                                            }();
                                            return mkExecaResult({
                                              spawnError: Nothing.value,
                                              stdinErr,
                                              stdoutErr: result.stdout.error,
                                              stderrErr: result.stderr.error,
                                              exitStatus: result.exit,
                                              exitCode: exitResult.exitCode,
                                              pid: new Just(res.value0),
                                              signal: alt8(exitResult.signal)(timeout),
                                              stdout: result.stdout.text,
                                              stderr: result.stderr.text,
                                              command: command2,
                                              escapedCommand,
                                              execaOptions: parsed.options,
                                              timedOut: isJust(timeout),
                                              canceled,
                                              killed: killed$prime
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      }
                      ;
                      throw new Error("Failed pattern match at Node.Library.Execa (line 386, column 7 - line 519, column 16): " + [res.constructor.name]);
                    });
                  };
                  return pure1({
                    cancel,
                    getResult: mainFiber(Nothing.value),
                    "getResult'": function(cb) {
                      return mainFiber(new Just(cb));
                    },
                    unsafeChannelRef: liftEffect1(unsafeChannelRef(spawned)),
                    unsafeChannelUnref: liftEffect1(unsafeChannelUnref(spawned)),
                    connected: liftEffect1(connected2(spawned)),
                    disconnect: liftEffect1(disconnect(spawned)),
                    kill: liftEffect1(kill(spawned)),
                    killWithSignal: function(signal) {
                      return liftEffect1(kill$prime(signal)(spawned));
                    },
                    killForced: function(forceKillAfterTimeout) {
                      return liftEffect1(execaKill(new Just(stringSignal("SIGTERM")))(new Just(forceKillAfterTimeout))(spawned));
                    },
                    killForcedWithSignal: function(signal) {
                      return function(forceKillAfterTimeout) {
                        return liftEffect1(execaKill(new Just(signal))(new Just(forceKillAfterTimeout))(spawned));
                      };
                    },
                    killed: liftEffect1(killed(spawned)),
                    unref: liftEffect1(unref(spawned)),
                    ref: liftEffect1(ref(spawned)),
                    spawnArgs: spawnArgs(spawned),
                    spawnFile: spawnFile(spawned),
                    childProcess: spawned,
                    stdin: mapFlipped1(toMaybe(unsafeStdin(spawned)))(function(stdin$prime) {
                      return {
                        stream: stdin$prime,
                        writeUtf8: function(string4) {
                          return liftEffect1(function __do3() {
                            var buf = fromString7(string4)(UTF8.value)();
                            return $$void9(write4(stdin$prime)(buf))();
                          });
                        },
                        writeUtf8End: function(string4) {
                          return liftEffect1(function __do3() {
                            var buf = fromString7(string4)(UTF8.value)();
                            $$void9(write4(stdin$prime)(buf))();
                            return $$void9(end(stdin$prime))();
                          });
                        },
                        end: liftEffect1($$void9(end(stdin$prime)))
                      };
                    }),
                    stdout: mapFlipped1(toMaybe(unsafeStdout(spawned)))(function(stdout$prime) {
                      return {
                        stream: stdout$prime,
                        pipeToParentStdout: liftEffect1($$void9(pipe2(stdout$prime)(stdout)))
                      };
                    }),
                    stderr: mapFlipped1(toMaybe(unsafeStderr(spawned)))(function(stderr$prime) {
                      return {
                        stream: stderr$prime,
                        pipeToParentStderr: liftEffect1($$void9(pipe2(stderr$prime)(stderr)))
                      };
                    }),
                    waitSpawned: bind22(liftEffect1(pid2(spawned)))(function(mbPid) {
                      if (mbPid instanceof Just) {
                        return pure1(new Right(mbPid.value0));
                      }
                      ;
                      if (mbPid instanceof Nothing) {
                        return waitSpawned$prime(spawned);
                      }
                      ;
                      throw new Error("Failed pattern match at Node.Library.Execa (line 565, column 9 - line 567, column 42): " + [mbPid.constructor.name]);
                    })
                  });
                });
              });
            });
          });
        });
      });
    };
  };
};

// output/Effect.Now/foreign.js
function now2() {
  return Date.now();
}

// output/Effect.Now/index.js
var map28 = /* @__PURE__ */ map(functorEffect);
var nowDateTime = /* @__PURE__ */ map28(toDateTime)(now2);

// output/Whine.Log/index.js
var fold5 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var LogDebug = /* @__PURE__ */ function() {
  function LogDebug2() {
  }
  ;
  LogDebug2.value = new LogDebug2();
  return LogDebug2;
}();
var LogInfo = /* @__PURE__ */ function() {
  function LogInfo2() {
  }
  ;
  LogInfo2.value = new LogInfo2();
  return LogInfo2;
}();
var LogWarning = /* @__PURE__ */ function() {
  function LogWarning2() {
  }
  ;
  LogWarning2.value = new LogWarning2();
  return LogWarning2;
}();
var LogError = /* @__PURE__ */ function() {
  function LogError2() {
  }
  ;
  LogError2.value = new LogError2();
  return LogError2;
}();
var loggableString = {
  toDoc: /* @__PURE__ */ identity(categoryFn)
};
var loggableError = {
  toDoc: message
};
var loggableDecodeError = {
  toDoc: print3
};
var eqLogSeverity = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LogDebug && y instanceof LogDebug) {
        return true;
      }
      ;
      if (x instanceof LogInfo && y instanceof LogInfo) {
        return true;
      }
      ;
      if (x instanceof LogWarning && y instanceof LogWarning) {
        return true;
      }
      ;
      if (x instanceof LogError && y instanceof LogError) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordLogSeverity = {
  compare: function(x) {
    return function(y) {
      if (x instanceof LogDebug && y instanceof LogDebug) {
        return EQ.value;
      }
      ;
      if (x instanceof LogDebug) {
        return LT.value;
      }
      ;
      if (y instanceof LogDebug) {
        return GT.value;
      }
      ;
      if (x instanceof LogInfo && y instanceof LogInfo) {
        return EQ.value;
      }
      ;
      if (x instanceof LogInfo) {
        return LT.value;
      }
      ;
      if (y instanceof LogInfo) {
        return GT.value;
      }
      ;
      if (x instanceof LogWarning && y instanceof LogWarning) {
        return EQ.value;
      }
      ;
      if (x instanceof LogWarning) {
        return LT.value;
      }
      ;
      if (y instanceof LogWarning) {
        return GT.value;
      }
      ;
      if (x instanceof LogError && y instanceof LogError) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Whine.Log (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqLogSeverity;
  }
};
var greaterThanOrEq2 = /* @__PURE__ */ greaterThanOrEq(ordLogSeverity);
var toDoc = function(dict) {
  return dict.toDoc;
};
var log4 = function(dict) {
  return dict.log;
};
var logDebug = function(dictMonadLog) {
  var log1 = log4(dictMonadLog);
  return function(dictLoggable) {
    return log1(dictLoggable)(LogDebug.value);
  };
};
var logError = function(dictMonadLog) {
  var log1 = log4(dictMonadLog);
  return function(dictLoggable) {
    return log1(dictLoggable)(LogError.value);
  };
};
var logInfo = function(dictMonadLog) {
  var log1 = log4(dictMonadLog);
  return function(dictLoggable) {
    return log1(dictLoggable)(LogInfo.value);
  };
};
var formatDebugTime = /* @__PURE__ */ function() {
  return format(fromFoldable6(foldableArray)([Hours24.value, new Placeholder(":"), MinutesTwoDigits.value, new Placeholder(":"), SecondsTwoDigits.value, new Placeholder("."), Milliseconds2.value]));
}();
var logDefault = function(dictMonadEffect) {
  var info4 = info2(dictMonadEffect);
  var warn3 = warn2(dictMonadEffect);
  var error5 = error4(dictMonadEffect);
  var Monad0 = dictMonadEffect.Monad0();
  var bind30 = bind(Monad0.Bind1());
  var liftEffect7 = liftEffect(dictMonadEffect);
  var debug3 = debug2(dictMonadEffect);
  var when9 = when(Monad0.Applicative0());
  return function(dictLoggable) {
    var toDoc1 = toDoc(dictLoggable);
    return function(v) {
      return function(message3) {
        var printFn = function() {
          if (v.severity instanceof LogInfo) {
            return info4;
          }
          ;
          if (v.severity instanceof LogWarning) {
            return warn3;
          }
          ;
          if (v.severity instanceof LogError) {
            return error5;
          }
          ;
          if (v.severity instanceof LogDebug) {
            return function(s) {
              return bind30(liftEffect7(nowDateTime))(function(now3) {
                return debug3(fold5(["[", formatDebugTime(now3), "]: ", s]));
              });
            };
          }
          ;
          throw new Error("Failed pattern match at Whine.Log (line 37, column 15 - line 46, column 66): " + [v.severity.constructor.name]);
        }();
        return when9(greaterThanOrEq2(v.severity)(v.level))(printFn(toDoc1(message3)));
      };
    };
  };
};

// output/Control.Monad.Reader/index.js
var unwrap6 = /* @__PURE__ */ unwrap();
var runReader = function(v) {
  return function($4) {
    return unwrap6(v($4));
  };
};

// output/WhineM/index.js
var monadWriterT2 = /* @__PURE__ */ monadWriterT(monoidArray);
var monadErrorWriterT2 = /* @__PURE__ */ monadErrorWriterT(monoidArray);
var monadEffectWriter2 = /* @__PURE__ */ monadEffectWriter(monoidArray);
var monadAskWriterT2 = /* @__PURE__ */ monadAskWriterT(monoidArray);
var bindWriterT2 = /* @__PURE__ */ bindWriterT(semigroupArray);
var coerce6 = /* @__PURE__ */ coerce();
var applicativeWriterT2 = /* @__PURE__ */ applicativeWriterT(monoidArray);
var monadWhineM = function(dictMonad) {
  return monadWriterT2(monadReaderT(dictMonad));
};
var monadErrorWhineM = function(dictMonadError) {
  return monadErrorWriterT2(monadErrorReaderT(dictMonadError));
};
var monadEffectWhineM = function(dictMonadEffect) {
  return monadEffectWriter2(monadEffectReader(dictMonadEffect));
};
var monadAskWhineM = function(dictMonad) {
  return monadAskWriterT2(monadAskReaderT(dictMonad));
};
var monadAffWhineM = function(dictMonadAff) {
  return monadAffWriter(monadAffReader(dictMonadAff))(monoidArray);
};
var functorWhineM = function(dictFunctor) {
  return functorWriterT(functorReaderT(dictFunctor));
};
var bindWhineM = function(dictBind) {
  return bindWriterT2(bindReaderT(dictBind));
};
var monadLogWhineM = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var Bind1 = Monad0.Bind1();
  var bind30 = bind(bindWhineM(Bind1));
  var mapFlipped7 = mapFlipped(functorWhineM(Bind1.Apply0().Functor0()));
  var ask2 = ask(monadAskWhineM(Monad0));
  var logDefault2 = logDefault(monadEffectWhineM(dictMonadEffect));
  return function(dictTypeEquals) {
    return {
      log: function(dictLoggable) {
        var logDefault1 = logDefault2(dictLoggable);
        return function(severity) {
          return function(message3) {
            return bind30(mapFlipped7(mapFlipped7(ask2)(coerce6))(function(v) {
              return v.logLevel;
            }))(function(level) {
              return logDefault1({
                level,
                severity
              })(message3);
            });
          };
        };
      }
    };
  };
};
var applicativeWhineM = function(dictApplicative) {
  return applicativeWriterT2(applicativeReaderT(dictApplicative));
};
var runWhineM = function(dictMonadEffect) {
  return function(env) {
    return function(v) {
      return runReaderT(runWriterT(v))(env);
    };
  };
};

// output/Whine.Runner.Prelude/index.js
var bindWhineM2 = /* @__PURE__ */ bindWhineM(bindAff);
var discard4 = /* @__PURE__ */ discard(discardUnit)(bindWhineM2);
var logError2 = /* @__PURE__ */ logError(/* @__PURE__ */ monadLogWhineM(monadEffectAff)(refl));
var pure14 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeWhineM(applicativeAff));
var exit2 = /* @__PURE__ */ function() {
  var $19 = liftEffect(monadEffectWhineM(monadEffectAff));
  return function($20) {
    return $19(exit$prime($20));
  };
}();
var die = function(dictLoggable) {
  var logError1 = logError2(dictLoggable);
  return function(message3) {
    return discard4(logError1(message3))(function() {
      return exit2(1);
    });
  };
};
var rightOrDie = function(dictLoggable) {
  return either(die(dictLoggable))(pure14);
};
var tryOrDie = /* @__PURE__ */ composeKleisli(bindWhineM2)(/* @__PURE__ */ $$try2(/* @__PURE__ */ monadErrorWhineM(monadErrorAff)))(/* @__PURE__ */ rightOrDie(loggableError));

// output/Whine.Bootstrap.Execa/index.js
var bindWhineM3 = /* @__PURE__ */ bindWhineM(bindAff);
var bind8 = /* @__PURE__ */ bind(bindWhineM3);
var liftAff2 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffWhineM(monadAffAff));
var $$try4 = /* @__PURE__ */ $$try2(monadErrorAff);
var discard5 = /* @__PURE__ */ discard(discardUnit)(bindWhineM3);
var logDebug2 = /* @__PURE__ */ logDebug(/* @__PURE__ */ monadLogWhineM(monadEffectAff)(refl));
var logDebug1 = /* @__PURE__ */ logDebug2(loggableError);
var die2 = /* @__PURE__ */ die(loggableString);
var applicativeWhineM2 = /* @__PURE__ */ applicativeWhineM(applicativeAff);
var pure15 = /* @__PURE__ */ pure(applicativeWhineM2);
var when6 = /* @__PURE__ */ when(applicativeWhineM2);
var notEq3 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqMaybe(eqInt));
var logDebug22 = /* @__PURE__ */ logDebug2(loggableString);
var $$void10 = /* @__PURE__ */ $$void(/* @__PURE__ */ functorWhineM(functorAff));
var execa2 = function(cmd) {
  return function(args) {
    return function(opts) {
      return bind8(liftAff2($$try4(execa(cmd)(args)(opts))))(function(res) {
        if (res instanceof Left) {
          return discard5(logDebug1(res.value0))(function() {
            return die2("Error running '" + (cmd + "'"));
          });
        }
        ;
        if (res instanceof Right) {
          return pure15(res.value0);
        }
        ;
        throw new Error("Failed pattern match at Whine.Bootstrap.Execa (line 11, column 3 - line 16, column 13): " + [res.constructor.name]);
      });
    };
  };
};
var execResultSuccessOrDie = function(cmd) {
  return function(res) {
    return when6(notEq3(res.exitCode)(new Just(0)))(discard5(logDebug22("STDOUT:\n" + (res.stdout + "\n\n")))(function() {
      return discard5(logDebug22("STDERR:\n" + (res.stderr + "\n\n")))(function() {
        return die2("Error running '" + (cmd + "'"));
      });
    }));
  };
};
var execSuccessOrDie = function(cmd) {
  return function(proc) {
    return bind8(liftAff2(proc.getResult))(function(res) {
      return discard5(execResultSuccessOrDie(cmd)(res))(function() {
        return pure15(res);
      });
    });
  };
};
var execSuccessOrDie_ = function(cmd) {
  return function(res) {
    return $$void10(execSuccessOrDie(cmd)(res));
  };
};

// output/Whine.Bootstrap.Hash/foreign.js
import crypto from "crypto";
var hashString = (str2) => {
  const h = crypto.createHash("sha256");
  h.update(str2);
  return h.digest("hex");
};

// output/Whine.Bootstrap.ScriptDir/foreign.js
var getScriptDir = () => __dirname;

// output/Whine.Runner.PackageVersion/index.js
var bind9 = /* @__PURE__ */ bind(bindParserT);
var discard6 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var $$void11 = /* @__PURE__ */ $$void(functorParserT);
var pure16 = /* @__PURE__ */ pure(applicativeParserT);
var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);
var fold6 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var show9 = /* @__PURE__ */ show(showInt);
var ExactVersion = /* @__PURE__ */ function() {
  function ExactVersion2(value0) {
    this.value0 = value0;
  }
  ;
  ExactVersion2.create = function(value0) {
    return new ExactVersion2(value0);
  };
  return ExactVersion2;
}();
var VersionRange = /* @__PURE__ */ function() {
  function VersionRange2(value0) {
    this.value0 = value0;
  }
  ;
  VersionRange2.create = function(value0) {
    return new VersionRange2(value0);
  };
  return VersionRange2;
}();
var versionToRange = function(v) {
  if (v instanceof ExactVersion) {
    return {
      from: v.value0,
      to: {
        major: v.value0.major,
        minor: v.value0.minor,
        patch: v.value0.patch + 1 | 0
      }
    };
  }
  ;
  if (v instanceof VersionRange) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Whine.Runner.PackageVersion (line 27, column 18 - line 29, column 22): " + [v.constructor.name]);
};
var versionParser = /* @__PURE__ */ function() {
  var versionNumber = bind9(intDecimal)(function(major) {
    return discard6($$void11($$char2(".")))(function() {
      return bind9(intDecimal)(function(minor) {
        return discard6($$void11($$char2(".")))(function() {
          return bind9(intDecimal)(function(patch) {
            var $23 = major < 0 || (minor < 0 || patch < 0);
            if ($23) {
              return fail2("");
            }
            ;
            return pure16({
              major,
              minor,
              patch
            });
          });
        });
      });
    });
  });
  var range3 = discard6($$void11(string2(">=")))(function() {
    return bind9(versionNumber)(function(from3) {
      return discard6($$void11(string2("<")))(function() {
        return bind9(versionNumber)(function(to2) {
          return pure16(new VersionRange({
            from: from3,
            to: to2
          }));
        });
      });
    });
  });
  var exact = map(functorParserT)(ExactVersion.create)(versionNumber);
  return alt(altParserT)(exact)(range3);
}();
var parseVersion = function(v) {
  return lmap2($$const("Malformed package version"))(runParser(v)(versionParser));
};
var formatVersionNumber = function(v) {
  return fold6([show9(v.major), ".", show9(v.minor), ".", show9(v.patch)]);
};
var formatVersionRange = function(v) {
  return ">=" + (formatVersionNumber(v.from) + (" <" + formatVersionNumber(v.to)));
};
var formatVersion = function(v) {
  if (v instanceof ExactVersion) {
    return formatVersionNumber(v.value0);
  }
  ;
  if (v instanceof VersionRange) {
    return formatVersionRange(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Whine.Runner.PackageVersion (line 16, column 17 - line 18, column 41): " + [v.constructor.name]);
};

// output/Whine.Runner.Yaml/foreign.js
var import_yaml = __toESM(require_dist(), 1);
var parseYaml_ = (left, right, text2) => {
  try {
    return right(import_yaml.default.parse(text2));
  } catch (error5) {
    return left(error5.message);
  }
};
var stringify = import_yaml.default.stringify;

// output/Whine.Runner.Yaml/index.js
var parseYaml = /* @__PURE__ */ function() {
  return runFn3(parseYaml_)(Left.create)(Right.create);
}();

// output/Whine.Runner.Config/index.js
var bind14 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
var toUnfoldable8 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var pure17 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
var throwError4 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadIdentity));
var alt9 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var JustPackage = /* @__PURE__ */ function() {
  function JustPackage2() {
  }
  ;
  JustPackage2.value = new JustPackage2();
  return JustPackage2;
}();
var PackageVersion = /* @__PURE__ */ function() {
  function PackageVersion2(value0) {
    this.value0 = value0;
  }
  ;
  PackageVersion2.create = function(value0) {
    return new PackageVersion2(value0);
  };
  return PackageVersion2;
}();
var LocalPackage = /* @__PURE__ */ function() {
  function LocalPackage2(value0) {
    this.value0 = value0;
  }
  ;
  LocalPackage2.create = function(value0) {
    return new LocalPackage2(value0);
  };
  return LocalPackage2;
}();
var packagesCodec = /* @__PURE__ */ function() {
  var localPackageCodec = strMap(objectStrict(recordPropOptional2({
    reflectSymbol: function() {
      return "module";
    }
  })()(string)(recordProp2({
    reflectSymbol: function() {
      return "local";
    }
  })()(string)(record2))));
  var packageCodec = function() {
    var enc = function(v) {
      if (v.value1 instanceof JustPackage) {
        return encode(string)(v["value0"]["package"]);
      }
      ;
      if (v.value1 instanceof PackageVersion) {
        return encode(strMap(string))(singleton7(v["value0"]["package"])(formatVersion(v.value1.value0)));
      }
      ;
      if (v.value1 instanceof LocalPackage) {
        return encode(localPackageCodec)(singleton7(v["value0"]["package"])({
          local: v.value1.value0.path,
          module: v.value1.value0.module
        }));
      }
      ;
      throw new Error("Failed pattern match at Whine.Runner.Config (line 159, column 9 - line 159, column 74): " + [v.constructor.name]);
    };
    var dec = function(json2) {
      var withVersion = bind14(decode(strMap(string))(json2))(function(m) {
        var v = toUnfoldable8(m);
        if (v.length === 1) {
          var v1 = parseVersion(v[0].value1);
          if (v1 instanceof Right) {
            return pure17(new Tuple({
              "package": v[0].value0
            }, new PackageVersion(v1.value0)));
          }
          ;
          if (v1 instanceof Left) {
            return throwError4(basic(v1.value0));
          }
          ;
          throw new Error("Failed pattern match at Whine.Runner.Config (line 173, column 19 - line 175, column 67): " + [v1.constructor.name]);
        }
        ;
        return throwError4(basic("Malformed package specification"));
      });
      var localPackage = bind14(decode(localPackageCodec)(json2))(function(m) {
        var v = toUnfoldable8(m);
        if (v.length === 1) {
          return pure17(new Tuple({
            "package": v[0].value0
          }, new LocalPackage({
            path: v[0].value1.local,
            module: v[0].value1.module
          })));
        }
        ;
        return throwError4(basic("Malformed package specification"));
      });
      var justPackage = bind14(decode(string)(json2))(function($$package) {
        return pure17(new Tuple({
          "package": $$package
        }, JustPackage.value));
      });
      return alt9(justPackage)(alt9(withVersion)(localPackage));
    };
    return codec$prime(dec)(enc);
  }();
  return dimap(profunctorCodec(functorExceptT(functorIdentity)))(toUnfoldable8)(fromFoldable4(ordRecord()(ordRecordCons(ordRecordNil)()({
    reflectSymbol: function() {
      return "package";
    }
  })(ordString)))(foldableArray))(array(packageCodec));
}();
var configCodec = /* @__PURE__ */ objectStrict(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "rules";
  }
})()(/* @__PURE__ */ strMap(json))(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "exclude";
  }
})()(/* @__PURE__ */ array(nonEmptyString))(/* @__PURE__ */ recordPropOptional2({
  reflectSymbol: function() {
    return "include";
  }
})()(/* @__PURE__ */ array(nonEmptyString))(/* @__PURE__ */ recordProp2({
  reflectSymbol: function() {
    return "rulePackages";
  }
})()(packagesCodec)(record2)))));

// output/Node.FS.Aff/index.js
var voidLeft3 = /* @__PURE__ */ voidLeft(functorEffect);
var toAff = function(p) {
  return makeAff(function(k) {
    return voidLeft3(p(k))(nonCanceler);
  });
};
var toAff1 = function(f) {
  return function(a) {
    return toAff(f(a));
  };
};
var unlink3 = /* @__PURE__ */ toAff1(unlink2);
var toAff2 = function(f) {
  return function(a) {
    return function(b) {
      return toAff(f(a)(b));
    };
  };
};
var toAff3 = function(f) {
  return function(a) {
    return function(b) {
      return function(c) {
        return toAff(f(a)(b)(c));
      };
    };
  };
};
var writeTextFile2 = /* @__PURE__ */ toAff3(writeTextFile);
var stat4 = /* @__PURE__ */ toAff1(stat3);
var readTextFile3 = /* @__PURE__ */ toAff2(readTextFile);
var mkdir$prime2 = /* @__PURE__ */ toAff2(mkdir$prime);

// output/Whine.Runner.FS/index.js
var liftAff3 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffWhineM(monadAffAff));
var bind10 = /* @__PURE__ */ bind(/* @__PURE__ */ bindWhineM(bindAff));
var pure18 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeWhineM(applicativeAff));
var liftEffect4 = /* @__PURE__ */ liftEffect(/* @__PURE__ */ monadEffectWhineM(monadEffectAff));
var writeFile3 = function(path2) {
  return function(text2) {
    return tryOrDie(liftAff3(writeTextFile2(UTF8.value)(path2)(text2)));
  };
};
var unlink4 = function(path2) {
  return tryOrDie(liftAff3(unlink3(path2)));
};
var stat5 = function(path2) {
  return bind10(liftAff3(stat4(path2)))(function(stats) {
    return pure18({
      modifiedTime: modifiedTime(stats)
    });
  });
};
var readFile3 = function(path2) {
  return tryOrDie(liftAff3(readTextFile3(UTF8.value)(path2)));
};
var mkDirP = function(path2) {
  return tryOrDie(liftAff3(mkdir$prime2(path2)({
    recursive: true,
    mode: permsReadWrite
  })));
};
var exists2 = function(path2) {
  return liftEffect4(exists(path2));
};

// output/Whine.Bootstrap.Cache/index.js
var fromJust9 = /* @__PURE__ */ fromJust();
var object3 = /* @__PURE__ */ object2();
var rowListCodecConsCodec2 = /* @__PURE__ */ rowListCodecConsCodec(rowListCodecNilRowRow)()();
var packageIsSymbol = {
  reflectSymbol: function() {
    return "package";
  }
};
var fold7 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorArray);
var toUnfoldable9 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var bindWhineM4 = /* @__PURE__ */ bindWhineM(bindAff);
var bind11 = /* @__PURE__ */ bind(bindWhineM4);
var liftEffect5 = /* @__PURE__ */ liftEffect(/* @__PURE__ */ monadEffectWhineM(monadEffectAff));
var discard7 = /* @__PURE__ */ discard(discardUnit);
var discard13 = /* @__PURE__ */ discard7(bindWhineM4);
var monadLogWhineM2 = /* @__PURE__ */ monadLogWhineM(monadEffectAff)(refl);
var logDebug3 = /* @__PURE__ */ logDebug(monadLogWhineM2)(loggableString);
var applicativeWhineM3 = /* @__PURE__ */ applicativeWhineM(applicativeAff);
var pure19 = /* @__PURE__ */ pure(applicativeWhineM3);
var liftAff4 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffWhineM(monadAffAff));
var unless4 = /* @__PURE__ */ unless(applicativeWhineM3);
var eq20 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindWhineM4);
var asks2 = /* @__PURE__ */ asks(/* @__PURE__ */ monadAskWhineM(monadAff));
var eq110 = /* @__PURE__ */ eq(eqLogSeverity);
var logInfo2 = /* @__PURE__ */ logInfo(monadLogWhineM2)(loggableString);
var map29 = /* @__PURE__ */ map(functorEffect);
var map112 = /* @__PURE__ */ map(functorFn);
var ordRecord2 = /* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(ordRecordNil)()(packageIsSymbol)(ordString));
var union4 = /* @__PURE__ */ union(ordRecord2);
var fromFoldable15 = /* @__PURE__ */ fromFoldable4(ordString)(foldableArray);
var bind15 = /* @__PURE__ */ bind(bindArray);
var when7 = /* @__PURE__ */ when(applicativeWhineM3);
var any4 = /* @__PURE__ */ any(foldableMap)(heytingAlgebraBoolean);
var whenM3 = /* @__PURE__ */ whenM(/* @__PURE__ */ monadWhineM(monadAff));
var rightOrDie2 = /* @__PURE__ */ rightOrDie(loggableDecodeError);
var bind23 = /* @__PURE__ */ bind(bindEither);
var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);
var discard23 = /* @__PURE__ */ discard7(bindArray);
var guard8 = /* @__PURE__ */ guard2(alternativeArray);
var pure110 = /* @__PURE__ */ pure(applicativeArray);
var lookup6 = /* @__PURE__ */ lookup3(ordString);
var alt10 = /* @__PURE__ */ alt(altMaybe);
var elem3 = /* @__PURE__ */ elem2(eqString);
var rightOrDie1 = /* @__PURE__ */ rightOrDie(loggableString);
var ifM2 = /* @__PURE__ */ ifM(bindWhineM4);
var functorWhineM2 = /* @__PURE__ */ functorWhineM(functorAff);
var map210 = /* @__PURE__ */ map(functorWhineM2);
var $$for4 = /* @__PURE__ */ $$for(applicativeWhineM3)(traversableArray);
var mapFlipped12 = /* @__PURE__ */ mapFlipped(functorWhineM2);
var maximumBy2 = /* @__PURE__ */ maximumBy(foldableArray);
var comparing2 = /* @__PURE__ */ comparing(ordDateTime);
var lessThan2 = /* @__PURE__ */ lessThan(ordDateTime);
var map33 = /* @__PURE__ */ map(functorMaybe);
var not4 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var traverse3 = /* @__PURE__ */ traverse(traversableMaybe)(applicativeWhineM3);
var eq24 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqBoolean));
var member4 = /* @__PURE__ */ member(ordRecord2);
var whineCorePackage = /* @__PURE__ */ function() {
  var version2 = fromJust9(hush(parseVersion(packages["whine-core"])));
  return new Tuple({
    "package": "whine-core"
  }, new PackageVersion(version2));
}();
var spagoYamlCodec = /* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec(/* @__PURE__ */ rowListCodecConsCodec2({
  reflectSymbol: function() {
    return "workspace";
  }
}))()()(packageIsSymbol))({
  "package": /* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec(/* @__PURE__ */ rowListCodecConsCodec(/* @__PURE__ */ rowListCodecConsCodec2({
    reflectSymbol: function() {
      return "name";
    }
  }))()()({
    reflectSymbol: function() {
      return "dependencies";
    }
  }))()()({
    reflectSymbol: function() {
      return "bundle";
    }
  }))({
    name: string,
    dependencies: /* @__PURE__ */ array(/* @__PURE__ */ strMap(string)),
    bundle: /* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec(/* @__PURE__ */ rowListCodecConsCodec(/* @__PURE__ */ rowListCodecConsCodec2({
      reflectSymbol: function() {
        return "platform";
      }
    }))()()({
      reflectSymbol: function() {
        return "outfile";
      }
    }))()()({
      reflectSymbol: function() {
        return "module";
      }
    }))({
      module: string,
      platform: string,
      outfile: string
    })
  }),
  workspace: /* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec2({
    reflectSymbol: function() {
      return "extraPackages";
    }
  }))({
    extraPackages: /* @__PURE__ */ strMap(/* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec2({
      reflectSymbol: function() {
        return "path";
      }
    }))({
      path: string
    }))
  })
});
var sourceMapCodec = /* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec2({
  reflectSymbol: function() {
    return "sources";
  }
}))({
  sources: /* @__PURE__ */ array(string)
});
var moduleGraphCodec = /* @__PURE__ */ strMap(/* @__PURE__ */ object3(/* @__PURE__ */ rowListCodecConsCodec2(packageIsSymbol))({
  "package": string
}));
var hashConfig = function(v) {
  var printPackageSpec = function(v1) {
    if (v1 instanceof JustPackage) {
      return "*";
    }
    ;
    if (v1 instanceof PackageVersion) {
      return formatVersion(v1.value0);
    }
    ;
    if (v1 instanceof LocalPackage) {
      return v1.value0.path + (":" + fromMaybe("")(v1.value0.module));
    }
    ;
    throw new Error("Failed pattern match at Whine.Bootstrap.Cache (line 296, column 24 - line 299, column 63): " + [v1.constructor.name]);
  };
  return hashString(fold7([packages["whine-core"], joinWith("\n")(mapFlipped4(toUnfoldable9(v.rulePackages))(function(v1) {
    return v1["value0"]["package"] + (":" + printPackageSpec(v1.value1));
  }))]));
};
var getPreBundledWhineCoreCache = /* @__PURE__ */ bind11(/* @__PURE__ */ liftEffect5(getScriptDir))(function(scriptDir) {
  var bundlePath = scriptDir + "/whine-core-bundle.mjs";
  return bind11(exists2(bundlePath))(function(bundleExists) {
    if (bundleExists) {
      return discard13(logDebug3("Found pre-bundled whine-core at " + bundlePath))(function() {
        return pure19(new Just({
          executable: bundlePath,
          dependencies: Nothing.value,
          dirty: false,
          rebuild: pure19(unit)
        }));
      });
    }
    ;
    return pure19(Nothing.value);
  });
});
var formatTime = /* @__PURE__ */ function() {
  return format(fromFoldable6(foldableArray)([YearFull.value, new Placeholder("-"), MonthTwoDigits.value, new Placeholder("-"), DayOfMonthTwoDigits.value, new Placeholder("T"), Hours24.value, new Placeholder(":"), MinutesTwoDigits.value, new Placeholder(":"), SecondsTwoDigits.value, new Placeholder("."), Milliseconds2.value]));
}();
var cachedBundleMainModule = function(v) {
  var ruleModuleImports = mapFlipped4(v.ruleModules)(function(modul) {
    return "import " + (modul + (" as " + modul));
  });
  var ruleModuleAccess = mapFlipped4(v.ruleModules)(function(modul) {
    return modul + ".rules :: RuleFactories";
  });
  return joinWith("\n")(["module " + (v.moduleName + " where"), "import Whine.Prelude", "import Whine.Types (class MonadRules, RuleFactories)", "import Whine.Runner (runWhineAndPrintResultsAndExit)", joinWith("\n")(ruleModuleImports), "main :: Effect Unit", "main = runWhineAndPrintResultsAndExit $ fold", "  [ " + joinWith("\n  ,")(ruleModuleAccess), "  ]"]);
};
var cacheDir = ".whine";
var rebuildCache = function(v) {
  var spagoGraphModules = bind11(execa2("npx")(["spago", "graph", "modules", "--json"])(function(v1) {
    return {
      cleanup: v1.cleanup,
      preferLocal: v1.preferLocal,
      stripFinalNewline: v1.stripFinalNewline,
      extendEnv: v1.extendEnv,
      env: v1.env,
      encoding: v1.encoding,
      argv0: v1.argv0,
      stdin: v1.stdin,
      ipc: v1.ipc,
      stdioExtra: v1.stdioExtra,
      detached: v1.detached,
      uid: v1.uid,
      gid: v1.gid,
      shell: v1.shell,
      timeout: v1.timeout,
      maxBuffer: v1.maxBuffer,
      windowsVerbatimArguments: v1.windowsVerbatimArguments,
      windowsHide: v1.windowsHide,
      windowsEnableCmdEcho: v1.windowsEnableCmdEcho,
      cwd: new Just(cacheDir),
      stdout: new Just(pipe),
      stderr: new Just(pipe)
    };
  }))(function(proc) {
    return bind11(liftAff4(proc.getResult))(function(res) {
      return discard13(unless4(eq20(res.exitCode)(new Just(0)))(discard13(logDebug3("'spago graph modules' failed. Trying to build to see what the error was..."))(function() {
        return discard13(writeFile3(cacheDir + "/src/Main.purs")("module M where\nx = 42 :: Int"))(function() {
          return discard13(bindFlipped4(execSuccessOrDie_("spago build"))(execa2("npx")(["spago", "build"])(function(v1) {
            return {
              cleanup: v1.cleanup,
              preferLocal: v1.preferLocal,
              stripFinalNewline: v1.stripFinalNewline,
              extendEnv: v1.extendEnv,
              env: v1.env,
              encoding: v1.encoding,
              argv0: v1.argv0,
              stdin: v1.stdin,
              ipc: v1.ipc,
              stdioExtra: v1.stdioExtra,
              detached: v1.detached,
              uid: v1.uid,
              gid: v1.gid,
              shell: v1.shell,
              timeout: v1.timeout,
              maxBuffer: v1.maxBuffer,
              windowsVerbatimArguments: v1.windowsVerbatimArguments,
              windowsHide: v1.windowsHide,
              windowsEnableCmdEcho: v1.windowsEnableCmdEcho,
              cwd: new Just(cacheDir),
              stdout: new Just(pipe),
              stderr: new Just(pipe)
            };
          })))(function() {
            return discard13(logDebug3("Building succeeded, but 'spago graph modules' still failed."))(function() {
              return execResultSuccessOrDie("spago graph modules")(res);
            });
          });
        });
      })))(function() {
        return pure19(res.stdout);
      });
    });
  });
  var logSameLine = function(msg) {
    return bind11(asks2(function(v1) {
      return v1.logLevel;
    }))(function(logLevel) {
      var prefix = function() {
        var $165 = eq110(logLevel)(LogDebug.value);
        if ($165) {
          return "";
        }
        ;
        return "\x1B[1A\x1B[K";
      }();
      return logInfo2(prefix + msg);
    });
  };
  var isLocalPackage = function(v1) {
    if (v1 instanceof LocalPackage) {
      return true;
    }
    ;
    return false;
  };
  return discard13(logInfo2("Please hold on, preparing to whine..."))(function() {
    return discard13(logInfo2("Applying artificial tears..."))(function() {
      return bind11(liftEffect5(map29(map112(replaceAll("-")(""))(toString5))(genUUID)))(function(unique) {
        var mainModule = "Main" + unique;
        var dependencies = union4(v.rulePackages)(uncurry(singleton7)(whineCorePackage));
        return discard13(mkDirP(cacheDir + "/src"))(function() {
          return discard13(writeFile3(cacheDir + "/package.json")("{}"))(function() {
            return discard13(writeFile3(cacheDir + "/spago.yaml")(stringify(encode2(spagoYamlCodec)({
              "package": {
                name: "whine-cached-bootstrap",
                dependencies: mapFlipped4(toUnfoldable9(dependencies))(function(v1) {
                  return singleton7(v1["value0"]["package"])(function() {
                    if (v1.value1 instanceof JustPackage) {
                      return "*";
                    }
                    ;
                    if (v1.value1 instanceof PackageVersion) {
                      return formatVersionRange(versionToRange(v1.value1.value0));
                    }
                    ;
                    if (v1.value1 instanceof LocalPackage) {
                      return "*";
                    }
                    ;
                    throw new Error("Failed pattern match at Whine.Bootstrap.Cache (line 152, column 35 - line 155, column 36): " + [v1.value1.constructor.name]);
                  }());
                }),
                bundle: {
                  module: mainModule,
                  platform: "node",
                  outfile: v.bundleFile
                }
              },
              workspace: {
                extraPackages: fromFoldable15(bind15(toUnfoldable9(v.rulePackages))(function(v1) {
                  if (v1.value1 instanceof LocalPackage) {
                    return [new Tuple(v1["value0"]["package"], {
                      path: relative(cacheDir)(v1.value1.value0.path)
                    })];
                  }
                  ;
                  return [];
                }))
              }
            }))))(function() {
              return discard13(when7(any4(isLocalPackage)(v.rulePackages))(whenM3(exists2(cacheDir + "/spago.lock"))(tryOrDie(unlink4(cacheDir + "/spago.lock")))))(function() {
                return discard13(logSameLine("Coming up with excuses..."))(function() {
                  return discard13(logDebug3("Wrote workspace files"))(function() {
                    return discard13(bindFlipped4(execSuccessOrDie_("npm install"))(execa2("npm")(["install", "spago@" + spagoVersion, "purescript@" + pursVersion, "micromatch", "glob", "vscode-languageserver", "vscode-languageserver-textdocument"])(function(v1) {
                      return {
                        cleanup: v1.cleanup,
                        preferLocal: v1.preferLocal,
                        stripFinalNewline: v1.stripFinalNewline,
                        extendEnv: v1.extendEnv,
                        env: v1.env,
                        encoding: v1.encoding,
                        argv0: v1.argv0,
                        stdin: v1.stdin,
                        ipc: v1.ipc,
                        stdioExtra: v1.stdioExtra,
                        detached: v1.detached,
                        uid: v1.uid,
                        gid: v1.gid,
                        shell: v1.shell,
                        timeout: v1.timeout,
                        maxBuffer: v1.maxBuffer,
                        windowsVerbatimArguments: v1.windowsVerbatimArguments,
                        windowsHide: v1.windowsHide,
                        windowsEnableCmdEcho: v1.windowsEnableCmdEcho,
                        cwd: new Just(cacheDir),
                        stdout: new Just(pipe),
                        stderr: new Just(pipe)
                      };
                    })))(function() {
                      return discard13(logSameLine("Making a pitiful face..."))(function() {
                        return discard13(logDebug3("Installed NPM dependencies"))(function() {
                          return bind11(spagoGraphModules)(function(moduleGraphJson) {
                            return bind11(rightOrDie2(bind23(lmap3(basic)(parse(moduleGraphJson)))(decode2(moduleGraphCodec))))(function(moduleGraph) {
                              return discard13(logDebug3("Obtained dependency module graph"))(function() {
                                var candidateModules = fromFoldable15(bind15(toUnfoldable9(moduleGraph))(function(v1) {
                                  return discard23(guard8(isJust(stripSuffix(".WhineRules")(v1.value0))))(function() {
                                    return pure110(new Tuple(v1["value1"]["package"], v1.value0));
                                  });
                                }));
                                var ruleModules = catMaybes(bind15(toUnfoldable9(v.rulePackages))(function(v1) {
                                  var specifiedModule = function() {
                                    if (v1.value1 instanceof LocalPackage) {
                                      return v1.value1.value0.module;
                                    }
                                    ;
                                    return Nothing.value;
                                  }();
                                  var inferredModule = lookup6(v1["value0"]["package"])(candidateModules);
                                  return pure110(alt10(specifiedModule)(inferredModule));
                                }));
                                return discard13(writeFile3(cacheDir + "/src/Main.purs")(cachedBundleMainModule({
                                  moduleName: mainModule,
                                  ruleModules
                                })))(function() {
                                  return discard13(logSameLine("Revisiting complaints..."))(function() {
                                    return discard13(logDebug3("Wrote executable entry point"))(function() {
                                      return discard13(bindFlipped4(execSuccessOrDie_("spago bundle"))(execa2("npx")(["spago", "bundle", "--source-maps"])(function(v1) {
                                        return {
                                          cleanup: v1.cleanup,
                                          preferLocal: v1.preferLocal,
                                          stripFinalNewline: v1.stripFinalNewline,
                                          extendEnv: v1.extendEnv,
                                          env: v1.env,
                                          encoding: v1.encoding,
                                          argv0: v1.argv0,
                                          stdin: v1.stdin,
                                          ipc: v1.ipc,
                                          stdioExtra: v1.stdioExtra,
                                          detached: v1.detached,
                                          uid: v1.uid,
                                          gid: v1.gid,
                                          shell: v1.shell,
                                          timeout: v1.timeout,
                                          maxBuffer: v1.maxBuffer,
                                          windowsVerbatimArguments: v1.windowsVerbatimArguments,
                                          windowsHide: v1.windowsHide,
                                          windowsEnableCmdEcho: v1.windowsEnableCmdEcho,
                                          cwd: new Just(cacheDir),
                                          stdout: new Just(pipe),
                                          stderr: new Just(pipe)
                                        };
                                      })))(function() {
                                        return discard13(logSameLine("Done, ready to whine."))(function() {
                                          return discard13(logDebug3("Bundled the executable"))(function() {
                                            return logInfo2("");
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};
var buildRuntimeCache = function(v) {
  var ignoreDependencies = ["node_modules", "<stdin>", ".spago"];
  var ignoredDependency = function(file) {
    return maybe(false)(function(v1) {
      return elem3(v1)(ignoreDependencies);
    })(head(split(sep)(file)));
  };
  var decodeSourceMapFile = function(content) {
    return rightOrDie1(bind23(parse(content))(function(json2) {
      return lmap3(print3)(decode2(sourceMapCodec)(json2));
    }));
  };
  var configHash = hashConfig({
    rulePackages: v.rulePackages
  });
  var bundleFile = "bundle-" + (configHash + ".mjs");
  var bundlePath = cacheDir + ("/" + bundleFile);
  var sourceMapFilePath = bundlePath + ".map";
  var readSourceMapFile = ifM2(exists2(sourceMapFilePath))(map210(Just.create)(bindFlipped4(decodeSourceMapFile)(readFile3(sourceMapFilePath))))(pure19(Nothing.value));
  var anyDependenciesNewerThanBundle = function(deps) {
    return bind11(stat5(bundlePath))(function(v1) {
      return bind11(map210(catMaybes)($$for4(deps)(function(d) {
        return ifM2(exists2(d))(pure19(new Just(d)))(pure19(Nothing.value));
      })))(function(existingDeps) {
        return bind11($$for4(existingDeps)(function(d) {
          return mapFlipped12(mapFlipped12(stat5(d))(function(v2) {
            return v2.modifiedTime;
          }))(function(v2) {
            return new Tuple(v2, d);
          });
        }))(function(depStats) {
          var mLatestDep = maximumBy2(comparing2(fst))(depStats);
          return discard13(logDebug3(fold7([bundlePath, " last modified at ", formatTime(v1.modifiedTime), ", latest dependency ", maybe("<none>")(snd)(mLatestDep), " time is ", maybe("<none>")(function($208) {
            return formatTime(fst($208));
          })(mLatestDep)])))(function() {
            return pure19(maybe(true)(function(v2) {
              return lessThan2(v1.modifiedTime)(v2.value0);
            })(mLatestDep));
          });
        });
      });
    });
  };
  return bind11(mapFlipped12(readSourceMapFile)(map33(function(v1) {
    return mapFlipped4(filter(not4(ignoredDependency))(v1.sources))(function(s) {
      return cacheDir + ("/" + s);
    });
  })))(function(dependencies) {
    return bind11(exists2(bundlePath))(function(bundleExists) {
      return bind11(function() {
        if (bundleExists) {
          return traverse3(anyDependenciesNewerThanBundle)(dependencies);
        }
        ;
        return pure19(Nothing.value);
      }())(function(newerDeps) {
        return pure19({
          executable: bundlePath,
          dependencies,
          dirty: !bundleExists || eq24(newerDeps)(new Just(true)),
          rebuild: rebuildCache({
            rulePackages: v.rulePackages,
            bundleFile
          })
        });
      });
    });
  });
};
var getCache = function(v) {
  var isOnlyWhineCore = size(v.rulePackages) === 1 && member4({
    "package": "whine-core"
  })(v.rulePackages);
  if (isOnlyWhineCore) {
    return bind11(getPreBundledWhineCoreCache)(function(mPreBundled) {
      if (mPreBundled instanceof Just) {
        return pure19(mPreBundled.value0);
      }
      ;
      if (mPreBundled instanceof Nothing) {
        return buildRuntimeCache({
          rulePackages: v.rulePackages
        });
      }
      ;
      throw new Error("Failed pattern match at Whine.Bootstrap.Cache (line 71, column 7 - line 73, column 54): " + [mPreBundled.constructor.name]);
    });
  }
  ;
  return buildRuntimeCache({
    rulePackages: v.rulePackages
  });
};

// output/ExitCodes/index.js
var Success = /* @__PURE__ */ function() {
  function Success3() {
  }
  ;
  Success3.value = new Success3();
  return Success3;
}();
var $$Error = /* @__PURE__ */ function() {
  function $$Error2() {
  }
  ;
  $$Error2.value = new $$Error2();
  return $$Error2;
}();
var MisuseOfShellBuiltins = /* @__PURE__ */ function() {
  function MisuseOfShellBuiltins2() {
  }
  ;
  MisuseOfShellBuiltins2.value = new MisuseOfShellBuiltins2();
  return MisuseOfShellBuiltins2;
}();
var CLIUsageError = /* @__PURE__ */ function() {
  function CLIUsageError2() {
  }
  ;
  CLIUsageError2.value = new CLIUsageError2();
  return CLIUsageError2;
}();
var DataFormatError = /* @__PURE__ */ function() {
  function DataFormatError2() {
  }
  ;
  DataFormatError2.value = new DataFormatError2();
  return DataFormatError2;
}();
var CannotOpenInput = /* @__PURE__ */ function() {
  function CannotOpenInput2() {
  }
  ;
  CannotOpenInput2.value = new CannotOpenInput2();
  return CannotOpenInput2;
}();
var AddresseeUnknown = /* @__PURE__ */ function() {
  function AddresseeUnknown2() {
  }
  ;
  AddresseeUnknown2.value = new AddresseeUnknown2();
  return AddresseeUnknown2;
}();
var HostNameUnknown = /* @__PURE__ */ function() {
  function HostNameUnknown2() {
  }
  ;
  HostNameUnknown2.value = new HostNameUnknown2();
  return HostNameUnknown2;
}();
var ServiceUnavailable = /* @__PURE__ */ function() {
  function ServiceUnavailable2() {
  }
  ;
  ServiceUnavailable2.value = new ServiceUnavailable2();
  return ServiceUnavailable2;
}();
var InternalSoftwareError = /* @__PURE__ */ function() {
  function InternalSoftwareError2() {
  }
  ;
  InternalSoftwareError2.value = new InternalSoftwareError2();
  return InternalSoftwareError2;
}();
var SystemError = /* @__PURE__ */ function() {
  function SystemError2() {
  }
  ;
  SystemError2.value = new SystemError2();
  return SystemError2;
}();
var CriticalOSFileMissing = /* @__PURE__ */ function() {
  function CriticalOSFileMissing2() {
  }
  ;
  CriticalOSFileMissing2.value = new CriticalOSFileMissing2();
  return CriticalOSFileMissing2;
}();
var CannotCreateOutputFile = /* @__PURE__ */ function() {
  function CannotCreateOutputFile2() {
  }
  ;
  CannotCreateOutputFile2.value = new CannotCreateOutputFile2();
  return CannotCreateOutputFile2;
}();
var IOError = /* @__PURE__ */ function() {
  function IOError2() {
  }
  ;
  IOError2.value = new IOError2();
  return IOError2;
}();
var TemporaryFailure = /* @__PURE__ */ function() {
  function TemporaryFailure2() {
  }
  ;
  TemporaryFailure2.value = new TemporaryFailure2();
  return TemporaryFailure2;
}();
var RemoteError = /* @__PURE__ */ function() {
  function RemoteError2() {
  }
  ;
  RemoteError2.value = new RemoteError2();
  return RemoteError2;
}();
var PermissionDenied = /* @__PURE__ */ function() {
  function PermissionDenied2() {
  }
  ;
  PermissionDenied2.value = new PermissionDenied2();
  return PermissionDenied2;
}();
var ConfigurationError = /* @__PURE__ */ function() {
  function ConfigurationError2() {
  }
  ;
  ConfigurationError2.value = new ConfigurationError2();
  return ConfigurationError2;
}();
var CannotExecute = /* @__PURE__ */ function() {
  function CannotExecute2() {
  }
  ;
  CannotExecute2.value = new CannotExecute2();
  return CannotExecute2;
}();
var CommandNotFound = /* @__PURE__ */ function() {
  function CommandNotFound2() {
  }
  ;
  CommandNotFound2.value = new CommandNotFound2();
  return CommandNotFound2;
}();
var InvalidExitArgument = /* @__PURE__ */ function() {
  function InvalidExitArgument2() {
  }
  ;
  InvalidExitArgument2.value = new InvalidExitArgument2();
  return InvalidExitArgument2;
}();
var SIGHUP = /* @__PURE__ */ function() {
  function SIGHUP2() {
  }
  ;
  SIGHUP2.value = new SIGHUP2();
  return SIGHUP2;
}();
var SIGINT = /* @__PURE__ */ function() {
  function SIGINT2() {
  }
  ;
  SIGINT2.value = new SIGINT2();
  return SIGINT2;
}();
var SIGQUIT = /* @__PURE__ */ function() {
  function SIGQUIT2() {
  }
  ;
  SIGQUIT2.value = new SIGQUIT2();
  return SIGQUIT2;
}();
var SIGILL = /* @__PURE__ */ function() {
  function SIGILL2() {
  }
  ;
  SIGILL2.value = new SIGILL2();
  return SIGILL2;
}();
var SIGABRT = /* @__PURE__ */ function() {
  function SIGABRT2() {
  }
  ;
  SIGABRT2.value = new SIGABRT2();
  return SIGABRT2;
}();
var SIGFPE = /* @__PURE__ */ function() {
  function SIGFPE2() {
  }
  ;
  SIGFPE2.value = new SIGFPE2();
  return SIGFPE2;
}();
var SIGKILL = /* @__PURE__ */ function() {
  function SIGKILL2() {
  }
  ;
  SIGKILL2.value = new SIGKILL2();
  return SIGKILL2;
}();
var SIGSEGV = /* @__PURE__ */ function() {
  function SIGSEGV2() {
  }
  ;
  SIGSEGV2.value = new SIGSEGV2();
  return SIGSEGV2;
}();
var SIGPIPE = /* @__PURE__ */ function() {
  function SIGPIPE2() {
  }
  ;
  SIGPIPE2.value = new SIGPIPE2();
  return SIGPIPE2;
}();
var SIGALRM = /* @__PURE__ */ function() {
  function SIGALRM2() {
  }
  ;
  SIGALRM2.value = new SIGALRM2();
  return SIGALRM2;
}();
var SIGTERM = /* @__PURE__ */ function() {
  function SIGTERM2() {
  }
  ;
  SIGTERM2.value = new SIGTERM2();
  return SIGTERM2;
}();
var eqExitCode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return true;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return true;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return true;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return true;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return true;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return true;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return true;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return true;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return true;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return true;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return true;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return true;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return true;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return true;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return true;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return true;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return true;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return true;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return true;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return true;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return true;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return true;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return true;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return true;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return true;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return true;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return true;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return true;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return true;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return true;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return true;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordExitCode = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return EQ.value;
      }
      ;
      if (x instanceof Success) {
        return LT.value;
      }
      ;
      if (y instanceof Success) {
        return GT.value;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return EQ.value;
      }
      ;
      if (x instanceof $$Error) {
        return LT.value;
      }
      ;
      if (y instanceof $$Error) {
        return GT.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return EQ.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins) {
        return LT.value;
      }
      ;
      if (y instanceof MisuseOfShellBuiltins) {
        return GT.value;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return EQ.value;
      }
      ;
      if (x instanceof CLIUsageError) {
        return LT.value;
      }
      ;
      if (y instanceof CLIUsageError) {
        return GT.value;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return EQ.value;
      }
      ;
      if (x instanceof DataFormatError) {
        return LT.value;
      }
      ;
      if (y instanceof DataFormatError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotOpenInput) {
        return LT.value;
      }
      ;
      if (y instanceof CannotOpenInput) {
        return GT.value;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof AddresseeUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof AddresseeUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof HostNameUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof HostNameUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return EQ.value;
      }
      ;
      if (x instanceof ServiceUnavailable) {
        return LT.value;
      }
      ;
      if (y instanceof ServiceUnavailable) {
        return GT.value;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return EQ.value;
      }
      ;
      if (x instanceof InternalSoftwareError) {
        return LT.value;
      }
      ;
      if (y instanceof InternalSoftwareError) {
        return GT.value;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return EQ.value;
      }
      ;
      if (x instanceof SystemError) {
        return LT.value;
      }
      ;
      if (y instanceof SystemError) {
        return GT.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return EQ.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing) {
        return LT.value;
      }
      ;
      if (y instanceof CriticalOSFileMissing) {
        return GT.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile) {
        return LT.value;
      }
      ;
      if (y instanceof CannotCreateOutputFile) {
        return GT.value;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return EQ.value;
      }
      ;
      if (x instanceof IOError) {
        return LT.value;
      }
      ;
      if (y instanceof IOError) {
        return GT.value;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return EQ.value;
      }
      ;
      if (x instanceof TemporaryFailure) {
        return LT.value;
      }
      ;
      if (y instanceof TemporaryFailure) {
        return GT.value;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return EQ.value;
      }
      ;
      if (x instanceof RemoteError) {
        return LT.value;
      }
      ;
      if (y instanceof RemoteError) {
        return GT.value;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return EQ.value;
      }
      ;
      if (x instanceof PermissionDenied) {
        return LT.value;
      }
      ;
      if (y instanceof PermissionDenied) {
        return GT.value;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return EQ.value;
      }
      ;
      if (x instanceof ConfigurationError) {
        return LT.value;
      }
      ;
      if (y instanceof ConfigurationError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotExecute) {
        return LT.value;
      }
      ;
      if (y instanceof CannotExecute) {
        return GT.value;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return EQ.value;
      }
      ;
      if (x instanceof CommandNotFound) {
        return LT.value;
      }
      ;
      if (y instanceof CommandNotFound) {
        return GT.value;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return EQ.value;
      }
      ;
      if (x instanceof InvalidExitArgument) {
        return LT.value;
      }
      ;
      if (y instanceof InvalidExitArgument) {
        return GT.value;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGHUP) {
        return LT.value;
      }
      ;
      if (y instanceof SIGHUP) {
        return GT.value;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGINT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGINT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGQUIT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGQUIT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGABRT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGABRT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGFPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGFPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGKILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGKILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGSEGV) {
        return LT.value;
      }
      ;
      if (y instanceof SIGSEGV) {
        return GT.value;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGPIPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGPIPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGALRM) {
        return LT.value;
      }
      ;
      if (y instanceof SIGALRM) {
        return GT.value;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at ExitCodes (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqExitCode;
  }
};
var enumExitCode = {
  succ: function(v) {
    if (v instanceof Success) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof $$Error) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGTERM.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  pred: function(v) {
    if (v instanceof Success) {
      return Nothing.value;
    }
    ;
    if (v instanceof $$Error) {
      return new Just(Success.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return new Just(SIGALRM.value);
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  Ord0: function() {
    return ordExitCode;
  }
};
var boundedExitCode = /* @__PURE__ */ function() {
  return {
    bottom: Success.value,
    top: SIGTERM.value,
    Ord0: function() {
      return ordExitCode;
    }
  };
}();
var boundedEnumExitCode = {
  cardinality: 32,
  toEnum: function(v) {
    if (v === 0) {
      return new Just(Success.value);
    }
    ;
    if (v === 1) {
      return new Just($$Error.value);
    }
    ;
    if (v === 2) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v === 64) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v === 65) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v === 66) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v === 67) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v === 68) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v === 69) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v === 70) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v === 71) {
      return new Just(SystemError.value);
    }
    ;
    if (v === 72) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v === 73) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v === 74) {
      return new Just(IOError.value);
    }
    ;
    if (v === 75) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v === 76) {
      return new Just(RemoteError.value);
    }
    ;
    if (v === 77) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v === 78) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v === 126) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v === 127) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v === 128) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v === 129) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v === 130) {
      return new Just(SIGINT.value);
    }
    ;
    if (v === 131) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v === 132) {
      return new Just(SIGILL.value);
    }
    ;
    if (v === 134) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v === 136) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v === 137) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v === 139) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v === 141) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v === 142) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v === 143) {
      return new Just(SIGTERM.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Success) {
      return 0;
    }
    ;
    if (v instanceof $$Error) {
      return 1;
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return 2;
    }
    ;
    if (v instanceof CLIUsageError) {
      return 64;
    }
    ;
    if (v instanceof DataFormatError) {
      return 65;
    }
    ;
    if (v instanceof CannotOpenInput) {
      return 66;
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return 67;
    }
    ;
    if (v instanceof HostNameUnknown) {
      return 68;
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return 69;
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return 70;
    }
    ;
    if (v instanceof SystemError) {
      return 71;
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return 72;
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return 73;
    }
    ;
    if (v instanceof IOError) {
      return 74;
    }
    ;
    if (v instanceof TemporaryFailure) {
      return 75;
    }
    ;
    if (v instanceof RemoteError) {
      return 76;
    }
    ;
    if (v instanceof PermissionDenied) {
      return 77;
    }
    ;
    if (v instanceof ConfigurationError) {
      return 78;
    }
    ;
    if (v instanceof CannotExecute) {
      return 126;
    }
    ;
    if (v instanceof CommandNotFound) {
      return 127;
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return 128;
    }
    ;
    if (v instanceof SIGHUP) {
      return 128 + 1 | 0;
    }
    ;
    if (v instanceof SIGINT) {
      return 128 + 2 | 0;
    }
    ;
    if (v instanceof SIGQUIT) {
      return 128 + 3 | 0;
    }
    ;
    if (v instanceof SIGILL) {
      return 128 + 4 | 0;
    }
    ;
    if (v instanceof SIGABRT) {
      return 128 + 6 | 0;
    }
    ;
    if (v instanceof SIGFPE) {
      return 128 + 8 | 0;
    }
    ;
    if (v instanceof SIGKILL) {
      return 128 + 9 | 0;
    }
    ;
    if (v instanceof SIGSEGV) {
      return 128 + 11 | 0;
    }
    ;
    if (v instanceof SIGPIPE) {
      return 128 + 13 | 0;
    }
    ;
    if (v instanceof SIGALRM) {
      return 128 + 14 | 0;
    }
    ;
    if (v instanceof SIGTERM) {
      return 128 + 15 | 0;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 153, column 1 - line 219, column 30): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedExitCode;
  },
  Enum1: function() {
    return enumExitCode;
  }
};

// output/Options.Applicative.Internal.Utils/index.js
var eq21 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var whitespaceRegex = /* @__PURE__ */ function() {
  var v = regex("\\s+")(noFlags);
  if (v instanceof Left) {
    return unsafeCrashWith("whitespaceRegex: `\\s+` seems to be invlaid, err: " + v.value0);
  }
  ;
  if (v instanceof Right) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Internal.Utils (line 39, column 19 - line 41, column 15): " + [v.constructor.name]);
}();
var words = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split2(whitespaceRegex)(v);
};
var unWords = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)(" ");
};
var unLines = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)("\n");
};
var startsWith = function(p) {
  return function(s) {
    return eq21(indexOf2(p)(s))(new Just(0));
  };
};
var lines = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split("\n")(v);
};

// output/Data.CatQueue/index.js
var CatQueue = /* @__PURE__ */ function() {
  function CatQueue2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatQueue2.create = function(value0) {
    return function(value12) {
      return new CatQueue2(value0, value12);
    };
  };
  return CatQueue2;
}();
var uncons6 = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v.value0 instanceof Nil) {
      $copy_v = new CatQueue(reverse2(v.value1), Nil.value);
      return;
    }
    ;
    if (v.value0 instanceof Cons) {
      $tco_done = true;
      return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var snoc4 = function(v) {
  return function(a) {
    return new CatQueue(v.value0, new Cons(a, v.value1));
  };
};
var $$null6 = function(v) {
  if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var empty7 = /* @__PURE__ */ function() {
  return new CatQueue(Nil.value, Nil.value);
}();

// output/Data.CatList/index.js
var CatNil = /* @__PURE__ */ function() {
  function CatNil2() {
  }
  ;
  CatNil2.value = new CatNil2();
  return CatNil2;
}();
var CatCons = /* @__PURE__ */ function() {
  function CatCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatCons2.create = function(value0) {
    return function(value12) {
      return new CatCons2(value0, value12);
    };
  };
  return CatCons2;
}();
var link3 = function(v) {
  return function(v1) {
    if (v instanceof CatNil) {
      return v1;
    }
    ;
    if (v1 instanceof CatNil) {
      return v;
    }
    ;
    if (v instanceof CatCons) {
      return new CatCons(v.value0, snoc4(v.value1)(v1));
    }
    ;
    throw new Error("Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): " + [v.constructor.name, v1.constructor.name]);
  };
};
var foldr5 = function(k) {
  return function(b) {
    return function(q) {
      var foldl3 = function($copy_v) {
        return function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v = $copy_v;
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1, v2) {
              if (v2 instanceof Nil) {
                $tco_done = true;
                return v1;
              }
              ;
              if (v2 instanceof Cons) {
                $tco_var_v = v;
                $tco_var_v1 = v(v1)(v2.value0);
                $copy_v2 = v2.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
      };
      var go = function($copy_xs) {
        return function($copy_ys) {
          var $tco_var_xs = $copy_xs;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(xs, ys) {
            var v = uncons6(xs);
            if (v instanceof Nothing) {
              $tco_done1 = true;
              return foldl3(function(x) {
                return function(i) {
                  return i(x);
                };
              })(b)(ys);
            }
            ;
            if (v instanceof Just) {
              $tco_var_xs = v.value0.value1;
              $copy_ys = new Cons(k(v.value0.value0), ys);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_xs, $copy_ys);
          }
          ;
          return $tco_result;
        };
      };
      return go(q)(Nil.value);
    };
  };
};
var uncons7 = function(v) {
  if (v instanceof CatNil) {
    return Nothing.value;
  }
  ;
  if (v instanceof CatCons) {
    return new Just(new Tuple(v.value0, function() {
      var $66 = $$null6(v.value1);
      if ($66) {
        return CatNil.value;
      }
      ;
      return foldr5(link3)(CatNil.value)(v.value1);
    }()));
  }
  ;
  throw new Error("Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var empty8 = /* @__PURE__ */ function() {
  return CatNil.value;
}();
var append6 = link3;
var semigroupCatList = {
  append: append6
};
var snoc5 = function(cat) {
  return function(a) {
    return append6(cat)(new CatCons(a, empty7));
  };
};

// output/Control.Monad.Free/index.js
var $runtime_lazy8 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var append7 = /* @__PURE__ */ append(semigroupCatList);
var Free = /* @__PURE__ */ function() {
  function Free2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Free2.create = function(value0) {
    return function(value12) {
      return new Free2(value0, value12);
    };
  };
  return Free2;
}();
var Return = /* @__PURE__ */ function() {
  function Return2(value0) {
    this.value0 = value0;
  }
  ;
  Return2.create = function(value0) {
    return new Return2(value0);
  };
  return Return2;
}();
var Bind = /* @__PURE__ */ function() {
  function Bind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Bind2.create = function(value0) {
    return function(value12) {
      return new Bind2(value0, value12);
    };
  };
  return Bind2;
}();
var toView = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    var runExpF = function(v22) {
      return v22;
    };
    var concatF = function(v22) {
      return function(r) {
        return new Free(v22.value0, append7(v22.value1)(r));
      };
    };
    if (v.value0 instanceof Return) {
      var v2 = uncons7(v.value1);
      if (v2 instanceof Nothing) {
        $tco_done = true;
        return new Return(v.value0.value0);
      }
      ;
      if (v2 instanceof Just) {
        $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);
        return;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): " + [v2.constructor.name]);
    }
    ;
    if (v.value0 instanceof Bind) {
      $tco_done = true;
      return new Bind(v.value0.value0, function(a) {
        return concatF(v.value0.value1(a))(v.value1);
      });
    }
    ;
    throw new Error("Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): " + [v.value0.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var resume$prime = function(k) {
  return function(j) {
    return function(f) {
      var v = toView(f);
      if (v instanceof Return) {
        return j(v.value0);
      }
      ;
      if (v instanceof Bind) {
        return k(v.value0)(v.value1);
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 213, column 17 - line 215, column 20): " + [v.constructor.name]);
    };
  };
};
var fromView = function(f) {
  return new Free(f, empty8);
};
var freeMonad = {
  Applicative0: function() {
    return freeApplicative;
  },
  Bind1: function() {
    return freeBind;
  }
};
var freeFunctor = {
  map: function(k) {
    return function(f) {
      return bindFlipped(freeBind)(function() {
        var $189 = pure(freeApplicative);
        return function($190) {
          return $189(k($190));
        };
      }())(f);
    };
  }
};
var freeBind = {
  bind: function(v) {
    return function(k) {
      return new Free(v.value0, snoc5(v.value1)(k));
    };
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var freeApplicative = {
  pure: function($191) {
    return fromView(Return.create($191));
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy8("freeApply", "Control.Monad.Free", function() {
  return {
    apply: ap(freeMonad),
    Functor0: function() {
      return freeFunctor;
    }
  };
});
var bind16 = /* @__PURE__ */ bind(freeBind);
var pure20 = /* @__PURE__ */ pure(freeApplicative);
var freeMonadRec = {
  tailRecM: function(k) {
    return function(a) {
      return bind16(k(a))(function(v) {
        if (v instanceof Loop) {
          return tailRecM(freeMonadRec)(k)(v.value0);
        }
        ;
        if (v instanceof Done) {
          return pure20(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Free (line 86, column 26 - line 88, column 21): " + [v.constructor.name]);
      });
    };
  },
  Monad0: function() {
    return freeMonad;
  }
};
var liftF = function(f) {
  return fromView(new Bind(f, function($192) {
    return pure20($192);
  }));
};

// output/Data.Exists/index.js
var runExists = unsafeCoerce2;
var mkExists = unsafeCoerce2;

// output/Text.PrettyPrint.Leijen/index.js
var max3 = /* @__PURE__ */ max(ordInt);
var min3 = /* @__PURE__ */ min(ordInt);
var foldr6 = /* @__PURE__ */ foldr(foldableArray);
var SFail = /* @__PURE__ */ function() {
  function SFail2() {
  }
  ;
  SFail2.value = new SFail2();
  return SFail2;
}();
var SEmpty = /* @__PURE__ */ function() {
  function SEmpty2() {
  }
  ;
  SEmpty2.value = new SEmpty2();
  return SEmpty2;
}();
var SChar = /* @__PURE__ */ function() {
  function SChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar2.create = function(value0) {
    return function(value12) {
      return new SChar2(value0, value12);
    };
  };
  return SChar2;
}();
var SText = /* @__PURE__ */ function() {
  function SText2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText2(value0, value12, value22);
      };
    };
  };
  return SText2;
}();
var SLine = /* @__PURE__ */ function() {
  function SLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine2.create = function(value0) {
    return function(value12) {
      return new SLine2(value0, value12);
    };
  };
  return SLine2;
}();
var SFail$prime = /* @__PURE__ */ function() {
  function SFail$prime2() {
  }
  ;
  SFail$prime2.value = new SFail$prime2();
  return SFail$prime2;
}();
var SEmpty$prime = /* @__PURE__ */ function() {
  function SEmpty$prime2() {
  }
  ;
  SEmpty$prime2.value = new SEmpty$prime2();
  return SEmpty$prime2;
}();
var SChar$prime = /* @__PURE__ */ function() {
  function SChar$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar$prime2.create = function(value0) {
    return function(value12) {
      return new SChar$prime2(value0, value12);
    };
  };
  return SChar$prime2;
}();
var SText$prime = /* @__PURE__ */ function() {
  function SText$prime2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText$prime2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText$prime2(value0, value12, value22);
      };
    };
  };
  return SText$prime2;
}();
var SLine$prime = /* @__PURE__ */ function() {
  function SLine$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine$prime2.create = function(value0) {
    return function(value12) {
      return new SLine$prime2(value0, value12);
    };
  };
  return SLine$prime2;
}();
var Fail = /* @__PURE__ */ function() {
  function Fail2() {
  }
  ;
  Fail2.value = new Fail2();
  return Fail2;
}();
var Empty = /* @__PURE__ */ function() {
  function Empty2() {
  }
  ;
  Empty2.value = new Empty2();
  return Empty2;
}();
var Char = /* @__PURE__ */ function() {
  function Char2(value0) {
    this.value0 = value0;
  }
  ;
  Char2.create = function(value0) {
    return new Char2(value0);
  };
  return Char2;
}();
var Text = /* @__PURE__ */ function() {
  function Text2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text2.create = function(value0) {
    return function(value12) {
      return new Text2(value0, value12);
    };
  };
  return Text2;
}();
var Line = /* @__PURE__ */ function() {
  function Line2() {
  }
  ;
  Line2.value = new Line2();
  return Line2;
}();
var FlatAlt = /* @__PURE__ */ function() {
  function FlatAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlatAlt2.create = function(value0) {
    return function(value12) {
      return new FlatAlt2(value0, value12);
    };
  };
  return FlatAlt2;
}();
var Cat = /* @__PURE__ */ function() {
  function Cat2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cat2.create = function(value0) {
    return function(value12) {
      return new Cat2(value0, value12);
    };
  };
  return Cat2;
}();
var Nest = /* @__PURE__ */ function() {
  function Nest2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Nest2.create = function(value0) {
    return function(value12) {
      return new Nest2(value0, value12);
    };
  };
  return Nest2;
}();
var Union = /* @__PURE__ */ function() {
  function Union2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Union2.create = function(value0) {
    return function(value12) {
      return new Union2(value0, value12);
    };
  };
  return Union2;
}();
var Column = /* @__PURE__ */ function() {
  function Column2(value0) {
    this.value0 = value0;
  }
  ;
  Column2.create = function(value0) {
    return new Column2(value0);
  };
  return Column2;
}();
var Columns = /* @__PURE__ */ function() {
  function Columns2(value0) {
    this.value0 = value0;
  }
  ;
  Columns2.create = function(value0) {
    return new Columns2(value0);
  };
  return Columns2;
}();
var Nesting = /* @__PURE__ */ function() {
  function Nesting2(value0) {
    this.value0 = value0;
  }
  ;
  Nesting2.create = function(value0) {
    return new Nesting2(value0);
  };
  return Nesting2;
}();
var Nil3 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons3 = /* @__PURE__ */ function() {
  function Cons4(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Cons4(value0, value12, value22);
      };
    };
  };
  return Cons4;
}();
var text = function(v) {
  if (v === "") {
    return Empty.value;
  }
  ;
  return new Text(length4(v), v);
};
var spaces = function(n) {
  if (n <= 0) {
    return "";
  }
  ;
  if (otherwise) {
    return fromCharArray(replicate(n)(" "));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 908, column 1 - line 908, column 24): " + [n.constructor.name]);
};
var space = /* @__PURE__ */ function() {
  return new Char(" ");
}();
var rparen = /* @__PURE__ */ function() {
  return new Char(")");
}();
var rbracket = /* @__PURE__ */ function() {
  return new Char("]");
}();
var nesting = function(f) {
  return new Nesting(f);
};
var nest = function(i) {
  return function(x) {
    return new Nest(i, x);
  };
};
var lparen = /* @__PURE__ */ function() {
  return new Char("(");
}();
var line = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, space);
}();
var lbracket = /* @__PURE__ */ function() {
  return new Char("[");
}();
var indentation = function(n) {
  return spaces(n);
};
var forceSimpleDoc = function(v) {
  if (v instanceof SFail$prime) {
    return SFail.value;
  }
  ;
  if (v instanceof SEmpty$prime) {
    return SEmpty.value;
  }
  ;
  if (v instanceof SChar$prime) {
    return new SChar(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  if (v instanceof SText$prime) {
    return new SText(v.value0, v.value1, forceSimpleDoc(force(v.value2)));
  }
  ;
  if (v instanceof SLine$prime) {
    return new SLine(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 600, column 18 - line 605, column 51): " + [v.constructor.name]);
};
var renderFits = function(fits) {
  return function(rfrac) {
    return function(w) {
      return function(headNode) {
        var r = max3(0)(min3(w)(round2(toNumber(w) * rfrac)));
        var nicest$prime = function(n) {
          return function(k) {
            return function(i) {
              return function(ds) {
                return function(x) {
                  return function(y) {
                    var x$prime = best(n)(k)(new Cons3(i, x, ds));
                    var width$prime = min3(w - k | 0)((r - k | 0) + n | 0);
                    var $221 = fits(w)(min3(n)(k))(width$prime)(x$prime);
                    if ($221) {
                      return x$prime;
                    }
                    ;
                    var y$prime = best(n)(k)(new Cons3(i, y, ds));
                    return y$prime;
                  };
                };
              };
            };
          };
        };
        var best = function(v) {
          return function(v1) {
            return function(v2) {
              if (v2 instanceof Nil3) {
                return SEmpty$prime.value;
              }
              ;
              if (v2 instanceof Cons3) {
                if (v2.value1 instanceof Fail) {
                  return SFail$prime.value;
                }
                ;
                if (v2.value1 instanceof Empty) {
                  return best(v)(v1)(v2.value2);
                }
                ;
                if (v2.value1 instanceof Char) {
                  var k$prime = v1 + 1 | 0;
                  return new SChar$prime(v2.value1.value0, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Text) {
                  var k$prime = v1 + v2.value1.value0 | 0;
                  return new SText$prime(v2.value1.value0, v2.value1.value1, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Line) {
                  return new SLine$prime(v2.value0, defer2(function(v3) {
                    return best(v2.value0)(v2.value0)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof FlatAlt) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, v2.value2));
                }
                ;
                if (v2.value1 instanceof Cat) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, new Cons3(v2.value0, v2.value1.value1, v2.value2)));
                }
                ;
                if (v2.value1 instanceof Nest) {
                  var i$prime = v2.value0 + v2.value1.value0 | 0;
                  return best(v)(v1)(new Cons3(i$prime, v2.value1.value1, v2.value2));
                }
                ;
                if (v2.value1 instanceof Union) {
                  return nicest$prime(v)(v1)(v2.value0)(v2.value2)(v2.value1.value0)(v2.value1.value1);
                }
                ;
                if (v2.value1 instanceof Column) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v1), v2.value2));
                }
                ;
                if (v2.value1 instanceof Columns) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(new Just(w)), v2.value2));
                }
                ;
                if (v2.value1 instanceof Nesting) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v2.value0), v2.value2));
                }
                ;
                throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 788, column 11 - line 802, column 56): " + [v2.value1.constructor.name]);
              }
              ;
              throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 785, column 7 - line 785, column 50): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            };
          };
        };
        return forceSimpleDoc(best(0)(0)(new Cons3(0, headNode, Nil3.value)));
      };
    };
  };
};
var foldr12 = function(dictMonoid) {
  var mempty11 = mempty(dictMonoid);
  return function(f) {
    return function($297) {
      return function(v) {
        if (v instanceof Nothing) {
          return mempty11;
        }
        ;
        if (v instanceof Just) {
          return foldr6(f)(v.value0.last)(v.value0.init);
        }
        ;
        throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 122, column 29 - line 124, column 43): " + [v.constructor.name]);
      }(unsnoc($297));
    };
  };
};
var flatten = function(v) {
  if (v instanceof FlatAlt) {
    return v.value1;
  }
  ;
  if (v instanceof Cat) {
    return new Cat(flatten(v.value0), flatten(v.value1));
  }
  ;
  if (v instanceof Nest) {
    return new Nest(v.value0, flatten(v.value1));
  }
  ;
  if (v instanceof Line) {
    return Fail.value;
  }
  ;
  if (v instanceof Union) {
    return flatten(v.value0);
  }
  ;
  if (v instanceof Column) {
    return new Column(function($298) {
      return flatten(v.value0($298));
    });
  }
  ;
  if (v instanceof Columns) {
    return new Columns(function($299) {
      return flatten(v.value0($299));
    });
  }
  ;
  if (v instanceof Nesting) {
    return new Nesting(function($300) {
      return flatten(v.value0($300));
    });
  }
  ;
  return v;
};
var group4 = function(x) {
  return new Union(flatten(x), x);
};
var softline = /* @__PURE__ */ group4(line);
var fits1 = function($copy_v) {
  return function($copy_v1) {
    return function($copy_v2) {
      return function($copy_v3) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_var_v2 = $copy_v2;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1, v2, v3) {
          if (v2 < 0) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SFail$prime) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SEmpty$prime) {
            $tco_done = true;
            return true;
          }
          ;
          if (v3 instanceof SChar$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - 1 | 0;
            $copy_v3 = force(v3.value1);
            return;
          }
          ;
          if (v3 instanceof SText$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - v3.value0 | 0;
            $copy_v3 = force(v3.value2);
            return;
          }
          ;
          if (v3 instanceof SLine$prime) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 819, column 1 - line 819, column 55): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $tco_var_v2, $copy_v3);
        }
        ;
        return $tco_result;
      };
    };
  };
};
var renderPretty = /* @__PURE__ */ renderFits(fits1);
var empty9 = /* @__PURE__ */ function() {
  return Empty.value;
}();
var linebreak = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, empty9);
}();
var displayS = function(v) {
  if (v instanceof SFail) {
    return unsafeCrashWith("@SFail@ can not appear uncaught in a rendered @SimpleDoc@");
  }
  ;
  if (v instanceof SEmpty) {
    return "";
  }
  ;
  if (v instanceof SChar) {
    return fromCharArray([v.value0]) + displayS(v.value1);
  }
  ;
  if (v instanceof SText) {
    return v.value1 + displayS(v.value2);
  }
  ;
  if (v instanceof SLine) {
    return "\n" + (indentation(v.value0) + displayS(v.value1));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 893, column 1 - line 893, column 32): " + [v.constructor.name]);
};
var column = function(f) {
  return new Column(f);
};
var $$char3 = function(v) {
  if (v === "\n") {
    return line;
  }
  ;
  return new Char(v);
};
var beside = function(x) {
  return function(y) {
    return new Cat(x, y);
  };
};
var docSemigroup = {
  append: beside
};
var append14 = /* @__PURE__ */ append(docSemigroup);
var docMonoid = {
  mempty: empty9,
  Semigroup0: function() {
    return docSemigroup;
  }
};
var foldr11 = /* @__PURE__ */ foldr12(docMonoid);
var string3 = /* @__PURE__ */ function() {
  var $303 = intercalate(foldableArray)(docMonoid)(line);
  var $304 = map(functorArray)(text);
  var $305 = split("\n");
  return function($306) {
    return $303($304($305($306)));
  };
}();
var enclose = function(l) {
  return function(r) {
    return function(x) {
      return append14(l)(append14(x)(r));
    };
  };
};
var brackets = /* @__PURE__ */ enclose(lbracket)(rbracket);
var parens = /* @__PURE__ */ enclose(lparen)(rparen);
var width = function(d) {
  return function(f) {
    return column(function(k1) {
      return append14(d)(column(function(k2) {
        return f(k2 - k1 | 0);
      }));
    });
  };
};
var fillBreak = function(f) {
  return function(x) {
    return width(x)(function(w) {
      var $292 = w > f;
      if ($292) {
        return nest(f)(linebreak);
      }
      ;
      return text(spaces(f - w | 0));
    });
  };
};
var appendWithSpace = function(x) {
  return function(y) {
    return append14(x)(append14(space)(y));
  };
};
var hsep = /* @__PURE__ */ foldr11(appendWithSpace);
var appendWithSoftline = function(x) {
  return function(y) {
    return append14(x)(append14(softline)(y));
  };
};
var appendWithLinebreak = function(x) {
  return function(y) {
    return append14(x)(append14(linebreak)(y));
  };
};
var vcat = /* @__PURE__ */ foldr11(appendWithLinebreak);
var appendWithLine = function(x) {
  return function(y) {
    return append14(x)(append14(line)(y));
  };
};
var align = function(d) {
  return column(function(k) {
    return nesting(function(i) {
      return nest(k - i | 0)(d);
    });
  });
};
var hang = function(i) {
  return function(d) {
    return align(nest(i)(d));
  };
};
var indent = function(i) {
  return function(d) {
    return hang(i)(append14(text(spaces(i)))(d));
  };
};

// output/Options.Applicative.Help.Chunk/index.js
var un2 = /* @__PURE__ */ un();
var foldr7 = /* @__PURE__ */ foldr(foldableArray);
var mempty6 = /* @__PURE__ */ mempty(docMonoid);
var fold8 = /* @__PURE__ */ fold(foldableArray);
var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorArray);
var Chunk = function(x) {
  return x;
};
var chunked = function(v) {
  return function(v1) {
    return function(v2) {
      if (v1 instanceof Nothing) {
        return v2;
      }
      ;
      if (v2 instanceof Nothing) {
        return v1;
      }
      ;
      if (v1 instanceof Just && v2 instanceof Just) {
        return new Just(v(v1.value0)(v2.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Help.Chunk (line 57, column 1 - line 58, column 41): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var chunkSemigroup = function(dictSemigroup) {
  return {
    append: chunked(append(dictSemigroup))
  };
};
var extractChunk = function(dictMonoid) {
  var $56 = fromMaybe(mempty(dictMonoid));
  var $57 = un2(Chunk);
  return function($58) {
    return $56($57($58));
  };
};
var isEmpty3 = /* @__PURE__ */ function() {
  var $59 = un2(Chunk);
  return function($60) {
    return isNothing($59($60));
  };
}();
var chunkMonoid = function(dictSemigroup) {
  var chunkSemigroup1 = chunkSemigroup(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return chunkSemigroup1;
    }
  };
};
var mempty1 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var vcatChunks = /* @__PURE__ */ foldr7(/* @__PURE__ */ chunked(appendWithLine))(mempty1);
var vsepChunks = /* @__PURE__ */ foldr7(/* @__PURE__ */ chunked(function(x) {
  return function(y) {
    return appendWithLine(x)(appendWithLine(mempty6)(y));
  };
}))(mempty1);
var chunkFunctor = functorMaybe;
var chunkBesideOrBelow = /* @__PURE__ */ chunked(appendWithSoftline);
var chunkBeside = /* @__PURE__ */ chunked(appendWithSpace);
var chunkApply = applyMaybe;
var chunkApplicative = applicativeMaybe;
var pure21 = /* @__PURE__ */ pure(chunkApplicative);
var listToChunk = function(dictMonoid) {
  var mempty24 = mempty(chunkMonoid(dictMonoid.Semigroup0()));
  var fold18 = fold8(dictMonoid);
  return function(v) {
    if (v.length === 0) {
      return mempty24;
    }
    ;
    return pure21(fold18(v));
  };
};
var stringChunk = function(v) {
  if (v === "") {
    return mempty1;
  }
  ;
  return pure21(text(v));
};
var paragraph = /* @__PURE__ */ function() {
  var $61 = foldr7(function() {
    var $63 = chunked(appendWithSoftline);
    return function($64) {
      return $63(stringChunk($64));
    };
  }())(mempty1);
  return function($62) {
    return $61(words($62));
  };
}();
var tabulate$prime = function(v) {
  return function(v1) {
    if (v1.length === 0) {
      return mempty1;
    }
    ;
    return pure21(vcat(mapFlipped5(v1)(function(v2) {
      return indent(2)(appendWithSpace(fillBreak(v)(v2.value0))(v2.value1));
    })));
  };
};
var tabulate = /* @__PURE__ */ tabulate$prime(24);

// output/Options.Applicative.Help.Types/index.js
var helpBodyIsSymbol = {
  reflectSymbol: function() {
    return "helpBody";
  }
};
var helpErrorIsSymbol = {
  reflectSymbol: function() {
    return "helpError";
  }
};
var helpFooterIsSymbol = {
  reflectSymbol: function() {
    return "helpFooter";
  }
};
var helpHeaderIsSymbol = {
  reflectSymbol: function() {
    return "helpHeader";
  }
};
var helpSuggestionsIsSymbol = {
  reflectSymbol: function() {
    return "helpSuggestions";
  }
};
var helpUsageIsSymbol = {
  reflectSymbol: function() {
    return "helpUsage";
  }
};
var chunkMonoid2 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var extractChunk2 = /* @__PURE__ */ extractChunk(docMonoid);
var ParserHelp = function(x) {
  return x;
};
var parserHelpMonoid = /* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(helpBodyIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpErrorIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpFooterIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpHeaderIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpSuggestionsIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpUsageIsSymbol)(chunkMonoid2)()(monoidRecordNil)))))));
var helpText = function(v) {
  return extractChunk2(vsepChunks([v.helpError, v.helpSuggestions, v.helpHeader, v.helpUsage, v.helpBody, v.helpFooter]));
};
var renderHelp = function(cols) {
  var $65 = renderPretty(1)(cols);
  return function($66) {
    return displayS($65(helpText($66)));
  };
};

// output/Options.Applicative.Types/index.js
var monadExceptT3 = /* @__PURE__ */ monadExceptT(monadIdentity);
var map30 = /* @__PURE__ */ map(/* @__PURE__ */ functorReaderT(/* @__PURE__ */ functorExceptT(functorIdentity)));
var apply4 = /* @__PURE__ */ apply(/* @__PURE__ */ applyReaderT(/* @__PURE__ */ applyExceptT(monadIdentity)));
var bind17 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(/* @__PURE__ */ bindExceptT(monadIdentity)));
var un3 = /* @__PURE__ */ un();
var map113 = /* @__PURE__ */ map(functorMaybe);
var compare6 = /* @__PURE__ */ compare(ordChar);
var compare15 = /* @__PURE__ */ compare(ordString);
var apply1 = /* @__PURE__ */ apply(applyEffect);
var map211 = /* @__PURE__ */ map(functorEffect);
var append15 = /* @__PURE__ */ append(semigroupArray);
var pure24 = /* @__PURE__ */ pure(applicativeEffect);
var over3 = /* @__PURE__ */ over()();
var map34 = /* @__PURE__ */ map(freeFunctor);
var bimap2 = /* @__PURE__ */ bimap(bifunctorStep);
var ParserFailure = function(x) {
  return x;
};
var Internal = /* @__PURE__ */ function() {
  function Internal2() {
  }
  ;
  Internal2.value = new Internal2();
  return Internal2;
}();
var Hidden = /* @__PURE__ */ function() {
  function Hidden2() {
  }
  ;
  Hidden2.value = new Hidden2();
  return Hidden2;
}();
var Visible = /* @__PURE__ */ function() {
  function Visible2() {
  }
  ;
  Visible2.value = new Visible2();
  return Visible2;
}();
var Leaf2 = /* @__PURE__ */ function() {
  function Leaf3(value0) {
    this.value0 = value0;
  }
  ;
  Leaf3.create = function(value0) {
    return new Leaf3(value0);
  };
  return Leaf3;
}();
var MultNode = /* @__PURE__ */ function() {
  function MultNode2(value0) {
    this.value0 = value0;
  }
  ;
  MultNode2.create = function(value0) {
    return new MultNode2(value0);
  };
  return MultNode2;
}();
var AltNode = /* @__PURE__ */ function() {
  function AltNode2(value0) {
    this.value0 = value0;
  }
  ;
  AltNode2.create = function(value0) {
    return new AltNode2(value0);
  };
  return AltNode2;
}();
var OptProperties = function(x) {
  return x;
};
var OptShort = /* @__PURE__ */ function() {
  function OptShort2(value0) {
    this.value0 = value0;
  }
  ;
  OptShort2.create = function(value0) {
    return new OptShort2(value0);
  };
  return OptShort2;
}();
var OptLong = /* @__PURE__ */ function() {
  function OptLong2(value0) {
    this.value0 = value0;
  }
  ;
  OptLong2.create = function(value0) {
    return new OptLong2(value0);
  };
  return OptLong2;
}();
var OptHelpInfo = function(x) {
  return x;
};
var CmdStart = /* @__PURE__ */ function() {
  function CmdStart2() {
  }
  ;
  CmdStart2.value = new CmdStart2();
  return CmdStart2;
}();
var CmdCont = /* @__PURE__ */ function() {
  function CmdCont2() {
  }
  ;
  CmdCont2.value = new CmdCont2();
  return CmdCont2;
}();
var CompletionResult = function(x) {
  return x;
};
var Success2 = /* @__PURE__ */ function() {
  function Success3(value0) {
    this.value0 = value0;
  }
  ;
  Success3.create = function(value0) {
    return new Success3(value0);
  };
  return Success3;
}();
var Failure = /* @__PURE__ */ function() {
  function Failure2(value0) {
    this.value0 = value0;
  }
  ;
  Failure2.create = function(value0) {
    return new Failure2(value0);
  };
  return Failure2;
}();
var CompletionInvoked = /* @__PURE__ */ function() {
  function CompletionInvoked2(value0) {
    this.value0 = value0;
  }
  ;
  CompletionInvoked2.create = function(value0) {
    return new CompletionInvoked2(value0);
  };
  return CompletionInvoked2;
}();
var Completer = function(x) {
  return x;
};
var Backtrack = /* @__PURE__ */ function() {
  function Backtrack2() {
  }
  ;
  Backtrack2.value = new Backtrack2();
  return Backtrack2;
}();
var NoBacktrack = /* @__PURE__ */ function() {
  function NoBacktrack2() {
  }
  ;
  NoBacktrack2.value = new NoBacktrack2();
  return NoBacktrack2;
}();
var SubparserInline = /* @__PURE__ */ function() {
  function SubparserInline2() {
  }
  ;
  SubparserInline2.value = new SubparserInline2();
  return SubparserInline2;
}();
var ParserPrefs = function(x) {
  return x;
};
var Intersperse = /* @__PURE__ */ function() {
  function Intersperse2() {
  }
  ;
  Intersperse2.value = new Intersperse2();
  return Intersperse2;
}();
var NoIntersperse = /* @__PURE__ */ function() {
  function NoIntersperse2() {
  }
  ;
  NoIntersperse2.value = new NoIntersperse2();
  return NoIntersperse2;
}();
var AllPositionals = /* @__PURE__ */ function() {
  function AllPositionals2() {
  }
  ;
  AllPositionals2.value = new AllPositionals2();
  return AllPositionals2;
}();
var ForwardOptions = /* @__PURE__ */ function() {
  function ForwardOptions2() {
  }
  ;
  ForwardOptions2.value = new ForwardOptions2();
  return ForwardOptions2;
}();
var ParserInfo = function(x) {
  return x;
};
var NilP = /* @__PURE__ */ function() {
  function NilP2(value0) {
    this.value0 = value0;
  }
  ;
  NilP2.create = function(value0) {
    return new NilP2(value0);
  };
  return NilP2;
}();
var OptP = /* @__PURE__ */ function() {
  function OptP2(value0) {
    this.value0 = value0;
  }
  ;
  OptP2.create = function(value0) {
    return new OptP2(value0);
  };
  return OptP2;
}();
var MultP = /* @__PURE__ */ function() {
  function MultP2(value0) {
    this.value0 = value0;
  }
  ;
  MultP2.create = function(value0) {
    return new MultP2(value0);
  };
  return MultP2;
}();
var AltP = /* @__PURE__ */ function() {
  function AltP2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AltP2.create = function(value0) {
    return function(value12) {
      return new AltP2(value0, value12);
    };
  };
  return AltP2;
}();
var BindP = /* @__PURE__ */ function() {
  function BindP2(value0) {
    this.value0 = value0;
  }
  ;
  BindP2.create = function(value0) {
    return new BindP2(value0);
  };
  return BindP2;
}();
var Option = function(x) {
  return x;
};
var OptReader = /* @__PURE__ */ function() {
  function OptReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  OptReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new OptReader2(value0, value12, value22);
      };
    };
  };
  return OptReader2;
}();
var FlagReader = /* @__PURE__ */ function() {
  function FlagReader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlagReader2.create = function(value0) {
    return function(value12) {
      return new FlagReader2(value0, value12);
    };
  };
  return FlagReader2;
}();
var ArgReader = /* @__PURE__ */ function() {
  function ArgReader2(value0) {
    this.value0 = value0;
  }
  ;
  ArgReader2.create = function(value0) {
    return new ArgReader2(value0);
  };
  return ArgReader2;
}();
var CmdReader = /* @__PURE__ */ function() {
  function CmdReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  CmdReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new CmdReader2(value0, value12, value22);
      };
    };
  };
  return CmdReader2;
}();
var CReader = function(x) {
  return x;
};
var ReadM = function(x) {
  return x;
};
var ErrorMsg = /* @__PURE__ */ function() {
  function ErrorMsg2(value0) {
    this.value0 = value0;
  }
  ;
  ErrorMsg2.create = function(value0) {
    return new ErrorMsg2(value0);
  };
  return ErrorMsg2;
}();
var InfoMsg = /* @__PURE__ */ function() {
  function InfoMsg2(value0) {
    this.value0 = value0;
  }
  ;
  InfoMsg2.create = function(value0) {
    return new InfoMsg2(value0);
  };
  return InfoMsg2;
}();
var ShowHelpText = /* @__PURE__ */ function() {
  function ShowHelpText2() {
  }
  ;
  ShowHelpText2.value = new ShowHelpText2();
  return ShowHelpText2;
}();
var MissingError = /* @__PURE__ */ function() {
  function MissingError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MissingError2.create = function(value0) {
    return function(value12) {
      return new MissingError2(value0, value12);
    };
  };
  return MissingError2;
}();
var ExpectsArgError = /* @__PURE__ */ function() {
  function ExpectsArgError2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectsArgError2.create = function(value0) {
    return new ExpectsArgError2(value0);
  };
  return ExpectsArgError2;
}();
var UnexpectedError = /* @__PURE__ */ function() {
  function UnexpectedError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  UnexpectedError2.create = function(value0) {
    return function(value12) {
      return new UnexpectedError2(value0, value12);
    };
  };
  return UnexpectedError2;
}();
var SomeParser = /* @__PURE__ */ function() {
  function SomeParser2(value0) {
    this.value0 = value0;
  }
  ;
  SomeParser2.create = function(value0) {
    return new SomeParser2(value0);
  };
  return SomeParser2;
}();
var MultPE = /* @__PURE__ */ function() {
  function MultPE2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MultPE2.create = function(value0) {
    return function(value12) {
      return new MultPE2(value0, value12);
    };
  };
  return MultPE2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Context2.create = function(value0) {
    return function(value12) {
      return new Context2(value0, value12);
    };
  };
  return Context2;
}();
var ParserM = function(x) {
  return x;
};
var readerAsk = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadExceptT3));
var readerAbort = /* @__PURE__ */ function() {
  var $478 = lift(monadTransReaderT)(monadExceptT3);
  var $479 = throwError(monadThrowExceptT(monadIdentity));
  return function($480) {
    return ReadM($478($479($480)));
  };
}();
var readerError = function($481) {
  return readerAbort(ErrorMsg.create($481));
};
var readMFunctor = {
  map: function(f) {
    return function(v) {
      return map30(f)(v);
    };
  }
};
var map42 = /* @__PURE__ */ map(readMFunctor);
var readMApply = {
  apply: function(v) {
    return function(v1) {
      return apply4(v)(v1);
    };
  },
  Functor0: function() {
    return readMFunctor;
  }
};
var readMBind = {
  bind: function(v) {
    return function(f) {
      return bind17(v)(function() {
        var $482 = un3(ReadM);
        return function($483) {
          return $482(f($483));
        };
      }());
    };
  },
  Apply0: function() {
    return readMApply;
  }
};
var readMApplicative = {
  pure: /* @__PURE__ */ function() {
    var $484 = pure(applicativeReaderT(applicativeExceptT(monadIdentity)));
    return function($485) {
      return ReadM($484($485));
    };
  }(),
  Apply0: function() {
    return readMApply;
  }
};
var parserMMonadRec = freeMonadRec;
var tailRecM4 = /* @__PURE__ */ tailRecM(parserMMonadRec);
var parserMBind = freeBind;
var bind18 = /* @__PURE__ */ bind(parserMBind);
var parserMApplicative = freeApplicative;
var pure111 = /* @__PURE__ */ pure(parserMApplicative);
var parseErrorSemigroup = {
  append: function(v) {
    return function(m) {
      return m;
    };
  }
};
var optional2 = function(dictAlt) {
  var alt22 = alt(dictAlt);
  var map102 = map(dictAlt.Functor0());
  return function(dictApplicative) {
    var pure35 = pure(dictApplicative);
    return function(a) {
      return alt22(map102(Just.create)(a))(pure35(Nothing.value));
    };
  };
};
var optVisibilityEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return true;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return true;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return true;
      }
      ;
      return false;
    };
  }
};
var optVisibilityOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return EQ.value;
      }
      ;
      if (x instanceof Internal) {
        return LT.value;
      }
      ;
      if (y instanceof Internal) {
        return GT.value;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return EQ.value;
      }
      ;
      if (x instanceof Hidden) {
        return LT.value;
      }
      ;
      if (y instanceof Hidden) {
        return GT.value;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optVisibilityEq;
  }
};
var optShowDefault = /* @__PURE__ */ function() {
  var $486 = un3(OptProperties);
  var $487 = un3(Option);
  return function($488) {
    return function(v) {
      return v.propShowDefault;
    }($486(function(v) {
      return v.optProps;
    }($487($488))));
  };
}();
var optVisibility = /* @__PURE__ */ function() {
  var $489 = un3(OptProperties);
  var $490 = un3(Option);
  return function($491) {
    return function(v) {
      return v.propVisibility;
    }($489(function(v) {
      return v.optProps;
    }($490($491))));
  };
}();
var optNameEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var optNameOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return compare6(x.value0)(y.value0);
      }
      ;
      if (x instanceof OptShort) {
        return LT.value;
      }
      ;
      if (y instanceof OptShort) {
        return GT.value;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return compare15(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optNameEq;
  }
};
var optMetaVar = /* @__PURE__ */ function() {
  var $492 = un3(OptProperties);
  var $493 = un3(Option);
  return function($494) {
    return function(v) {
      return v.propMetaVar;
    }($492(function(v) {
      return v.optProps;
    }($493($494))));
  };
}();
var optHelp = /* @__PURE__ */ function() {
  var $495 = un3(OptProperties);
  var $496 = un3(Option);
  return function($497) {
    return function(v) {
      return v.propHelp;
    }($495(function(v) {
      return v.optProps;
    }($496($497))));
  };
}();
var optDescMod = /* @__PURE__ */ function() {
  var $498 = un3(OptProperties);
  var $499 = un3(Option);
  return function($500) {
    return function(v) {
      return v.propDescMod;
    }($498(function(v) {
      return v.optProps;
    }($499($500))));
  };
}();
var oneM = function($501) {
  return ParserM(liftF($501));
};
var fromM = function(v) {
  return new BindP(v);
};
var completerSemigroup = {
  append: function(v) {
    return function(v1) {
      return function(s) {
        return apply1(map211(append15)(v(s)))(v1(s));
      };
    };
  }
};
var completerMonoid = {
  mempty: function(v) {
    return pure24([]);
  },
  Semigroup0: function() {
    return completerSemigroup;
  }
};
var cReaderFunctor = {
  map: function(f) {
    return over3(CReader)(function(r) {
      return {
        crCompleter: r.crCompleter,
        crReader: map42(f)(r.crReader)
      };
    });
  }
};
var map82 = /* @__PURE__ */ map(cReaderFunctor);
var parserInfoFunctor = {
  map: function(f) {
    return over3(ParserInfo)(function(i) {
      return {
        infoFailureCode: i.infoFailureCode,
        infoFooter: i.infoFooter,
        infoFullDesc: i.infoFullDesc,
        infoHeader: i.infoHeader,
        infoPolicy: i.infoPolicy,
        infoProgDesc: i.infoProgDesc,
        infoParser: map(parserFunctor)(f)(i.infoParser)
      };
    });
  }
};
var parserFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return new NilP(v(v1.value0));
      }
      ;
      if (v1 instanceof OptP) {
        return new OptP(map(optionFunctor)(v)(v1.value0));
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          return new MultP(mkExists(new MultPE(map(parserFunctor)(function(v3) {
            return function($502) {
              return v(v3($502));
            };
          })(v2.value0), v2.value1)));
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return new AltP(map(parserFunctor)(v)(v1.value0), map(parserFunctor)(v)(v1.value1));
      }
      ;
      if (v1 instanceof BindP) {
        return new BindP(map34(v)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 317, column 1 - line 322, column 36): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var optionFunctor = {
  map: function(f) {
    return over3(Option)(function(o) {
      return {
        optProps: o.optProps,
        optMain: map(optReaderFunctor)(f)(o.optMain)
      };
    });
  }
};
var optReaderFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof OptReader) {
        return new OptReader(v1.value0, map82(v)(v1.value1), v1.value2);
      }
      ;
      if (v1 instanceof FlagReader) {
        return new FlagReader(v1.value0, v(v1.value1));
      }
      ;
      if (v1 instanceof ArgReader) {
        return new ArgReader(map82(v)(v1.value0));
      }
      ;
      if (v1 instanceof CmdReader) {
        return new CmdReader(v1.value0, v1.value1, function() {
          var $503 = map113(map(parserInfoFunctor)(v));
          return function($504) {
            return $503(v1.value2($504));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 264, column 1 - line 268, column 68): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var map92 = /* @__PURE__ */ map(parserFunctor);
var parserAlt = /* @__PURE__ */ function() {
  return {
    alt: AltP.create,
    Functor0: function() {
      return parserFunctor;
    }
  };
}();
var alt1 = /* @__PURE__ */ alt(parserAlt);
var parserApply = {
  apply: function(a) {
    return function(b) {
      return new MultP(mkExists(new MultPE(a, b)));
    };
  },
  Functor0: function() {
    return parserFunctor;
  }
};
var parserApplicative = /* @__PURE__ */ function() {
  return {
    pure: NilP.create,
    Apply0: function() {
      return parserApply;
    }
  };
}();
var pure25 = /* @__PURE__ */ pure(parserApplicative);
var manyM = function(p) {
  var go = function(acc) {
    return bind18(oneM(alt1(map92(Loop.create)(p))(pure25(new Done(unit)))))(function(aa) {
      return pure111(bimap2(function(v) {
        return new Cons(v, acc);
      })(function(v) {
        return reverse2(acc);
      })(aa));
    });
  };
  return tailRecM4(go)(Nil.value);
};
var many2 = function($505) {
  return fromM(manyM($505));
};
var argPolicyEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Intersperse && y instanceof Intersperse) {
        return true;
      }
      ;
      if (x instanceof NoIntersperse && y instanceof NoIntersperse) {
        return true;
      }
      ;
      if (x instanceof AllPositionals && y instanceof AllPositionals) {
        return true;
      }
      ;
      if (x instanceof ForwardOptions && y instanceof ForwardOptions) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Options.Applicative.Internal/index.js
var $runtime_lazy9 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var un4 = /* @__PURE__ */ un();
var map31 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorStateT(/* @__PURE__ */ functorReaderT(functorIdentity))));
var monadReaderT2 = /* @__PURE__ */ monadReaderT(monadIdentity);
var monadStateT2 = /* @__PURE__ */ monadStateT(monadReaderT2);
var apply5 = /* @__PURE__ */ apply(/* @__PURE__ */ applyExceptT(monadStateT2));
var bind19 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadStateT2));
var pure26 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadStateT2));
var altExceptT2 = /* @__PURE__ */ altExceptT(parseErrorSemigroup);
var alt11 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadStateT2));
var lift6 = /* @__PURE__ */ lift(monadTransExceptT);
var lift1 = /* @__PURE__ */ lift6(monadStateT2);
var modify_4 = /* @__PURE__ */ modify_2(/* @__PURE__ */ monadStateStateT(monadReaderT2));
var lift23 = /* @__PURE__ */ lift(monadTransStateT);
var throwError5 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadStateT2));
var map114 = /* @__PURE__ */ map(functorArray);
var pure112 = /* @__PURE__ */ pure(applicativeArray);
var discard8 = /* @__PURE__ */ discard(discardUnit);
var identity16 = /* @__PURE__ */ identity(categoryFn);
var TNil = /* @__PURE__ */ function() {
  function TNil2() {
  }
  ;
  TNil2.value = new TNil2();
  return TNil2;
}();
var TCons = /* @__PURE__ */ function() {
  function TCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TCons2.create = function(value0) {
    return function(value12) {
      return new TCons2(value0, value12);
    };
  };
  return TCons2;
}();
var P = function(x) {
  return x;
};
var ListT = function(x) {
  return x;
};
var NondetT = function(x) {
  return x;
};
var ComplParser = /* @__PURE__ */ function() {
  function ComplParser2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ComplParser2.create = function(value0) {
    return function(value12) {
      return new ComplParser2(value0, value12);
    };
  };
  return ComplParser2;
}();
var ComplOption = /* @__PURE__ */ function() {
  function ComplOption2(value0) {
    this.value0 = value0;
  }
  ;
  ComplOption2.create = function(value0) {
    return new ComplOption2(value0);
  };
  return ComplOption2;
}();
var ComplResult = /* @__PURE__ */ function() {
  function ComplResult2(value0) {
    this.value0 = value0;
  }
  ;
  ComplResult2.create = function(value0) {
    return new ComplResult2(value0);
  };
  return ComplResult2;
}();
var Completion = function(x) {
  return x;
};
var withReadM = function(f) {
  var f$prime = function(v) {
    if (v instanceof ErrorMsg) {
      return new ErrorMsg(f(v.value0));
    }
    ;
    return v;
  };
  var $298 = mapReaderT(withExcept(f$prime));
  var $299 = un4(ReadM);
  return function($300) {
    return ReadM($298($299($300)));
  };
};
var stepListT = function(v) {
  return v;
};
var runP2 = function(v) {
  return runReader(flip(runStateT)([])(runExceptT(v)));
};
var runNondetT = function(v) {
  return v;
};
var runListT = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var liftM12 = liftM1(dictMonad);
  return function(xs) {
    return bind210(stepListT(xs))(function(s) {
      if (s instanceof TNil) {
        return pure42(Nil.value);
      }
      ;
      if (s instanceof TCons) {
        return liftM12(Cons.create(s.value0))(runListT(dictMonad)(s.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 200, column 3 - line 202, column 53): " + [s.constructor.name]);
    });
  };
};
var runCompletion = function(v) {
  return function(prefs2) {
    var v1 = runReaderT(runExceptT(v))(prefs2);
    if (v1 instanceof ComplResult) {
      return Nothing.value;
    }
    ;
    if (v1 instanceof ComplParser) {
      return new Just(new Left(new Tuple(v1.value0, v1.value1)));
    }
    ;
    if (v1 instanceof ComplOption) {
      return new Just(new Right(v1.value0));
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Internal (line 170, column 38 - line 173, column 42): " + [v1.constructor.name]);
  };
};
var pFunctor = {
  map: function(f) {
    return function(v) {
      return map31(f)(v);
    };
  }
};
var pApply = {
  apply: function(v) {
    return function(v1) {
      return apply5(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var pBind = {
  bind: function(v) {
    return function(k) {
      return bind19(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return pApply;
  }
};
var pApplicative = {
  pure: function(a) {
    return pure26(a);
  },
  Apply0: function() {
    return pApply;
  }
};
var pMonad = {
  Applicative0: function() {
    return pApplicative;
  },
  Bind1: function() {
    return pBind;
  }
};
var pAlt = {
  alt: function(v) {
    return function(v1) {
      return alt11(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var missingArgP = function(dict) {
  return dict.missingArgP;
};
var getPrefs = function(dict) {
  return dict.getPrefs;
};
var exitP = function(dict) {
  return dict.exitP;
};
var exitContext = function(dict) {
  return dict.exitContext;
};
var errorP = function(dict) {
  return dict.errorP;
};
var hoistEither = function(dictMonadP) {
  return either(errorP(dictMonadP))(pure(dictMonadP.Monad0().Applicative0()));
};
var runReadM = function(dictMonadP) {
  var hoistEither1 = hoistEither(dictMonadP);
  return function(v) {
    return function(s) {
      return hoistEither1(runExcept(runReaderT(v)(s)));
    };
  };
};
var hoistMaybe = function(dictMonadP) {
  var errorP1 = errorP(dictMonadP);
  var pure42 = pure(dictMonadP.Monad0().Applicative0());
  return function(err) {
    return maybe(errorP1(err))(pure42);
  };
};
var pMonadP = {
  enterContext: function(name3) {
    return function(pinfo) {
      return lift1(modify_4(cons(new Context(name3, mkExists(pinfo)))));
    };
  },
  exitContext: /* @__PURE__ */ lift1(/* @__PURE__ */ modify_4(/* @__PURE__ */ drop(1))),
  getPrefs: /* @__PURE__ */ P(/* @__PURE__ */ lift1(/* @__PURE__ */ lift23(monadReaderT2)(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadIdentity))))),
  missingArgP: function(e) {
    return function(v) {
      return errorP(pMonadP)(e);
    };
  },
  exitP: function(i) {
    return function(v) {
      return function(p) {
        var $301 = maybe(throwError5(MissingError.create(i)(SomeParser.create(mkExists(p)))))(pure26);
        return function($302) {
          return P($301($302));
        };
      };
    };
  },
  errorP: function($303) {
    return P(throwError5($303));
  },
  Monad0: function() {
    return pMonad;
  },
  Alt1: function() {
    return pAlt;
  }
};
var enterContext = function(dict) {
  return dict.enterContext;
};
var contextNames = function(ns) {
  var go = function(v) {
    return v.value0;
  };
  return reverse(map114(go)(ns));
};
var complResultMonad = {
  Applicative0: function() {
    return complResultApplicative;
  },
  Bind1: function() {
    return complResultBind;
  }
};
var complResultBind = {
  bind: function(m) {
    return function(f) {
      if (m instanceof ComplResult) {
        return f(m.value0);
      }
      ;
      if (m instanceof ComplParser) {
        return new ComplParser(m.value0, m.value1);
      }
      ;
      if (m instanceof ComplOption) {
        return new ComplOption(m.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 134, column 14 - line 137, column 35): " + [m.constructor.name]);
    };
  },
  Apply0: function() {
    return $lazy_complResultApply(0);
  }
};
var complResultApplicative = /* @__PURE__ */ function() {
  return {
    pure: ComplResult.create,
    Apply0: function() {
      return $lazy_complResultApply(0);
    }
  };
}();
var $lazy_complResultFunctor = /* @__PURE__ */ $runtime_lazy9("complResultFunctor", "Options.Applicative.Internal", function() {
  return {
    map: liftM1(complResultMonad)
  };
});
var $lazy_complResultApply = /* @__PURE__ */ $runtime_lazy9("complResultApply", "Options.Applicative.Internal", function() {
  return {
    apply: ap(complResultMonad),
    Functor0: function() {
      return $lazy_complResultFunctor(0);
    }
  };
});
var complResultFunctor = /* @__PURE__ */ $lazy_complResultFunctor(124);
var map212 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorReaderT(complResultFunctor)));
var monadReaderT1 = /* @__PURE__ */ monadReaderT(complResultMonad);
var alt12 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadReaderT1));
var apply12 = /* @__PURE__ */ apply(/* @__PURE__ */ applyExceptT(monadReaderT1));
var pure27 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadReaderT1));
var bind110 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadReaderT1));
var lift32 = /* @__PURE__ */ lift6(monadReaderT1);
var lift43 = /* @__PURE__ */ lift(monadTransReaderT)(complResultMonad);
var completionFunctor = {
  map: function(f) {
    return function(v) {
      return map212(f)(v);
    };
  }
};
var completionAlt = {
  alt: function(v) {
    return function(v1) {
      return alt12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApply = {
  apply: function(v) {
    return function(v1) {
      return apply12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApplicative = {
  pure: function(a) {
    return pure27(a);
  },
  Apply0: function() {
    return completionApply;
  }
};
var pure32 = /* @__PURE__ */ pure(completionApplicative);
var completionBind = {
  bind: function(v) {
    return function(k) {
      return bind110(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return completionApply;
  }
};
var completionMonad = {
  Applicative0: function() {
    return completionApplicative;
  },
  Bind1: function() {
    return completionBind;
  }
};
var completionMonadP = {
  enterContext: function(v) {
    return function(v1) {
      return pure32(unit);
    };
  },
  exitContext: /* @__PURE__ */ pure32(unit),
  getPrefs: /* @__PURE__ */ lift32(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(complResultMonad))),
  missingArgP: function(v) {
    return function($304) {
      return Completion(lift32(lift43(ComplOption.create($304))));
    };
  },
  exitP: function(v) {
    return function(a) {
      return function(p) {
        return function(v1) {
          return Completion(lift32(lift43(new ComplParser(new SomeParser(mkExists(p)), a))));
        };
      };
    };
  },
  errorP: /* @__PURE__ */ function() {
    var $305 = throwError(monadThrowExceptT(monadReaderT1));
    return function($306) {
      return Completion($305($306));
    };
  }(),
  Monad0: function() {
    return completionMonad;
  },
  Alt1: function() {
    return completionAlt;
  }
};
var bimapTStep = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof TNil) {
        return TNil.value;
      }
      ;
      if (v2 instanceof TCons) {
        return new TCons(v(v2.value0), v1(v2.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 186, column 1 - line 186, column 77): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var listTFunctor = function(dictMonad) {
  var liftM12 = liftM1(dictMonad);
  return {
    map: function(f) {
      return function(v) {
        return liftM12(bimapTStep(f)(map(listTFunctor(dictMonad))(f)))(stepListT(v));
      };
    }
  };
};
var listTAlt = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    alt: function(xs) {
      return function(ys) {
        return bind210(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return stepListT(ys);
          }
          ;
          if (s instanceof TCons) {
            return pure42(new TCons(s.value0, alt(listTAlt(dictMonad))(s.value1)(ys)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 227, column 5 - line 229, column 49): " + [s.constructor.name]);
        });
      };
    },
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTPlus = function(dictMonad) {
  var listTAlt1 = listTAlt(dictMonad);
  return {
    empty: pure(dictMonad.Applicative0())(TNil.value),
    Alt0: function() {
      return listTAlt1;
    }
  };
};
var hoistList = function(dictMonad) {
  var pure42 = pure(dictMonad.Applicative0());
  return foldr2(function(x) {
    return function(xt) {
      return pure42(new TCons(x, xt));
    };
  })(empty(listTPlus(dictMonad)));
};
var listTMonadTrans = {
  lift: function(dictMonad) {
    var empty10 = empty(listTPlus(dictMonad));
    var $307 = liftM1(dictMonad)(function(v) {
      return new TCons(v, empty10);
    });
    return function($308) {
      return ListT($307($308));
    };
  }
};
var lift52 = /* @__PURE__ */ lift(listTMonadTrans);
var cut = function(dictMonad) {
  return lift52(monadStateT(dictMonad))(put(monadStateStateT(dictMonad))(true));
};
var nondetTMonadTrans = {
  lift: function(dictMonad) {
    var $309 = lift52(monadStateT(dictMonad));
    var $310 = lift23(dictMonad);
    return function($311) {
      return NondetT($309($310($311)));
    };
  }
};
var listTMonad = function(dictMonad) {
  return {
    Applicative0: function() {
      return listTApplicative(dictMonad);
    },
    Bind1: function() {
      return listTBind(dictMonad);
    }
  };
};
var listTBind = function(dictMonad) {
  var bind210 = bind(dictMonad.Bind1());
  var pure42 = pure(dictMonad.Applicative0());
  var alt22 = alt(listTAlt(dictMonad));
  return {
    bind: function(xs) {
      return function(f) {
        return bind210(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return pure42(TNil.value);
          }
          ;
          if (s instanceof TCons) {
            return stepListT(alt22(f(s.value0))(bind(listTBind(dictMonad))(s.value1)(f)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 218, column 5 - line 220, column 53): " + [s.constructor.name]);
        });
      };
    },
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTApply = function(dictMonad) {
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    apply: ap(listTMonad(dictMonad)),
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTApplicative = function(dictMonad) {
  return {
    pure: function() {
      var $312 = hoistList(dictMonad);
      return function($313) {
        return $312(pure112($313));
      };
    }(),
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTAlternative = function(dictMonad) {
  var listTApplicative1 = listTApplicative(dictMonad);
  var listTPlus1 = listTPlus(dictMonad);
  return {
    Applicative0: function() {
      return listTApplicative1;
    },
    Plus1: function() {
      return listTPlus1;
    }
  };
};
var nondetTAltOp = function(dictMonad) {
  var monadStateT1 = monadStateT(dictMonad);
  var alt22 = alt(listTAlt(monadStateT1));
  var listTBind1 = listTBind(monadStateT1);
  var bind210 = bind(listTBind1);
  var lift62 = lift52(monadStateT1);
  var get3 = get(monadStateStateT(dictMonad));
  var discard16 = discard8(listTBind1);
  var guard11 = guard2(listTAlternative(monadStateT1));
  return function(m1) {
    return function(m2) {
      return NondetT(alt22(runNondetT(m1))(bind210(lift62(get3))(function(s) {
        return discard16(guard11(!s))(function() {
          return runNondetT(m2);
        });
      })));
    };
  };
};
var nondetTFunctor = function(dictMonad) {
  var map311 = map(listTFunctor(monadStateT(dictMonad)));
  return {
    map: function(f) {
      var $314 = map311(f);
      return function($315) {
        return NondetT($314(runNondetT($315)));
      };
    }
  };
};
var nondetTAlt = function(dictMonad) {
  var alt22 = alt(listTAlt(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    alt: function(v) {
      return function(v1) {
        return alt22(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTPlus = function(dictMonad) {
  var nondetTAlt1 = nondetTAlt(dictMonad);
  return {
    empty: empty(listTPlus(monadStateT(dictMonad))),
    Alt0: function() {
      return nondetTAlt1;
    }
  };
};
var nondetTApply = function(dictMonad) {
  var apply22 = apply(listTApply(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    apply: function(v) {
      return function(v1) {
        return apply22(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTApplicative = function(dictMonad) {
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    pure: function() {
      var $316 = pure(listTApplicative(monadStateT(dictMonad)));
      return function($317) {
        return NondetT($316($317));
      };
    }(),
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var nondetTBind = function(dictMonad) {
  var bind210 = bind(listTBind(monadStateT(dictMonad)));
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    bind: function(v) {
      return function(f) {
        return bind210(v)(function($318) {
          return runNondetT(f($318));
        });
      };
    },
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var takeListT = function(dictMonad) {
  var empty10 = empty(listTPlus(dictMonad));
  var liftM12 = liftM1(dictMonad);
  return function(v) {
    if (v === 0) {
      return $$const(empty10);
    }
    ;
    var $319 = liftM12(bimapTStep(identity16)(takeListT(dictMonad)(v - 1 | 0)));
    return function($320) {
      return ListT($319(stepListT($320)));
    };
  };
};
var disamb = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var bind210 = bind(Bind1);
  var evalStateT2 = evalStateT(Bind1.Apply0().Functor0());
  var monadStateT1 = monadStateT(dictMonad);
  var runListT1 = runListT(monadStateT1);
  var takeListT1 = takeListT(monadStateT1);
  var pure42 = pure(dictMonad.Applicative0());
  return function(allow_amb) {
    return function(xs) {
      return bind210(function(v) {
        return evalStateT2(v)(false);
      }(runListT1(takeListT1(function() {
        if (allow_amb) {
          return 1;
        }
        ;
        return 2;
      }())(runNondetT(xs)))))(function(xs$prime) {
        return pure42(function() {
          if (xs$prime instanceof Cons && xs$prime.value1 instanceof Nil) {
            return new Just(xs$prime.value0);
          }
          ;
          return Nothing.value;
        }());
      });
    };
  };
};

// output/Options.Applicative.Common/index.js
var bind20 = /* @__PURE__ */ bind(bindArray);
var fromFoldable17 = /* @__PURE__ */ fromFoldable(foldableList);
var map35 = /* @__PURE__ */ map(functorMaybe);
var voidRight4 = /* @__PURE__ */ voidRight(functorMaybe);
var guard9 = /* @__PURE__ */ guard2(alternativeMaybe);
var any5 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var elem4 = /* @__PURE__ */ elem(foldableArray)(optNameEq);
var discard9 = /* @__PURE__ */ discard(discardUnit);
var discard14 = /* @__PURE__ */ discard9(bindMaybe);
var un5 = /* @__PURE__ */ un();
var lift7 = /* @__PURE__ */ lift(monadTransStateT);
var apply6 = /* @__PURE__ */ apply(applyMaybe);
var alt13 = /* @__PURE__ */ alt(altMaybe);
var bind111 = /* @__PURE__ */ bind(bindMaybe);
var apply13 = /* @__PURE__ */ apply(parserApply);
var oneOf3 = /* @__PURE__ */ oneOf(foldableArray);
var bind24 = /* @__PURE__ */ bind(freeBind);
var greaterThan3 = /* @__PURE__ */ greaterThan(optVisibilityOrd);
var lift12 = /* @__PURE__ */ lift(nondetTMonadTrans);
var pure28 = /* @__PURE__ */ pure(parserApplicative);
var pure113 = /* @__PURE__ */ pure(applicativeMaybe);
var notEq1 = /* @__PURE__ */ notEq(argPolicyEq);
var OptWord = /* @__PURE__ */ function() {
  function OptWord2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OptWord2.create = function(value0) {
    return function(value12) {
      return new OptWord2(value0, value12);
    };
  };
  return OptWord2;
}();
var unexpectedError = function(arg) {
  return function(p) {
    return new UnexpectedError(arg, new SomeParser(mkExists(p)));
  };
};
var simplify = function(v) {
  if (v instanceof Leaf2) {
    return new Leaf2(v.value0);
  }
  ;
  if (v instanceof MultNode) {
    var remove_mult = function(v12) {
      if (v12 instanceof MultNode) {
        return v12.value0;
      }
      ;
      return [v12];
    };
    var v1 = bind20(v.value0)(function($340) {
      return remove_mult(simplify($340));
    });
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new MultNode(v1);
  }
  ;
  if (v instanceof AltNode) {
    var remove_alt = function(v12) {
      if (v12 instanceof AltNode) {
        return v12.value0;
      }
      ;
      if (v12 instanceof MultNode && v12.value0.length === 0) {
        return [];
      }
      ;
      return [v12];
    };
    var v1 = bind20(v.value0)(function($341) {
      return remove_alt(simplify($341));
    });
    if (v1.length === 0) {
      return new MultNode([]);
    }
    ;
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new AltNode(v1);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 280, column 1 - line 280, column 45): " + [v.constructor.name]);
};
var showOption = function(v) {
  if (v instanceof OptLong) {
    return "--" + v.value0;
  }
  ;
  if (v instanceof OptShort) {
    return fromCharArray(["-", v.value0]);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 43, column 1 - line 43, column 32): " + [v.constructor.name]);
};
var parseWord = /* @__PURE__ */ function() {
  var go = function(v) {
    if (v instanceof Cons && (v.value0 === "-" && (v.value1 instanceof Cons && v.value1.value0 === "-"))) {
      return new Just(function() {
        var v1 = function() {
          var v2 = span2(function(v3) {
            return v3 !== "=";
          })(v.value1.value1);
          if (v2.rest instanceof Nil) {
            return new Tuple(v.value1.value1, Nothing.value);
          }
          ;
          if (v2.rest instanceof Cons) {
            return new Tuple(v2.init, new Just(v2.rest.value1));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 107, column 23 - line 109, column 70): " + [v2.constructor.name]);
        }();
        return new OptWord(new OptLong(fromCharArray(fromFoldable17(v1.value0))), map35(function($342) {
          return fromCharArray(fromFoldable17($342));
        })(v1.value1));
      }());
    }
    ;
    if (v instanceof Cons && v.value0 === "-") {
      if (v.value1 instanceof Nil) {
        return Nothing.value;
      }
      ;
      if (v.value1 instanceof Cons) {
        return new Just(function() {
          var arg = voidRight4(v.value1.value1)(guard9(!$$null4(v.value1.value1)));
          return new OptWord(new OptShort(v.value1.value0), map35(function($343) {
            return fromCharArray(fromFoldable17($343));
          })(arg));
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 111, column 25 - line 115, column 79): " + [v.value1.constructor.name]);
    }
    ;
    return Nothing.value;
  };
  var $344 = fromFoldable6(foldableArray);
  return function($345) {
    return go($344(toCharArray($345)));
  };
}();
var optionNames = function(v) {
  if (v instanceof OptReader) {
    return v.value0;
  }
  ;
  if (v instanceof FlagReader) {
    return v.value0;
  }
  ;
  return [];
};
var liftOpt = /* @__PURE__ */ function() {
  return OptP.create;
}();
var isOptionPrefix = function(v) {
  return function(v1) {
    if (v instanceof OptShort && v1 instanceof OptShort) {
      return v.value0 === v1.value0;
    }
    ;
    if (v instanceof OptLong && v1 instanceof OptLong) {
      return startsWith(v.value0)(v1.value0);
    }
    ;
    return false;
  };
};
var optMatches = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bindStateT3 = bindStateT(Monad0);
  var bind32 = bind(bindStateT3);
  var monadStateStateT2 = monadStateStateT(Monad0);
  var get3 = get(monadStateStateT2);
  var missingArgP2 = missingArgP(dictMonadP);
  var lift24 = lift7(Monad0);
  var pure210 = pure(applicativeStateT(Monad0));
  var discard25 = discard9(bindStateT3);
  var put2 = put(monadStateStateT2);
  var runReadM2 = runReadM(dictMonadP);
  return function(disambiguate) {
    return function(opt) {
      return function(v) {
        var is_short = function(v1) {
          if (v1 instanceof OptShort) {
            return true;
          }
          ;
          if (v1 instanceof OptLong) {
            return false;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 90, column 5 - line 90, column 33): " + [v1.constructor.name]);
        };
        var has_name = function(a) {
          if (disambiguate) {
            return any5(isOptionPrefix(a));
          }
          ;
          if (otherwise) {
            return elem4(a);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 93, column 5 - line 95, column 27): " + [a.constructor.name]);
        };
        var errorFor = function(name3) {
          return function(msg) {
            return "option " + (showOption(name3) + (": " + msg));
          };
        };
        if (opt instanceof OptReader) {
          return discard14(guard9(has_name(v.value0)(opt.value0)))(function() {
            return new Just(bind32(get3)(function(args) {
              var missing_arg = missingArgP2(opt.value2(showOption(v.value0)))(un5(CReader)(opt.value1).crCompleter);
              return bind32(function() {
                var v1 = maybe(args)(function(v2) {
                  return new Cons(v2, args);
                })(v.value1);
                if (v1 instanceof Nil) {
                  return lift24(missing_arg);
                }
                ;
                if (v1 instanceof Cons) {
                  return pure210(new Tuple(v1.value0, v1.value1));
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 68, column 27 - line 70, column 56): " + [v1.constructor.name]);
              }())(function(v1) {
                return discard25(put2(v1.value1))(function() {
                  return lift24(runReadM2(withReadM(errorFor(v.value0))(un5(CReader)(opt.value1).crReader))(v1.value0));
                });
              });
            }));
          });
        }
        ;
        if (opt instanceof FlagReader) {
          return discard14(guard9(has_name(v.value0)(opt.value0)))(function() {
            return discard14(guard9(is_short(v.value0) || isNothing(v.value1)))(function() {
              return new Just(bind32(get3)(function(args) {
                var val$prime = map35(function($346) {
                  return function(s) {
                    return cons("-")(s);
                  }(toCharArray($346));
                })(v.value1);
                return discard25(put2(maybe(args)(function() {
                  var $347 = flip(Cons.create)(args);
                  return function($348) {
                    return $347(fromCharArray($348));
                  };
                }())(val$prime)))(function() {
                  return pure210(opt.value1);
                });
              }));
            });
          });
        }
        ;
        return Nothing.value;
      };
    };
  };
};
var isArg = function(v) {
  if (v instanceof ArgReader) {
    return true;
  }
  ;
  return false;
};
var evalParser = function(v) {
  if (v instanceof NilP) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof OptP) {
    return Nothing.value;
  }
  ;
  if (v instanceof MultP) {
    return runExists(function(v1) {
      return apply6(evalParser(v1.value0))(evalParser(v1.value1));
    })(v.value0);
  }
  ;
  if (v instanceof AltP) {
    return alt13(evalParser(v.value0))(evalParser(v.value1));
  }
  ;
  if (v instanceof BindP) {
    return resume$prime(function(p) {
      return function(k) {
        return bind111(evalParser(p))(function($349) {
          return evalParser(BindP.create(k($349)));
        });
      };
    })(Just.create)(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 220, column 1 - line 220, column 44): " + [v.constructor.name]);
};
var searchParser = function(dictMonad) {
  var nondetTPlus2 = nondetTPlus(dictMonad);
  var empty10 = empty(nondetTPlus2);
  var mapFlipped7 = mapFlipped(nondetTFunctor(dictMonad));
  var nondetTAltOp2 = nondetTAltOp(dictMonad);
  var oneOf1 = oneOf3(nondetTPlus2);
  return function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return empty10;
      }
      ;
      if (v1 instanceof OptP) {
        return v(v1.value0);
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          var b = mapFlipped7(searchParser(dictMonad)(v)(v2.value1))(function(p2$prime) {
            return apply13(v2.value0)(p2$prime);
          });
          var a = mapFlipped7(searchParser(dictMonad)(v)(v2.value0))(function(p1$prime) {
            return apply13(p1$prime)(v2.value1);
          });
          return nondetTAltOp2(a)(b);
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return oneOf1([searchParser(dictMonad)(v)(v1.value0), searchParser(dictMonad)(v)(v1.value1)]);
      }
      ;
      if (v1 instanceof BindP) {
        return resume$prime(function(p) {
          return function(k) {
            return oneOf1([mapFlipped7(searchParser(dictMonad)(v)(p))(function(p$prime) {
              return new BindP(bind24(liftF(p$prime))(k));
            }), function() {
              var v2 = evalParser(p);
              if (v2 instanceof Nothing) {
                return empty10;
              }
              ;
              if (v2 instanceof Just) {
                return searchParser(dictMonad)(v)(new BindP(k(v2.value0)));
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Common (line 135, column 7 - line 137, column 49): " + [v2.constructor.name]);
            }()]);
          };
        })($$const(empty10))(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 118, column 1 - line 120, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var searchOpt = function(dictMonadP) {
  var monadStateT3 = monadStateT(dictMonadP.Monad0());
  var searchParser1 = searchParser(monadStateT3);
  var optMatches1 = optMatches(dictMonadP);
  var lift24 = lift12(monadStateT3);
  var map118 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var empty10 = empty(nondetTPlus(monadStateT3));
  return function(pprefs) {
    return function(w) {
      return searchParser1(function(opt) {
        var disambiguate = un5(ParserPrefs)(pprefs).prefDisambiguate && greaterThan3(optVisibility(opt))(Internal.value);
        var v = optMatches1(disambiguate)(un5(Option)(opt).optMain)(w);
        if (v instanceof Just) {
          return lift24(map118(pure28)(v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return empty10;
        }
        ;
        throw new Error("Failed pattern match at Options.Applicative.Common (line 144, column 3 - line 146, column 21): " + [v.constructor.name]);
      });
    };
  };
};
var stepParser = function(dictMonadP) {
  var alt19 = alt(nondetTAlt(monadStateT(dictMonadP.Monad0())));
  var searchOpt1 = searchOpt(dictMonadP);
  return function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          if (v1 instanceof AllPositionals) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          if (v1 instanceof ForwardOptions) {
            var v42 = parseWord(v2);
            if (v42 instanceof Just) {
              return alt19(searchOpt1(v)(v42.value0)(v3))(searchArg(dictMonadP)(v)(v2)(v3));
            }
            ;
            if (v42 instanceof Nothing) {
              return searchArg(dictMonadP)(v)(v2)(v3);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 174, column 42 - line 176, column 36): " + [v42.constructor.name]);
          }
          ;
          var v42 = parseWord(v2);
          if (v42 instanceof Just) {
            return searchOpt1(v)(v42.value0)(v3);
          }
          ;
          if (v42 instanceof Nothing) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 177, column 29 - line 179, column 36): " + [v42.constructor.name]);
        };
      };
    };
  };
};
var searchArg = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var monadStateT3 = monadStateT(Monad0);
  var searchParser1 = searchParser(monadStateT3);
  var discard25 = discard9(nondetTBind(monadStateT3));
  var when9 = when(nondetTApplicative(monadStateT3));
  var cut2 = cut(monadStateT3);
  var lift24 = lift12(monadStateT3);
  var bindStateT3 = bindStateT(Monad0);
  var bind32 = bind(bindStateT3);
  var applyFirst2 = applyFirst(applyStateT(Monad0));
  var monadStateStateT2 = monadStateStateT(Monad0);
  var get3 = get(monadStateStateT2);
  var put2 = put(monadStateStateT2);
  var map118 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var lift33 = lift7(Monad0);
  var Apply0 = Monad0.Bind1().Apply0();
  var applyFirst1 = applyFirst(Apply0);
  var applySecond3 = applySecond(Apply0);
  var enterContext2 = enterContext(dictMonadP);
  var exitContext2 = exitContext(dictMonadP);
  var map215 = map(nondetTFunctor(monadStateT3));
  var discard33 = discard9(bindStateT3);
  var pure210 = pure(applicativeStateT(Monad0));
  var empty10 = empty(nondetTPlus(monadStateT3));
  var runReadM2 = runReadM(dictMonadP);
  return function(prefs2) {
    return function(arg) {
      return searchParser1(function(opt) {
        return discard25(when9(isArg(un5(Option)(opt).optMain))(cut2))(function() {
          var v = un5(Option)(opt).optMain;
          if (v instanceof CmdReader) {
            var v1 = new Tuple(v.value2(arg), un5(ParserPrefs)(prefs2).prefBacktrack);
            if (v1.value0 instanceof Just && v1.value1 instanceof NoBacktrack) {
              return lift24(bind32(applyFirst2(get3)(put2(Nil.value)))(function(args) {
                return map118(pure28)(lift33(applyFirst1(applySecond3(enterContext2(arg)(v1.value0.value0))(runParserInfo(dictMonadP)(v1.value0.value0)(args)))(exitContext2)));
              }));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof Backtrack) {
              return map215(pure28)(lift24(StateT(function(args) {
                return applyFirst1(applySecond3(enterContext2(arg)(v1.value0.value0))(runParser2(dictMonadP)(un5(ParserInfo)(v1.value0.value0).infoPolicy)(CmdStart.value)(un5(ParserInfo)(v1.value0.value0).infoParser)(args)))(exitContext2);
              })));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof SubparserInline) {
              return lift24(discard33(lift33(enterContext2(arg)(v1.value0.value0)))(function() {
                return pure210(un5(ParserInfo)(v1.value0.value0).infoParser);
              }));
            }
            ;
            if (v1.value0 instanceof Nothing) {
              return empty10;
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 154, column 7 - line 166, column 38): " + [v1.constructor.name]);
          }
          ;
          if (v instanceof ArgReader) {
            return map215(pure28)(lift24(lift33(runReadM2(un5(CReader)(v.value0).crReader)(arg))));
          }
          ;
          return empty10;
        });
      });
    };
  };
};
var runParserInfo = function(dictMonadP) {
  return function(i) {
    return runParserFully(dictMonadP)(un5(ParserInfo)(i).infoPolicy)(un5(ParserInfo)(i).infoParser);
  };
};
var runParserFully = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bind32 = bind(Monad0.Bind1());
  var pure210 = pure(Monad0.Applicative0());
  var errorP2 = errorP(dictMonadP);
  return function(policy) {
    return function(p) {
      return function(args) {
        return bind32(runParser2(dictMonadP)(policy)(CmdStart.value)(p)(args))(function(v) {
          if (v.value1 instanceof Nil) {
            return pure210(v.value0);
          }
          ;
          if (v.value1 instanceof Cons) {
            return errorP2(unexpectedError(v.value1.value0)(pure28(unit)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 214, column 3 - line 216, column 66): " + [v.value1.constructor.name]);
        });
      };
    };
  };
};
var runParser2 = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var disamb2 = disamb(monadStateT(Monad0));
  var exitP2 = exitP(dictMonadP);
  var bind32 = bind(Monad0.Bind1());
  var getPrefs2 = getPrefs(dictMonadP);
  var hoistMaybe2 = hoistMaybe(dictMonadP);
  return function(policy) {
    return function(isCmdStart) {
      return function(p) {
        return function(args) {
          var result = apply6(map35(Tuple.create)(evalParser(p)))(pure113(args));
          var newPolicy = function(a) {
            if (policy instanceof NoIntersperse) {
              var $299 = isJust(parseWord(a));
              if ($299) {
                return NoIntersperse.value;
              }
              ;
              return AllPositionals.value;
            }
            ;
            return policy;
          };
          var do_step = function(prefs2) {
            return function(arg) {
              return function(argt) {
                return function(v) {
                  return runStateT(v)(argt);
                }(disamb2(!un5(ParserPrefs)(prefs2).prefDisambiguate)(stepParser(dictMonadP)(prefs2)(policy)(arg)(p)));
              };
            };
          };
          if (args instanceof Nil) {
            return exitP2(isCmdStart)(policy)(p)(result);
          }
          ;
          if (args instanceof Cons && (args.value0 === "--" && notEq1(policy)(AllPositionals.value))) {
            return runParser2(dictMonadP)(AllPositionals.value)(CmdCont.value)(p)(args.value1);
          }
          ;
          if (args instanceof Cons) {
            return bind32(getPrefs2)(function(prefs2) {
              return bind32(do_step(prefs2)(args.value0)(args.value1))(function(v) {
                if (v.value0 instanceof Nothing) {
                  return hoistMaybe2(unexpectedError(args.value0)(p))(result);
                }
                ;
                if (v.value0 instanceof Just) {
                  return runParser2(dictMonadP)(newPolicy(args.value0))(CmdCont.value)(v.value0.value0)(v.value1);
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 192, column 5 - line 194, column 60): " + [v.value0.constructor.name]);
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 186, column 38 - line 194, column 60): " + [args.constructor.name]);
        };
      };
    };
  };
};
var treeMapParser = function(g) {
  var has_default = function(p) {
    return isJust(evalParser(p));
  };
  var hasArg = function(v) {
    if (v instanceof NilP) {
      return false;
    }
    ;
    if (v instanceof OptP) {
      return isArg(un5(Option)(v.value0).optMain);
    }
    ;
    if (v instanceof MultP) {
      return runExists(function(v1) {
        return hasArg(v1.value0) || hasArg(v1.value1);
      })(v.value0);
    }
    ;
    if (v instanceof AltP) {
      return hasArg(v.value0) || hasArg(v.value1);
    }
    ;
    if (v instanceof BindP) {
      return resume$prime(function(p) {
        return function(v1) {
          return hasArg(p);
        };
      })($$const(false))(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 272, column 5 - line 272, column 44): " + [v.constructor.name]);
  };
  var go = function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return function(v42) {
            if (v42 instanceof NilP) {
              return new MultNode([]);
            }
            ;
            if (v42 instanceof OptP) {
              if (greaterThan3(optVisibility(v42.value0))(Internal.value)) {
                return new Leaf2(v3({
                  hinfoMulti: v,
                  hinfoDefault: v1,
                  hinfoUnreachableArgs: v2
                })(v42.value0));
              }
              ;
              if (otherwise) {
                return new MultNode([]);
              }
              ;
            }
            ;
            if (v42 instanceof MultP) {
              return runExists(function(v5) {
                var r$prime = v2 || hasArg(v5.value0);
                return new MultNode([go(v)(v1)(v2)(v3)(v5.value0), go(v)(v1)(r$prime)(v3)(v5.value1)]);
              })(v42.value0);
            }
            ;
            if (v42 instanceof AltP) {
              var d$prime = v1 || (has_default(v42.value0) || has_default(v42.value1));
              return new AltNode([go(v)(d$prime)(v2)(v3)(v42.value0), go(v)(d$prime)(v2)(v3)(v42.value1)]);
            }
            ;
            if (v42 instanceof BindP) {
              return resume$prime(function(p) {
                return function(k) {
                  var go$prime = go(true)(v1)(v2)(v3)(p);
                  var v5 = evalParser(p);
                  if (v5 instanceof Nothing) {
                    return go$prime;
                  }
                  ;
                  if (v5 instanceof Just) {
                    return new MultNode([go$prime, go(true)(v1)(v2)(v3)(new BindP(k(v5.value0)))]);
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.Common (line 267, column 12 - line 269, column 68): " + [v5.constructor.name]);
                };
              })($$const(new MultNode([])))(v42.value0);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 248, column 5 - line 251, column 21): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name, v42.constructor.name]);
          };
        };
      };
    };
  };
  var $350 = go(false)(false)(false)(g);
  return function($351) {
    return simplify($350($351));
  };
};
var mapParser = function(f) {
  var flatten2 = function(v) {
    if (v instanceof Leaf2) {
      return [v.value0];
    }
    ;
    if (v instanceof MultNode) {
      return bind20(v.value0)(flatten2);
    }
    ;
    if (v instanceof AltNode) {
      return bind20(v.value0)(flatten2);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 235, column 5 - line 235, column 27): " + [v.constructor.name]);
  };
  var $352 = treeMapParser(f);
  return function($353) {
    return flatten2($352($353));
  };
};

// output/Options.Applicative.Builder.Internal/index.js
var over4 = /* @__PURE__ */ over()();
var append8 = /* @__PURE__ */ append(semigroupArray);
var map36 = /* @__PURE__ */ map(functorArray);
var lookup7 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var alt14 = /* @__PURE__ */ alt(altMaybe);
var identity17 = /* @__PURE__ */ identity(categoryFn);
var apply7 = /* @__PURE__ */ apply(applyMaybe);
var alt15 = /* @__PURE__ */ alt(parserAlt);
var pure29 = /* @__PURE__ */ pure(parserApplicative);
var OptionFields = function(x) {
  return x;
};
var FlagFields = function(x) {
  return x;
};
var DefaultProp = /* @__PURE__ */ function() {
  function DefaultProp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DefaultProp2.create = function(value0) {
    return function(value12) {
      return new DefaultProp2(value0, value12);
    };
  };
  return DefaultProp2;
}();
var Mod = /* @__PURE__ */ function() {
  function Mod2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Mod2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Mod2(value0, value12, value22);
      };
    };
  };
  return Mod2;
}();
var CommandFields = function(x) {
  return x;
};
var optionFieldsHasValue = {
  hasValueDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasName = {
  name: function(n) {
    return over4(OptionFields)(function(fields) {
      return {
        optCompleter: fields.optCompleter,
        optNoArgError: fields.optNoArgError,
        optNames: append8([n])(fields.optNames)
      };
    });
  }
};
var name2 = function(dict) {
  return dict.name;
};
var mkCommand = function(m) {
  var v = m.value0({
    cmdCommands: [],
    cmdGroup: Nothing.value
  });
  return new Tuple(v.cmdGroup, new Tuple(map36(fst)(v.cmdCommands), new Tuple(function(v1) {
    return lookup7(v1)(v.cmdCommands);
  }, unit)));
};
var flagFieldsHasName = {
  name: function(n) {
    return over4(FlagFields)(function(fields) {
      return {
        flagActive: fields.flagActive,
        flagNames: append8([n])(fields.flagNames)
      };
    });
  }
};
var defaultPropSemigroup = {
  append: function(v) {
    return function(v1) {
      return new DefaultProp(alt14(v.value0)(v1.value0), alt14(v.value1)(v1.value1));
    };
  }
};
var append16 = /* @__PURE__ */ append(defaultPropSemigroup);
var modSemigroup = {
  append: function(v) {
    return function(v1) {
      return new Mod(function($69) {
        return v1.value0(v.value0($69));
      }, append16(v1.value1)(v.value1), function($70) {
        return v1.value2(v.value2($70));
      });
    };
  }
};
var defaultPropMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new DefaultProp(Nothing.value, Nothing.value),
    Semigroup0: function() {
      return defaultPropSemigroup;
    }
  };
}();
var mempty7 = /* @__PURE__ */ mempty(defaultPropMonoid);
var fieldMod = function(f) {
  return new Mod(f, mempty7, identity17);
};
var modMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new Mod(identity17, mempty7, identity17),
    Semigroup0: function() {
      return modSemigroup;
    }
  };
}();
var optionMod = /* @__PURE__ */ function() {
  return Mod.create(identity17)(mempty7);
}();
var internal = /* @__PURE__ */ optionMod(/* @__PURE__ */ over4(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: Internal.value
  };
}));
var commandFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var baseProps = /* @__PURE__ */ function() {
  return {
    propMetaVar: "",
    propVisibility: Visible.value,
    propHelp: mempty(chunkMonoid(docSemigroup)),
    propShowDefault: Nothing.value,
    propDescMod: Nothing.value
  };
}();
var mkProps = function(v) {
  return function(g) {
    var props = over4(OptProperties)(function(r) {
      return {
        propDescMod: r.propDescMod,
        propHelp: r.propHelp,
        propMetaVar: r.propMetaVar,
        propVisibility: r.propVisibility,
        propShowDefault: apply7(v.value1)(v.value0)
      };
    })(g(baseProps));
    return props;
  };
};
var mkOption = function(d) {
  return function(g) {
    return function(rdr) {
      return {
        optMain: rdr,
        optProps: mkProps(d)(g)
      };
    };
  };
};
var mkParser = function(v) {
  return function(g) {
    return function(rdr) {
      var o = liftOpt(mkOption(v)(g)(rdr));
      return maybe(o)(function(a) {
        return alt15(o)(pure29(a));
      })(v.value0);
    };
  };
};
var argumentFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};

// output/Options.Applicative.Builder/index.js
var identity18 = /* @__PURE__ */ identity(categoryFn);
var over5 = /* @__PURE__ */ over()();
var un6 = /* @__PURE__ */ un();
var append9 = /* @__PURE__ */ append(modSemigroup);
var mempty8 = /* @__PURE__ */ mempty(completerMonoid);
var bind21 = /* @__PURE__ */ bind(readMBind);
var pure30 = /* @__PURE__ */ pure(readMApplicative);
var mempty12 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var min4 = /* @__PURE__ */ min(optVisibilityOrd);
var alt16 = /* @__PURE__ */ alt(parserAlt);
var pure114 = /* @__PURE__ */ pure(parserApplicative);
var show10 = /* @__PURE__ */ show(showString);
var append32 = /* @__PURE__ */ append(semigroupArray);
var mempty22 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "argCompleter";
  }
})(completerMonoid)()(monoidRecordNil)));
var fold9 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var PrefsMod = function(x) {
  return x;
};
var InfoMod = function(x) {
  return x;
};
var value = function(dictHasValue) {
  return function(x) {
    return new Mod(identity18, new DefaultProp(new Just(x), Nothing.value), identity18);
  };
};
var value1 = /* @__PURE__ */ value(optionFieldsHasValue);
var subparserInline = /* @__PURE__ */ over5(ParserPrefs)(function(p) {
  return {
    prefColumns: p.prefColumns,
    prefDisambiguate: p.prefDisambiguate,
    prefMultiSuffix: p.prefMultiSuffix,
    prefShowHelpOnEmpty: p.prefShowHelpOnEmpty,
    prefShowHelpOnError: p.prefShowHelpOnError,
    prefBacktrack: SubparserInline.value
  };
});
var str = readerAsk;
var showHelpOnError = /* @__PURE__ */ over5(ParserPrefs)(function(p) {
  return {
    prefBacktrack: p.prefBacktrack,
    prefColumns: p.prefColumns,
    prefDisambiguate: p.prefDisambiguate,
    prefMultiSuffix: p.prefMultiSuffix,
    prefShowHelpOnEmpty: p.prefShowHelpOnEmpty,
    prefShowHelpOnError: true
  };
});
var $$short = function(dictHasName) {
  var $121 = name2(dictHasName);
  return function($122) {
    return fieldMod($121(OptShort.create($122)));
  };
};
var progDesc = function(s) {
  return over5(ParserInfo)(function(i) {
    return {
      infoFailureCode: i.infoFailureCode,
      infoFooter: i.infoFooter,
      infoFullDesc: i.infoFullDesc,
      infoHeader: i.infoHeader,
      infoParser: i.infoParser,
      infoPolicy: i.infoPolicy,
      infoProgDesc: paragraph(s)
    };
  });
};
var noArgError = function(e) {
  return fieldMod(over5(OptionFields)(function(p) {
    return {
      optCompleter: p.optCompleter,
      optNames: p.optNames,
      optNoArgError: $$const(e)
    };
  }));
};
var prefs = function(m) {
  var base = {
    prefMultiSuffix: "",
    prefDisambiguate: false,
    prefShowHelpOnError: false,
    prefShowHelpOnEmpty: false,
    prefBacktrack: Backtrack.value,
    prefColumns: 80
  };
  return un6(PrefsMod)(m)(base);
};
var prefsModSemigroup = {
  append: function(m1) {
    return function(m2) {
      var $123 = un6(PrefsMod)(m2);
      var $124 = un6(PrefsMod)(m1);
      return function($125) {
        return $123($124($125));
      };
    };
  }
};
var metavar = function(dictHasMetavar) {
  return function($$var) {
    return optionMod(over5(OptProperties)(function(p) {
      return {
        propDescMod: p.propDescMod,
        propHelp: p.propHelp,
        propShowDefault: p.propShowDefault,
        propVisibility: p.propVisibility,
        propMetaVar: $$var
      };
    }));
  };
};
var metavar1 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var metavar2 = /* @__PURE__ */ metavar(commandFieldsHasMetavar);
var option2 = function(r) {
  return function(m) {
    var v = append9(metavar1("ARG"))(m);
    var v1 = v.value0({
      optNames: [],
      optCompleter: mempty8,
      optNoArgError: ExpectsArgError.create
    });
    var crdr = {
      crCompleter: v1.optCompleter,
      crReader: r
    };
    var rdr = new OptReader(v1.optNames, crdr, v1.optNoArgError);
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var strOption = /* @__PURE__ */ option2(str);
var subparser = function(m) {
  var v = append9(metavar2("COMMAND"))(m);
  var v1 = mkCommand(m);
  var rdr = new CmdReader(v1.value0, v1.value1.value0, v1.value1.value1.value0);
  return mkParser(v.value1)(v.value2)(rdr);
};
var $$long = function(dictHasName) {
  var $126 = name2(dictHasName);
  return function($127) {
    return fieldMod($126(OptLong.create($127)));
  };
};
var info3 = function(parser) {
  return function(m) {
    var base = {
      infoParser: parser,
      infoFullDesc: true,
      infoProgDesc: mempty12,
      infoHeader: mempty12,
      infoFooter: mempty12,
      infoFailureCode: $$Error.value,
      infoPolicy: Intersperse.value
    };
    return un6(InfoMod)(m)(base);
  };
};
var hidden = /* @__PURE__ */ optionMod(/* @__PURE__ */ over5(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: min4(Hidden.value)(p.propVisibility)
  };
}));
var help = function(s) {
  return optionMod(over5(OptProperties)(function(p) {
    return {
      propDescMod: p.propDescMod,
      propMetaVar: p.propMetaVar,
      propShowDefault: p.propShowDefault,
      propVisibility: p.propVisibility,
      propHelp: paragraph(s)
    };
  }));
};
var flag$prime = function(actv) {
  return function(v) {
    var rdr = function() {
      var v1 = v.value0({
        flagNames: [],
        flagActive: actv
      });
      return new FlagReader(v1.flagNames, v1.flagActive);
    }();
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var flag = function(defv) {
  return function(actv) {
    return function(m) {
      return alt16(flag$prime(actv)(m))(pure114(defv));
    };
  };
};
var $$switch = /* @__PURE__ */ flag(false)(true);
var eitherReader = function(f) {
  return bind21(readerAsk)(function() {
    var $131 = either(readerError)(pure30);
    return function($132) {
      return $131(f($132));
    };
  }());
};
var $$int2 = /* @__PURE__ */ eitherReader(function(s) {
  var v = fromString2(s);
  if (v instanceof Nothing) {
    return new Left("Can't parse as Int: `" + (show10(s) + "`"));
  }
  ;
  if (v instanceof Just) {
    return new Right(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Builder (line 124, column 28 - line 126, column 20): " + [v.constructor.name]);
});
var command = function(cmd) {
  return function(pinfo) {
    return fieldMod(over5(CommandFields)(function(p) {
      return {
        cmdGroup: p.cmdGroup,
        cmdCommands: append32([new Tuple(cmd, pinfo)])(p.cmdCommands)
      };
    }));
  };
};
var argument = function(p) {
  return function(v) {
    var v1 = v.value0(mempty22);
    var rdr = {
      crCompleter: v1.argCompleter,
      crReader: p
    };
    return mkParser(v.value1)(v.value2)(new ArgReader(rdr));
  };
};
var strArgument = /* @__PURE__ */ argument(str);
var abortOption = function(err) {
  return function(m) {
    return option2(readerAbort(err))(function(v) {
      return append9(v)(m);
    }(fold9([noArgError(err), value1(identity18), metavar1("")])));
  };
};

// output/Options.Applicative.BashCompletion/index.js
var pure31 = /* @__PURE__ */ pure(applicativeEffect);
var un7 = /* @__PURE__ */ un();
var map37 = /* @__PURE__ */ map(functorMaybe);
var map115 = /* @__PURE__ */ map(functorArray);
var runParserInfo2 = /* @__PURE__ */ runParserInfo(completionMonadP);
var fromFoldable18 = /* @__PURE__ */ fromFoldable6(foldableArray);
var identity19 = /* @__PURE__ */ identity(categoryFn);
var bind25 = /* @__PURE__ */ bind(bindMaybe);
var notEq4 = /* @__PURE__ */ notEq(argPolicyEq);
var map213 = /* @__PURE__ */ map(functorEffect);
var fold10 = /* @__PURE__ */ fold(foldableArray)(monoidArray);
var sequence2 = /* @__PURE__ */ sequence(traversableArray)(applicativeEffect);
var unLines2 = /* @__PURE__ */ unLines(foldableArray);
var alt17 = /* @__PURE__ */ alt(parserAlt);
var map38 = /* @__PURE__ */ map(parserFunctor);
var apply8 = /* @__PURE__ */ apply(parserApply);
var append17 = /* @__PURE__ */ append(modSemigroup);
var $$long2 = /* @__PURE__ */ $$long(flagFieldsHasName);
var long1 = /* @__PURE__ */ $$long(optionFieldsHasName);
var value2 = /* @__PURE__ */ value(optionFieldsHasValue);
var pure115 = /* @__PURE__ */ pure(parserApplicative);
var fromFoldable19 = /* @__PURE__ */ fromFoldable(foldableList);
var Standard = /* @__PURE__ */ function() {
  function Standard2() {
  }
  ;
  Standard2.value = new Standard2();
  return Standard2;
}();
var Enriched = /* @__PURE__ */ function() {
  function Enriched2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Enriched2.create = function(value0) {
    return function(value12) {
      return new Enriched2(value0, value12);
    };
  };
  return Enriched2;
}();
var zshCompletionScript = function(prog) {
  return function(progn) {
    return pure31(["#compdef " + progn, "", "local request", "local completions", "local word", "local index=$((CURRENT - 1))", "", "request=(--bash-completion-enriched --bash-completion-index $index)", "for arg in ${words[@]}; do", "  request=(${request[@]} --bash-completion-word $arg)", "done", "", "IFS=$'\\n' completions=($( " + (prog + ' "${request[@]}" ))'), "", "for word in $completions; do", "  local -a parts", "", "  # Split the line at a tab if there is one.", "  IFS=$'\\t' parts=($( echo $word ))", "", "  if [[ -n $parts[2] ]]; then", '     if [[ $word[1] == "-" ]]; then', '       local desc=("$parts[1] ($parts[2])")', "       compadd -d desc -- $parts[1]", "     else", '       local desc=($(print -f  "%-019s -- %s" $parts[1] $parts[2]))', "       compadd -l -d desc -- $parts[1]", "     fi", "  else", "    compadd -f -- $word", "  fi", "done"]);
  };
};
var fishCompletionScript = function(prog) {
  return function(progn) {
    return pure31([" function _" + progn, "    set -l cl (commandline --tokenize --current-process)", "    # Hack around fish issue #3934", "    set -l cn (commandline --tokenize --cut-at-cursor --current-process)", "    set -l cn (count $cn)", "    set -l tmpline --bash-completion-enriched --bash-completion-index $cn", "    for arg in $cl", "      set tmpline $tmpline --bash-completion-word $arg", "    end", "    for opt in (" + (prog + " $tmpline)"), "      if test -d $opt", '        echo -E "$opt/"', "      else", '        echo -E "$opt"', "      end", "    end", "end", "", "complete --no-files --command " + (progn + (" --arguments '(_" + (progn + ")'")))]);
  };
};
var bashCompletionScript = function(prog) {
  return function(progn) {
    return pure31(["_" + (progn + "()"), "{", "    local CMDLINE", "    local IFS=$'\\n'", "    CMDLINE=(--bash-completion-index $COMP_CWORD)", "", "    for arg in ${COMP_WORDS[@]}; do", "        CMDLINE=(${CMDLINE[@]} --bash-completion-word $arg)", "    done", "", "    COMPREPLY=( $(" + (prog + ' "${CMDLINE[@]}") )'), "}", "", "complete -o filenames -F _" + (progn + (" " + progn))]);
  };
};
var arraySplitAt = function(idx) {
  return function(arr) {
    if (idx === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    return {
      init: slice(0)(idx)(arr),
      rest: slice(idx)(length(arr))(arr)
    };
  };
};
var bashCompletionQuery = function(pinfo) {
  return function(pprefs) {
    return function(richness) {
      return function(ws) {
        return function(i) {
          return function(v) {
            var v1 = arraySplitAt(i)(ws);
            var run_completer = function(c) {
              return un7(Completer)(c)(fromMaybe("")(head(v1.rest)));
            };
            var render_line = function(len) {
              return function(doc) {
                var v22 = map37(uncons3)(fromArray3(lines(displayS(renderPretty(1)(len)(doc)))));
                if (v22 instanceof Nothing) {
                  return "";
                }
                ;
                if (v22 instanceof Just && v22.value0.tail.length === 0) {
                  return v22.value0.head;
                }
                ;
                if (v22 instanceof Just) {
                  return v22.value0.head + "...";
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 162, column 27 - line 165, column 43): " + [v22.constructor.name]);
              };
            };
            var is_completion = function() {
              var v22 = head(v1.rest);
              if (v22 instanceof Just) {
                return startsWith(v22.value0);
              }
              ;
              if (v22 instanceof Nothing) {
                return $$const(true);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 175, column 7 - line 177, column 30): " + [v22.constructor.name]);
            }();
            var filter_names = filter(is_completion);
            var show_names = function() {
              var $129 = map115(showOption);
              return function($130) {
                return filter_names($129($130));
              };
            }();
            var compl = runParserInfo2(pinfo)(fromFoldable18(drop(1)(v1.init)));
            var add_opt_help = function(dictFunctor) {
              var map44 = map(dictFunctor);
              return function(opt) {
                if (richness instanceof Standard) {
                  return identity19;
                }
                ;
                if (richness instanceof Enriched) {
                  return map44(function(o) {
                    var h = un7(Chunk)(optHelp(opt));
                    return maybe(o)(function(h$prime) {
                      return o + ("	" + render_line(richness.value0)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 138, column 24 - line 143, column 79): " + [richness.constructor.name]);
              };
            };
            var add_opt_help1 = add_opt_help(functorArray);
            var add_cmd_help = function(dictFunctor) {
              var map44 = map(dictFunctor);
              return function(p) {
                if (richness instanceof Standard) {
                  return identity19;
                }
                ;
                if (richness instanceof Enriched) {
                  return map44(function(cmd) {
                    var h = bind25(p(cmd))(function() {
                      var $131 = un7(Chunk);
                      var $132 = un7(ParserInfo);
                      return function($133) {
                        return $131(function(v22) {
                          return v22.infoProgDesc;
                        }($132($133)));
                      };
                    }());
                    return maybe(cmd)(function(h$prime) {
                      return cmd + ("	" + render_line(richness.value1)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 148, column 22 - line 153, column 85): " + [richness.constructor.name]);
              };
            };
            var add_cmd_help1 = add_cmd_help(functorArray);
            var opt_completions = function(argPolicy) {
              return function(hinfo) {
                return function(opt) {
                  var v22 = un7(Option)(opt).optMain;
                  if (v22 instanceof OptReader) {
                    if (notEq4(argPolicy)(AllPositionals.value)) {
                      return pure31(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure31([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof FlagReader) {
                    if (notEq4(argPolicy)(AllPositionals.value)) {
                      return pure31(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure31([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof ArgReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure31([]);
                    }
                    ;
                    if (otherwise) {
                      return run_completer(un7(CReader)(v22.value0).crCompleter);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof CmdReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure31([]);
                    }
                    ;
                    if (otherwise) {
                      return pure31(add_cmd_help1(v22.value2)(filter_names(v22.value1)));
                    }
                    ;
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 113, column 43 - line 133, column 53): " + [v22.constructor.name]);
                };
              };
            };
            var list_options = function(a) {
              var $134 = map213(fold10);
              var $135 = mapParser(opt_completions(a));
              return function($136) {
                return $134(sequence2($135($136)));
              };
            };
            var v2 = runCompletion(compl)(pprefs);
            if (v2 instanceof Just && v2.value0 instanceof Left) {
              return runExists(function(p) {
                return list_options(v2.value0.value0.value1)(p);
              })(v2.value0.value0.value0.value0);
            }
            ;
            if (v2 instanceof Just && v2.value0 instanceof Right) {
              return run_completer(v2.value0.value0);
            }
            ;
            if (v2 instanceof Nothing) {
              return pure31([]);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 83, column 52 - line 89, column 15): " + [v2.constructor.name]);
          };
        };
      };
    };
  };
};
var bashCompletionParser = function(pinfo) {
  return function(pprefs) {
    var failure = function(opts) {
      return {
        execCompletion: function(progn) {
          return map213(unLines2)(opts(progn));
        }
      };
    };
    var complParser = alt17(map38(failure)(apply8(apply8(map38(bashCompletionQuery(pinfo)(pprefs))(alt17(apply8(apply8(flag$prime(Enriched.create)(append17($$long2("bash-completion-enriched"))(internal)))(option2($$int2)(append17(append17(long1("bash-completion-option-desc-length"))(internal))(value2(40)))))(option2($$int2)(append17(append17(long1("bash-completion-command-desc-length"))(internal))(value2(40)))))(pure115(Standard.value))))(map38(fromFoldable19)(many2(strOption(append17(long1("bash-completion-word"))(internal))))))(option2($$int2)(append17(long1("bash-completion-index"))(internal)))))(alt17(map38(failure)(map38(bashCompletionScript)(strOption(append17(long1("bash-completion-script"))(internal)))))(alt17(map38(failure)(map38(fishCompletionScript)(strOption(append17(long1("fish-completion-script"))(internal)))))(map38(failure)(map38(zshCompletionScript)(strOption(append17(long1("zsh-completion-script"))(internal)))))));
    return complParser;
  };
};

// output/Options.Applicative.Help.Core/index.js
var over6 = /* @__PURE__ */ over()();
var mempty9 = /* @__PURE__ */ mempty(parserHelpMonoid);
var fold11 = /* @__PURE__ */ fold2(monoidArray);
var un8 = /* @__PURE__ */ un();
var chunkMonoid3 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var mempty13 = /* @__PURE__ */ mempty(chunkMonoid3);
var eq111 = /* @__PURE__ */ eq(optVisibilityEq);
var map39 = /* @__PURE__ */ map(functorArray);
var sort2 = /* @__PURE__ */ sort(optNameOrd);
var append10 = /* @__PURE__ */ append(/* @__PURE__ */ chunkSemigroup(docSemigroup));
var map116 = /* @__PURE__ */ map(chunkFunctor);
var listToChunk2 = /* @__PURE__ */ listToChunk(docMonoid);
var identity20 = /* @__PURE__ */ identity(categoryFn);
var map214 = /* @__PURE__ */ map(functorMaybe);
var discard10 = /* @__PURE__ */ discard(discardUnit)(bindMaybe);
var guard10 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure33 = /* @__PURE__ */ pure(applicativeMaybe);
var extractChunk3 = /* @__PURE__ */ extractChunk(docMonoid);
var bind26 = /* @__PURE__ */ bind(bindArray);
var pure116 = /* @__PURE__ */ pure(applicativeArray);
var mempty23 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidMaybe(semigroupString))(chunkMonoid3));
var append18 = /* @__PURE__ */ append(semigroupArray);
var eq25 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var OptDescStyle = function(x) {
  return x;
};
var usageHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: chunk
    };
  })(mempty9);
};
var suggestionsHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpUsage: v.helpUsage,
      helpSuggestions: chunk
    };
  })(mempty9);
};
var intersperse2 = function(sep2) {
  var $64 = mapWithIndex2(function(idx) {
    return function(e) {
      var $49 = idx === 0;
      if ($49) {
        return [e];
      }
      ;
      return [sep2, e];
    };
  });
  return function($65) {
    return fold11($64($65));
  };
};
var optDesc = function(pprefs) {
  return function(style) {
    return function(info4) {
      return function(opt) {
        var suffix = function() {
          if (un8(OptHelpInfo)(info4).hinfoMulti) {
            return stringChunk(un8(ParserPrefs)(pprefs).prefMultiSuffix);
          }
          ;
          if (otherwise) {
            return mempty13;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 58, column 7 - line 62, column 17): ");
        }();
        var show_opt = function() {
          if (un8(OptHelpInfo)(info4).hinfoDefault && !un8(OptDescStyle)(style).descOptional) {
            return false;
          }
          ;
          if (eq111(optVisibility(opt))(Hidden.value)) {
            return un8(OptDescStyle)(style).descHidden;
          }
          ;
          if (otherwise) {
            return eq111(optVisibility(opt))(Visible.value);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 51, column 7 - line 57, column 39): ");
        }();
        var ns = optionNames(un8(Option)(opt).optMain);
        var mv = stringChunk(optMetaVar(opt));
        var descs = map39(function($66) {
          return string3(showOption($66));
        })(sort2(ns));
        var render = function(chunk) {
          if (!show_opt) {
            return mempty13;
          }
          ;
          if (isEmpty3(chunk) || !un8(OptDescStyle)(style).descSurround) {
            return append10(chunk)(suffix);
          }
          ;
          if (un8(OptHelpInfo)(info4).hinfoDefault) {
            return append10(map116(brackets)(chunk))(suffix);
          }
          ;
          if ($$null(drop(1)(descs))) {
            return append10(chunk)(suffix);
          }
          ;
          if (otherwise) {
            return append10(map116(parens)(chunk))(suffix);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 63, column 7 - line 73, column 43): " + [chunk.constructor.name]);
        };
        var desc$prime = chunkBeside(listToChunk2(intersperse2(un8(OptDescStyle)(style).descSep)(descs)))(mv);
        return maybe(identity20)(map116)(optDescMod(opt))(render(desc$prime));
      };
    };
  };
};
var headerHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpHeader: chunk
    };
  })(mempty9);
};
var fullDesc = function(pprefs) {
  var style = {
    descSep: string3(","),
    descHidden: true,
    descOptional: true,
    descSurround: false
  };
  var doc = function(info4) {
    return function(opt) {
      var show_def = function(s) {
        return parens(appendWithSpace(string3("default:"))(string3(s)));
      };
      var n = optDesc(pprefs)(style)(info4)(opt);
      var hdef = map214(show_def)(optShowDefault(opt));
      var h = optHelp(opt);
      return discard10(guard10(!isEmpty3(n)))(function() {
        return discard10(guard10(!isEmpty3(h)))(function() {
          return pure33(new Tuple(extractChunk3(n), align(extractChunk3(chunkBeside(h)(hdef)))));
        });
      });
    };
  };
  var $67 = mapParser(doc);
  return function($68) {
    return tabulate(catMaybes($67($68)));
  };
};
var footerHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpFooter: chunk
    };
  })(mempty9);
};
var fold_tree = function(v) {
  if (v instanceof Leaf2) {
    return v.value0;
  }
  ;
  if (v instanceof MultNode) {
    return foldr2(function($69) {
      return chunkBesideOrBelow(fold_tree($69));
    })(mempty13)(v.value0);
  }
  ;
  if (v instanceof AltNode) {
    var alt_node = function(v1) {
      if (v1.length === 1) {
        return v1[0];
      }
      ;
      return map116(parens)(foldr2(chunked(function(x) {
        return function(y) {
          return appendWithSoftline(x)(appendWithSoftline($$char3("|"))(y));
        };
      }))(mempty13)(v1));
    };
    return alt_node(filter(function($70) {
      return !isEmpty3($70);
    })(map39(fold_tree)(v.value0)));
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 116, column 1 - line 116, column 46): " + [v.constructor.name]);
};
var errorHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpError: chunk
    };
  })(mempty9);
};
var cmdDesc = /* @__PURE__ */ function() {
  var desc = function(v) {
    return function(opt) {
      var v1 = un8(Option)(opt).optMain;
      if (v1 instanceof CmdReader) {
        return new Tuple(v1.value0, tabulate(bind26(reverse(v1.value1))(function(cmd) {
          return bind26(maybe([])(pure116)(map214(function() {
            var $71 = un8(ParserInfo);
            return function($72) {
              return function(v2) {
                return v2.infoProgDesc;
              }($71($72));
            };
          }())(v1.value2(cmd))))(function(d) {
            return pure116(new Tuple(string3(cmd), align(extractChunk3(d))));
          });
        })));
      }
      ;
      return mempty23;
    };
  };
  return mapParser(desc);
}();
var briefDesc$prime = function(showOptional) {
  return function(pprefs) {
    var style = {
      descSep: string3("|"),
      descHidden: false,
      descOptional: showOptional,
      descSurround: true
    };
    var $73 = treeMapParser(optDesc(pprefs)(style));
    return function($74) {
      return fold_tree($73($74));
    };
  };
};
var missingDesc = /* @__PURE__ */ briefDesc$prime(false);
var briefDesc = /* @__PURE__ */ briefDesc$prime(true);
var parserUsage = function(pprefs) {
  return function(p) {
    return function(progn) {
      return hsep([string3("Usage:"), string3(progn), align(extractChunk3(briefDesc(pprefs)(p)))]);
    };
  };
};
var bodyHelp = function(chunk) {
  return over6(ParserHelp)(function(v) {
    return {
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpBody: chunk
    };
  })(mempty9);
};
var parserHelp = function(pprefs) {
  return function(p) {
    var with_title = function(title2) {
      return map116(function(v) {
        return appendWithLine(string3(title2))(v);
      });
    };
    var group_title = function(arr) {
      var v = uncons3(arr);
      return with_title(fromMaybe("Available commands:")(fst(v.head)))(vcatChunks(append18([snd(v.head)])(map39(snd)(v.tail))));
    };
    var cs = groupBy(on(eq25)(fst))(cmdDesc(p));
    return bodyHelp(vsepChunks(append18([with_title("Available options:")(fullDesc(pprefs)(p))])(map39(group_title)(cs))));
  };
};

// output/Data.Function.Memoize/index.js
var bind27 = /* @__PURE__ */ bind(bindLazy);
var NatTrie = /* @__PURE__ */ function() {
  function NatTrie2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  NatTrie2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new NatTrie2(value0, value12, value22);
      };
    };
  };
  return NatTrie2;
}();
var tabulateNat = {
  tabulate: /* @__PURE__ */ function() {
    var tabulateImpl = function(f) {
      var walk = function(v) {
        return function(v1) {
          if (v instanceof Nil) {
            return v1.value0;
          }
          ;
          if (v instanceof Cons && !v.value0) {
            return bind27(v1.value1)(walk(v.value1));
          }
          ;
          if (v instanceof Cons && v.value0) {
            return bind27(v1.value2)(walk(v.value1));
          }
          ;
          throw new Error("Failed pattern match at Data.Function.Memoize (line 172, column 7 - line 172, column 60): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      var build = function(n) {
        return new NatTrie(defer2(function(v) {
          return f(n);
        }), defer2(function(v) {
          return build(n * 2 | 0);
        }), defer2(function(v) {
          return build((n * 2 | 0) + 1 | 0);
        }));
      };
      var trie = build(0);
      var bits = function() {
        var bits$prime = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 === 0) {
                $tco_done = true;
                return v;
              }
              ;
              $tco_var_v = new Cons((v1 & 1) !== 0, v);
              $copy_v1 = v1 >>> 1;
              return;
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return bits$prime(Nil.value);
      }();
      var go = function(n) {
        return walk(bits(n))(trie);
      };
      return go;
    };
    return tabulateImpl;
  }()
};
var tabulate2 = function(dict) {
  return dict.tabulate;
};
var tabulateTuple = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(dictTabulate1) {
    var tabulate4 = tabulate2(dictTabulate1);
    return {
      tabulate: function(f) {
        var f$prime = tabulate3(function(a) {
          return tabulate4(function(b) {
            return f(new Tuple(a, b));
          });
        });
        return function(v) {
          return bind27(f$prime(v.value0))(function(g) {
            return g(v.value1);
          });
        };
      }
    };
  };
};
var memoize = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(f) {
    var f1 = tabulate3(f);
    return function($141) {
      return force(f1($141));
    };
  };
};
var memoize2 = function(dictTabulate) {
  var tabulateTuple1 = tabulateTuple(dictTabulate);
  return function(dictTabulate1) {
    var memoize1 = memoize(tabulateTuple1(dictTabulate1));
    return function(f) {
      var f1 = memoize1(uncurry(f));
      return curry(f1);
    };
  };
};

// output/Options.Applicative.Help.Levenshtein/index.js
var $runtime_lazy10 = function(name3, moduleName, init3) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2) return val;
    if (state2 === 1) throw new ReferenceError(name3 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
    state2 = 1;
    val = init3();
    state2 = 2;
    return val;
  };
};
var memoize22 = /* @__PURE__ */ memoize2(tabulateNat)(tabulateNat);
var minimum3 = /* @__PURE__ */ minimum2(ordInt)(/* @__PURE__ */ foldable1NonEmpty(foldableArray));
var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();
var editDistance = function(dictEq) {
  var eq27 = eq(dictEq);
  return function(xs) {
    return function(ys) {
      var dist = function(v) {
        return function(v1) {
          if (v === 0) {
            return v1;
          }
          ;
          if (v1 === 0) {
            return v;
          }
          ;
          return minimum3(new NonEmpty($lazy_dist$prime(37)(v - 1 | 0)(v1) + 1 | 0, [$lazy_dist$prime(38)(v)(v1 - 1 | 0) + 1 | 0, function() {
            var $14 = eq27(unsafeIndex2(xs)(v - 1 | 0))(unsafeIndex2(ys)(v1 - 1 | 0));
            if ($14) {
              return $lazy_dist$prime(40)(v - 1 | 0)(v1 - 1 | 0);
            }
            ;
            return 1 + $lazy_dist$prime(41)(v - 1 | 0)(v1 - 1 | 0) | 0;
          }()]));
        };
      };
      var $lazy_dist$prime = $runtime_lazy10("dist'", "Options.Applicative.Help.Levenshtein", function() {
        return memoize22(function(a) {
          return function(b) {
            return dist(a)(b);
          };
        });
      });
      var dist$prime = $lazy_dist$prime(31);
      return dist$prime(length(xs))(length(ys));
    };
  };
};

// output/Options.Applicative.Extra/index.js
var un9 = /* @__PURE__ */ un();
var mempty10 = /* @__PURE__ */ mempty(parserHelpMonoid);
var pure34 = /* @__PURE__ */ pure(chunkApplicative);
var unWords2 = /* @__PURE__ */ unWords(foldableArray);
var append11 = /* @__PURE__ */ append(semigroupArray);
var map40 = /* @__PURE__ */ map(chunkFunctor);
var map117 = /* @__PURE__ */ map(functorArray);
var fold14 = /* @__PURE__ */ fold2(monoidArray);
var editDistance2 = /* @__PURE__ */ editDistance(eqChar);
var apply9 = /* @__PURE__ */ apply(chunkApply);
var mempty14 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var fold15 = /* @__PURE__ */ fold2(parserHelpMonoid);
var over7 = /* @__PURE__ */ over()();
var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorEffect);
var bind28 = /* @__PURE__ */ bind(bindMaybe);
var fromEnum8 = /* @__PURE__ */ fromEnum(boundedEnumExitCode);
var pure117 = /* @__PURE__ */ pure(applicativeEffect);
var bind112 = /* @__PURE__ */ bind(bindEffect);
var $$void12 = /* @__PURE__ */ $$void(functorEffect);
var alt18 = /* @__PURE__ */ alt(parserAlt);
var map310 = /* @__PURE__ */ map(parserFunctor);
var runParserInfo3 = /* @__PURE__ */ runParserInfo(pMonadP);
var fromFoldable20 = /* @__PURE__ */ fromFoldable6(foldableArray);
var map43 = /* @__PURE__ */ map(functorEffect);
var renderFailure = function(failure) {
  return function(progn) {
    var v = un9(ParserFailure)(failure)(progn);
    return new Tuple(renderHelp(v.value1.value1.value0)(v.value0), v.value1.value0);
  };
};
var parserFailure = function(pprefs) {
  return function(pinfo) {
    return function(msg) {
      return function(ctx) {
        var with_context = function(arr) {
          return function(i) {
            return function(f) {
              var v = head(arr);
              if (v instanceof Nothing) {
                return f([])(i);
              }
              ;
              if (v instanceof Just) {
                return runExists(function(i$prime) {
                  return f(contextNames(arr))(i$prime);
                })(v.value0.value1);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Extra (line 183, column 28 - line 185, column 73): " + [v.constructor.name]);
            };
          };
        };
        var usage_help = function(progn) {
          return function(names) {
            return function(v) {
              if (msg instanceof InfoMsg) {
                return mempty10;
              }
              ;
              return usageHelp(vcatChunks([pure34(parserUsage(pprefs)(v.infoParser)(unWords2(append11([progn])(names)))), map40(indent(2))(v.infoProgDesc)]));
            };
          };
        };
        var suggestion_help = suggestionsHelp(function() {
          if (msg instanceof UnexpectedError) {
            var opt_completions = function(v) {
              return function(v1) {
                if (v1.optMain instanceof OptReader) {
                  return map117(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof FlagReader) {
                  return map117(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof ArgReader) {
                  return [];
                }
                ;
                if (v1.optMain instanceof CmdReader) {
                  if (v.hinfoUnreachableArgs) {
                    return [];
                  }
                  ;
                  if (otherwise) {
                    return v1.optMain.value1;
                  }
                  ;
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Extra (line 273, column 64 - line 280, column 37): " + [v1.optMain.constructor.name]);
              };
            };
            var possibles = fold14(runExists(function(zz) {
              return mapParser(opt_completions)(zz);
            })(msg.value1.value0));
            var isClose = function(a) {
              return on(editDistance2)(toCharArray)(a)(msg.value0) < 3;
            };
            var good = filter(isClose)(possibles);
            var prose = function() {
              var $81 = length(good) < 2;
              if ($81) {
                return stringChunk("Did you mean this?");
              }
              ;
              return stringChunk("Did you mean one of these?");
            }();
            var suggestions = apply9(map40(appendWithLine)(prose))(map40(indent(4))(vcatChunks(map117(stringChunk)(good))));
            return suggestions;
          }
          ;
          return mempty14;
        }());
        var show_full_help = function() {
          if (msg instanceof ShowHelpText) {
            return true;
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return true;
          }
          ;
          return un9(ParserPrefs)(pprefs).prefShowHelpOnError;
        }();
        var exit_code = function() {
          if (msg instanceof ErrorMsg) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof MissingError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof UnexpectedError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ShowHelpText) {
            return Success.value;
          }
          ;
          if (msg instanceof InfoMsg) {
            return Success.value;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 171, column 17 - line 177, column 44): " + [msg.constructor.name]);
        }();
        var error_help = errorHelp(function() {
          if (msg instanceof ShowHelpText) {
            return mempty14;
          }
          ;
          if (msg instanceof ErrorMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof InfoMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return mempty14;
          }
          ;
          if (msg instanceof MissingError) {
            return runExists(function(x) {
              return chunkBeside(stringChunk("Missing:"))(missingDesc(pprefs)(x));
            })(msg.value1.value0);
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return stringChunk("The option `" + (msg.value0 + "` expects an argument."));
          }
          ;
          if (msg instanceof UnexpectedError) {
            var msg$prime = function() {
              var $105 = startsWith("-")(msg.value0);
              if ($105) {
                return "Invalid option `" + (msg.value0 + "'");
              }
              ;
              return "Invalid argument `" + (msg.value0 + "'");
            }();
            return stringChunk(msg$prime);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 196, column 30 - line 225, column 30): " + [msg.constructor.name]);
        }());
        var base_help = function(v) {
          var h = headerHelp(v.infoHeader);
          var f = footerHelp(v.infoFooter);
          if (show_full_help) {
            return fold15([h, f, parserHelp(pprefs)(v.infoParser)]);
          }
          ;
          return mempty10;
        };
        return function(progn) {
          var h = with_context(ctx)(pinfo)(function(names) {
            return function(pinfo$prime) {
              return fold15([base_help(pinfo$prime), usage_help(progn)(names)(pinfo$prime), suggestion_help, error_help]);
            };
          });
          return new Tuple(h, new Tuple(exit_code, new Tuple(un9(ParserPrefs)(pprefs).prefColumns, unit)));
        };
      };
    };
  };
};
var helper = /* @__PURE__ */ function() {
  return abortOption(ShowHelpText.value)(fold2(modMonoid)([$$long(optionFieldsHasName)("help"), $$short(optionFieldsHasName)("h"), help("Show this help text"), hidden]));
}();
var getProgName = /* @__PURE__ */ mapFlipped6(argv)(function(args) {
  return fromMaybe("")(bind28(index(args)(1))(function(executablePath) {
    return last(split("/")(executablePath));
  }));
});
var getArgs = /* @__PURE__ */ mapFlipped6(argv)(/* @__PURE__ */ drop(2));
var exitWith = function(c) {
  return exit$prime(fromEnum8(c));
};
var exitSuccess = /* @__PURE__ */ function() {
  return exit$prime(fromEnum8(Success.value));
}();
var handleParseResult = function(v) {
  if (v instanceof Success2) {
    return pure117(v.value0);
  }
  ;
  if (v instanceof Failure) {
    return function __do3() {
      var progn = getProgName();
      var v1 = renderFailure(v.value0)(progn);
      var stream2 = function() {
        if (v1.value1 instanceof Success) {
          return stdout;
        }
        ;
        return stderr;
      }();
      $$void12(writeString(stream2)(UTF8.value)(v1.value0 + "\n"))();
      return exitWith(v1.value1)();
    };
  }
  ;
  if (v instanceof CompletionInvoked) {
    return function __do3() {
      var progn = getProgName();
      var msg = un9(CompletionResult)(v.value0).execCompletion(progn)();
      $$void12(writeString(stdout)(UTF8.value)(msg))();
      return exitSuccess();
    };
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Extra (line 110, column 1 - line 110, column 58): " + [v.constructor.name]);
};
var execParserPure = function(pprefs) {
  return function(pinfo) {
    return function(args) {
      var pinfo$prime = over7(ParserInfo)(function(i) {
        return {
          infoFailureCode: i.infoFailureCode,
          infoFooter: i.infoFooter,
          infoFullDesc: i.infoFullDesc,
          infoHeader: i.infoHeader,
          infoPolicy: i.infoPolicy,
          infoProgDesc: i.infoProgDesc,
          infoParser: alt18(map310(Left.create)(bashCompletionParser(pinfo)(pprefs)))(map310(Right.create)(i.infoParser))
        };
      })(pinfo);
      var p = runParserInfo3(pinfo$prime)(fromFoldable20(args));
      var v = runP2(p)(pprefs);
      if (v.value0 instanceof Right && v.value0.value0 instanceof Right) {
        return new Success2(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Right && v.value0.value0 instanceof Left) {
        return new CompletionInvoked(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Left) {
        return new Failure(parserFailure(pprefs)(pinfo)(v.value0.value0)(v.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Extra (line 144, column 3 - line 147, column 73): " + [v.constructor.name]);
    };
  };
};
var customExecParser = function(pprefs) {
  return function(pinfo) {
    return bind112(map43(execParserPure(pprefs)(pinfo))(getArgs))(handleParseResult);
  };
};

// output/Whine.Runner.Cli/index.js
var fold16 = /* @__PURE__ */ fold(foldableArray);
var fold17 = /* @__PURE__ */ fold16(modMonoid);
var $$long3 = /* @__PURE__ */ $$long(flagFieldsHasName);
var $$short2 = /* @__PURE__ */ $$short(flagFieldsHasName);
var optional3 = /* @__PURE__ */ optional2(parserAlt)(parserApplicative);
var long12 = /* @__PURE__ */ $$long(optionFieldsHasName);
var apply10 = /* @__PURE__ */ apply(parserApply);
var map41 = /* @__PURE__ */ map(parserFunctor);
var fromFoldable21 = /* @__PURE__ */ fromFoldable5(foldableList);
var append19 = /* @__PURE__ */ append(prefsModSemigroup);
var Short = /* @__PURE__ */ function() {
  function Short2() {
  }
  ;
  Short2.value = new Short2();
  return Short2;
}();
var Long = /* @__PURE__ */ function() {
  function Long2() {
  }
  ;
  Long2.value = new Long2();
  return Long2;
}();
var CheckOnSave = /* @__PURE__ */ function() {
  function CheckOnSave2() {
  }
  ;
  CheckOnSave2.value = new CheckOnSave2();
  return CheckOnSave2;
}();
var CheckOnChange = /* @__PURE__ */ function() {
  function CheckOnChange2() {
  }
  ;
  CheckOnChange2.value = new CheckOnChange2();
  return CheckOnChange2;
}();
var JustWhine = /* @__PURE__ */ function() {
  function JustWhine2(value0) {
    this.value0 = value0;
  }
  ;
  JustWhine2.create = function(value0) {
    return new JustWhine2(value0);
  };
  return JustWhine2;
}();
var LanguageServer = /* @__PURE__ */ function() {
  function LanguageServer2(value0) {
    this.value0 = value0;
  }
  ;
  LanguageServer2.create = function(value0) {
    return new LanguageServer2(value0);
  };
  return LanguageServer2;
}();
var versionFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold17([/* @__PURE__ */ $$long3("version"), /* @__PURE__ */ $$short2("v"), /* @__PURE__ */ help("Print Whine version")]));
var quietFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold17([/* @__PURE__ */ $$long3("quiet"), /* @__PURE__ */ $$short2("q"), /* @__PURE__ */ help("Print no output")]));
var outputFormatOption = /* @__PURE__ */ function() {
  var parseOutputFormat = eitherReader(function(s) {
    var $29 = s === "short";
    if ($29) {
      return new Right(Short.value);
    }
    ;
    var $30 = s === "long";
    if ($30) {
      return new Right(Long.value);
    }
    ;
    return new Left("Invalid output format: " + s);
  });
  return optional3(option2(parseOutputFormat)(fold17([long12("output"), $$short(optionFieldsHasName)("o"), help("Output format. Possible values are 'short' and 'long'. Default is 'long'.")])));
}();
var justWhineArgsParser = /* @__PURE__ */ apply10(/* @__PURE__ */ map41(function(v) {
  return function(v1) {
    return {
      globs: fromFoldable21(mapMaybe2(fromString4)(v)),
      outputFormat: fromMaybe(Long.value)(v1)
    };
  };
})(/* @__PURE__ */ many2(/* @__PURE__ */ strArgument(/* @__PURE__ */ fold17([/* @__PURE__ */ metavar(argumentFieldsHasMetavar)("GLOB"), /* @__PURE__ */ help("Glob patterns to match files to lint. When empty, all files are linted.")])))))(outputFormatOption);
var determineLogLevel = function(args) {
  if (args.debug) {
    return LogDebug.value;
  }
  ;
  if (args.quiet) {
    return LogError.value;
  }
  ;
  return LogInfo.value;
};
var debugFlag = /* @__PURE__ */ $$switch(/* @__PURE__ */ fold17([/* @__PURE__ */ $$long3("debug"), /* @__PURE__ */ help("Print debug output")]));
var checkWhenOption = /* @__PURE__ */ function() {
  var checkWhen = eitherReader(function(s) {
    var $35 = s === "save";
    if ($35) {
      return new Right(CheckOnSave.value);
    }
    ;
    var $36 = s === "change";
    if ($36) {
      return new Right(CheckOnChange.value);
    }
    ;
    return new Left("Invalid value: " + s);
  });
  return optional3(option2(checkWhen)(fold17([long12("check-on"), help(fold16(monoidString)(["When to check files for violations. Possible values are ", "'", "save", "' to check when a file is saved or ", "'", "change", "' to check on every change. ", "Default is '", "save", "'."]))])));
}();
var languageServerArgsParser = /* @__PURE__ */ apply10(/* @__PURE__ */ apply10(/* @__PURE__ */ apply10(/* @__PURE__ */ map41(function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        return {
          checkWhen: fromMaybe(CheckOnSave.value)(v3)
        };
      };
    };
  };
})(/* @__PURE__ */ $$switch(/* @__PURE__ */ $$long3("stdio"))))(/* @__PURE__ */ $$switch(/* @__PURE__ */ $$long3("node-ipc"))))(/* @__PURE__ */ optional3(/* @__PURE__ */ strOption(/* @__PURE__ */ long12("socket")))))(checkWhenOption);
var commandParser = /* @__PURE__ */ function() {
  return subparser(command("language-server")(info3(map41(LanguageServer.create)(languageServerArgsParser))(progDesc("Start Whine in Language Server mode"))));
}();
var argsParser = /* @__PURE__ */ function() {
  return apply10(apply10(apply10(map41(function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return {
            command: v,
            version: v1,
            debug: v2,
            quiet: v3
          };
        };
      };
    };
  })(alt(parserAlt)(commandParser)(map41(JustWhine.create)(justWhineArgsParser))))(versionFlag))(debugFlag))(quietFlag);
}();
var parseCliArgs = function(dictMonadEffect) {
  return liftEffect(dictMonadEffect)(customExecParser(prefs(append19(showHelpOnError)(subparserInline)))(info3(apply10(helper)(argsParser))(progDesc("PureScript linter, extensible, with configurable rules, and one-off escape hatches"))));
};

// output/Whine.Bootstrap.Main/index.js
var bindWhineM5 = /* @__PURE__ */ bindWhineM(bindAff);
var bind29 = /* @__PURE__ */ bind(bindWhineM5);
var rightOrDie3 = /* @__PURE__ */ rightOrDie(loggableDecodeError);
var bind113 = /* @__PURE__ */ bind(bindEither);
var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);
var ordRecord3 = /* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(ordRecordNil)()({
  reflectSymbol: function() {
    return "package";
  }
})(ordString));
var lookup8 = /* @__PURE__ */ lookup3(ordRecord3);
var insert9 = /* @__PURE__ */ insert(ordRecord3);
var discard11 = /* @__PURE__ */ discard(discardUnit);
var discard15 = /* @__PURE__ */ discard11(bindWhineM5);
var applicativeWhineM4 = /* @__PURE__ */ applicativeWhineM(applicativeAff);
var when8 = /* @__PURE__ */ when(applicativeWhineM4);
var monadLogWhineM3 = /* @__PURE__ */ monadLogWhineM(monadEffectAff)(refl);
var logDebug4 = /* @__PURE__ */ logDebug(monadLogWhineM3)(loggableString);
var unlessM3 = /* @__PURE__ */ unlessM(/* @__PURE__ */ monadWhineM(monadAff));
var die3 = /* @__PURE__ */ die(loggableString);
var liftEffect6 = /* @__PURE__ */ liftEffect(/* @__PURE__ */ monadEffectWhineM(monadEffectAff));
var liftAff5 = /* @__PURE__ */ liftAff(/* @__PURE__ */ monadAffWhineM(monadAffAff));
var unless5 = /* @__PURE__ */ unless(applicativeWhineM4);
var eq26 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var logError3 = /* @__PURE__ */ logError(monadLogWhineM3)(loggableString);
var discard24 = /* @__PURE__ */ discard11(bindAff);
var when1 = /* @__PURE__ */ when(applicativeAff);
var log5 = /* @__PURE__ */ log3(monadEffectAff);
var liftEffect12 = /* @__PURE__ */ liftEffect(monadEffectAff);
var $$void13 = /* @__PURE__ */ $$void(functorAff);
var runWhineM2 = /* @__PURE__ */ runWhineM(monadEffectAff);
var entryPoint = /* @__PURE__ */ bind29(/* @__PURE__ */ readFile3("whine.yaml"))(function(configText) {
  return bind29(rightOrDie3(bind113(lmap4(basic)(parseYaml(configText)))(decode2(configCodec))))(function(config2) {
    var rulePackages = function() {
      var v = lookup8(fst(whineCorePackage))(config2.rulePackages);
      if (v instanceof Just && v.value0 instanceof JustPackage) {
        return uncurry(insert9)(whineCorePackage)(config2.rulePackages);
      }
      ;
      return config2.rulePackages;
    }();
    return bind29(getCache({
      rulePackages
    }))(function(cache) {
      return discard15(when8(cache.dirty)(discard15(logDebug4("Rebuilding the cached bundle"))(function() {
        return cache.rebuild;
      })))(function() {
        return discard15(unlessM3(exists2(cache.executable))(die3("Failed to rebuild Whine cache")))(function() {
          return bind29(liftEffect6(argv))(function(args) {
            return bind29(execa2(cache.executable)(drop(2)(args))(function(v) {
              return {
                cleanup: v.cleanup,
                preferLocal: v.preferLocal,
                stripFinalNewline: v.stripFinalNewline,
                extendEnv: v.extendEnv,
                cwd: v.cwd,
                env: v.env,
                encoding: v.encoding,
                argv0: v.argv0,
                ipc: v.ipc,
                stdioExtra: v.stdioExtra,
                detached: v.detached,
                uid: v.uid,
                gid: v.gid,
                shell: v.shell,
                timeout: v.timeout,
                maxBuffer: v.maxBuffer,
                windowsVerbatimArguments: v.windowsVerbatimArguments,
                windowsHide: v.windowsHide,
                windowsEnableCmdEcho: v.windowsEnableCmdEcho,
                stdin: new Just(inherit),
                stdout: new Just(inherit),
                stderr: new Just(inherit)
              };
            }))(function(whineProc) {
              return bind29(liftAff5(whineProc.getResult))(function(whineResult) {
                return discard15(unless5(eq26(whineResult.exitCode)(new Just(0)))(discard15(logDebug4(whineResult.stdout))(function() {
                  return logError3(whineResult.stderr);
                })))(function() {
                  return exit2(fromMaybe(1)(whineResult.exitCode));
                });
              });
            });
          });
        });
      });
    });
  });
});
var main = /* @__PURE__ */ launchAff_(/* @__PURE__ */ bind(bindAff)(/* @__PURE__ */ parseCliArgs(monadEffectAff))(function(args) {
  return discard24(when1(args.version)(discard24(log5(packages["whine-core"]))(function() {
    return liftEffect12(exit$prime(0));
  })))(function() {
    var env = {
      logLevel: determineLogLevel(args)
    };
    return $$void13(runWhineM2(env)(entryPoint));
  });
}));

// <stdin>
main();
